<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Divine Realms - God Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            overflow: hidden;
            cursor: grab;
            margin: 0;
            padding: 0;
        }
        
        body:active {
            cursor: grabbing;
        }
        
        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .panel {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            margin-bottom: 10px;
        }
        
        .power-bar {
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .power-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700 0%, #ffed4e 100%);
            width: 30%;
            transition: width 0.3s ease;
        }
        
        .speed-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .speed-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .speed-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .speed-btn.active {
            background: rgba(255, 215, 0, 0.3);
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        
        .current-speed {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 5px;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        
        @keyframes yearChange {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: #ffd700; }
            100% { transform: scale(1); }
        }
        
        .year-change {
            animation: yearChange 0.5s ease-out;
            display: inline-block;
        }
        
        .speed-indicator-fast {
            animation: pulse 1s infinite;
            color: #ffd700;
        }
        
        .pause-btn {
            background: rgba(255, 100, 100, 0.2);
            border-color: rgba(255, 100, 100, 0.5);
        }
        
        .pause-btn:hover {
            background: rgba(255, 100, 100, 0.3);
        }
        
        .pause-btn.active {
            background: rgba(255, 100, 100, 0.4);
            border-color: #ff6464;
        }
        
        .power-btn {
            position: relative;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 215, 0, 0.1) 100%);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ffd700;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .power-btn:hover:not(.disabled) {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3) 0%, rgba(255, 215, 0, 0.2) 100%);
            border-color: rgba(255, 215, 0, 0.8);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }
        
        .power-btn.active {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.4) 0%, rgba(255, 215, 0, 0.3) 100%);
            border-color: rgba(255, 215, 0, 1);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.7);
            transform: scale(1.08);
        }
        
        .power-btn.active:hover {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.5) 0%, rgba(255, 215, 0, 0.4) 100%);
            border-color: rgba(255, 215, 0, 1);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        }
        
        .power-btn.disabled {
            background: linear-gradient(135deg, rgba(100, 100, 100, 0.2) 0%, rgba(100, 100, 100, 0.1) 100%);
            border-color: rgba(100, 100, 100, 0.3);
            color: #666;
            cursor: not-allowed;
        }
        
        .power-btn.locked {
            background: linear-gradient(135deg, 
                rgba(40, 30, 25, 0.9) 0%, 
                rgba(25, 20, 15, 0.8) 50%,
                rgba(30, 25, 20, 0.9) 100%);
            border-color: rgba(80, 60, 40, 0.8);
            color: #554433;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .power-btn.locked svg {
            opacity: 0.2;
            filter: grayscale(100%) sepia(100%) saturate(200%) hue-rotate(15deg) brightness(0.6);
        }
        
        .power-btn.locked::before {
            content: '🔒';
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            opacity: 0.7;
            z-index: 10;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
            filter: sepia(100%) saturate(200%) hue-rotate(15deg) brightness(0.8);
        }
        
        /* Rust texture overlay */
        .power-btn.locked::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(140, 70, 20, 0.3) 0%, transparent 30%),
                radial-gradient(circle at 70% 60%, rgba(120, 60, 15, 0.2) 0%, transparent 25%),
                radial-gradient(circle at 40% 80%, rgba(100, 50, 10, 0.25) 0%, transparent 35%);
            pointer-events: none;
        }
        
        .power-btn.locked:hover {
            background: linear-gradient(135deg, 
                rgba(50, 40, 30, 0.9) 0%, 
                rgba(35, 25, 20, 0.8) 50%,
                rgba(40, 30, 25, 0.9) 100%);
            border-color: rgba(100, 75, 50, 0.9);
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.5),
                0 0 10px rgba(140, 100, 60, 0.3);
        }
        
        .power-btn.locked:hover::before {
            opacity: 0.8;
            animation: rustShake 0.3s ease-in-out;
        }
        
        @keyframes rustShake {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
            25% { transform: translate(-50%, -50%) rotate(-5deg); }
            75% { transform: translate(-50%, -50%) rotate(5deg); }
        }
        
        .power-btn.locked .power-cost {
            color: #ffd700;
            font-weight: bold;
        }
        
        .power-cost {
            position: absolute;
            bottom: -2px;
            right: 2px;
            font-size: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 4px;
            border-radius: 3px;
            color: #ffd700;
        }
        
        .power-radius {
            position: absolute;
            bottom: 2px;
            left: 2px;
            font-size: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 4px;
            border-radius: 3px;
            color: #ffd700;
        }
        
        .ability-tooltip {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
        }
        
        .power-btn:hover .ability-tooltip {
            opacity: 1;
        }
        
        /* Smite button specific styling */
        #smiteBtn {
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.2) 0%, rgba(50, 150, 255, 0.1) 100%);
            border-color: rgba(100, 200, 255, 0.5);
            color: #64c8ff;
        }
        
        #smiteBtn:hover:not(.disabled) {
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.3) 0%, rgba(50, 150, 255, 0.2) 100%);
            border-color: rgba(100, 200, 255, 0.8);
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.4);
        }
        
        #smiteBtn:hover:not(.disabled) svg {
            filter: drop-shadow(0 0 8px rgba(100, 200, 255, 1));
            transform: scale(1.1);
            transition: all 0.2s ease;
        }
        
        #smiteBtn svg {
            transition: all 0.2s ease;
        }
        
        #smiteBtn .power-cost,
        #smiteBtn .power-radius {
            color: #64c8ff;
        }
        
        .ability-container:has(#smiteBtn) .ability-name {
            color: #64c8ff;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }
        
        /* Disabled state for Smite button */
        #smiteBtn.disabled {
            background: linear-gradient(135deg, rgba(100, 100, 100, 0.2) 0%, rgba(100, 100, 100, 0.1) 100%);
            border-color: rgba(100, 100, 100, 0.3);
            color: #666;
        }
        
        #smiteBtn.disabled svg {
            filter: none;
            opacity: 0.5;
        }
        
        /* Active state for Smite button */
        #smiteBtn.active {
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.4) 0%, rgba(50, 150, 255, 0.3) 100%);
            border-color: rgba(100, 200, 255, 1);
            box-shadow: 0 0 25px rgba(100, 200, 255, 0.7);
            transform: scale(1.08);
        }
        
        #smiteBtn.active:hover {
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.5) 0%, rgba(50, 150, 255, 0.4) 100%);
            border-color: rgba(100, 200, 255, 1);
            box-shadow: 0 0 30px rgba(100, 200, 255, 0.8);
        }
        
        #smiteBtn.active svg {
            filter: drop-shadow(0 0 12px rgba(100, 200, 255, 1));
        }
        
        #smiteBtn.disabled .power-cost,
        #smiteBtn.disabled .power-radius {
            color: #666;
        }
        
        /* Bless button styling */
        #blessBtn svg {
            transition: all 0.2s ease;
        }
        
        #blessBtn:hover:not(.disabled) svg {
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 1));
            transform: scale(1.1);
        }
        
        /* Disabled state for Bless button */
        #blessBtn.disabled svg {
            filter: none;
            opacity: 0.5;
        }
        
        #blessBtn.disabled .power-cost {
            color: #666;
        }
        
        /* War button specific styling */
        #warBtn {
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.2) 0%, rgba(255, 50, 50, 0.1) 100%);
            border-color: rgba(255, 100, 100, 0.5);
            color: #ff6464;
        }
        
        #warBtn:hover:not(.disabled) {
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.3) 0%, rgba(255, 50, 50, 0.2) 100%);
            border-color: rgba(255, 100, 100, 0.8);
            box-shadow: 0 0 20px rgba(255, 100, 100, 0.4);
        }
        
        #warBtn:hover:not(.disabled) svg {
            filter: drop-shadow(0 0 8px rgba(255, 100, 100, 1));
            transform: scale(1.1);
            transition: all 0.2s ease;
        }
        
        #warBtn svg {
            transition: all 0.2s ease;
        }
        
        #warBtn .power-cost {
            color: #ff6464;
        }
        
        .ability-container:has(#warBtn) .ability-name {
            color: #ff6464;
            text-shadow: 0 0 10px rgba(255, 100, 100, 0.5);
        }
        
        /* Active state for War button */
        #warBtn.active {
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.4) 0%, rgba(255, 50, 50, 0.3) 100%);
            border-color: rgba(255, 100, 100, 1);
            box-shadow: 0 0 25px rgba(255, 100, 100, 0.7);
            transform: scale(1.08);
        }
        
        #warBtn.active:hover {
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.5) 0%, rgba(255, 50, 50, 0.4) 100%);
            border-color: rgba(255, 100, 100, 1);
            box-shadow: 0 0 30px rgba(255, 100, 100, 0.8);
        }
        
        #warBtn.active svg {
            filter: drop-shadow(0 0 12px rgba(255, 100, 100, 1));
        }
        
        /* Disabled state for War button */
        #warBtn.disabled {
            background: linear-gradient(135deg, rgba(100, 100, 100, 0.2) 0%, rgba(100, 100, 100, 0.1) 100%);
            border-color: rgba(100, 100, 100, 0.3);
            color: #666;
        }
        
        #warBtn.disabled svg {
            filter: none;
            opacity: 0.5;
        }
        
        #warBtn.disabled .power-cost {
            color: #666;
        }
        
        /* Peace button specific styling */
        #peaceBtn {
            background: linear-gradient(135deg, rgba(255, 223, 186, 0.2) 0%, rgba(255, 235, 205, 0.1) 100%);
            border-color: rgba(255, 223, 186, 0.5);
            color: #ffdba8;
        }
        
        .ability-container:has(#peaceBtn) .ability-name {
            color: #ffdba8;
        }
        
        #peaceBtn .power-cost {
            color: #ffdba8;
        }
        
        /* Portal button specific styling */
        #portalBtn {
            background: radial-gradient(circle at 30% 30%, rgba(75, 0, 130, 0.3), rgba(75, 0, 130, 0.1));
            border-color: #4B0082;
        }
        
        .ability-container:has(#portalBtn) .ability-name {
            color: #9370DB;
        }
        
        #portalBtn .power-cost {
            color: #9370DB;
        }
        
        /* Kingdom button specific styling */
        #kingdomBtn {
            background: radial-gradient(circle at 30% 30%, rgba(128, 128, 128, 0.3), rgba(128, 128, 128, 0.1));
            border-color: #808080;
        }
        
        .ability-container:has(#kingdomBtn) .ability-name {
            color: #808080;
        }
        
        #kingdomBtn .power-cost {
            color: #808080;
        }
        
        /* Terraform button specific styling */
        #terraformBtn {
            background: radial-gradient(circle at 30% 30%, rgba(210, 105, 30, 0.3), rgba(210, 105, 30, 0.1));
            border-color: #D2691E;
        }
        
        .ability-container:has(#terraformBtn) .ability-name {
            color: #D2691E;
        }
        
        #terraformBtn .power-cost {
            color: #D2691E;
        }
        
        /* Sculpt button specific styling */
        #sculptBtn {
            background: radial-gradient(circle at 30% 30%, rgba(139, 69, 19, 0.3), rgba(101, 67, 33, 0.1));
            border-color: #8B4513;
        }
        
        .ability-container:has(#sculptBtn) .ability-name {
            color: #8B4513;
        }
        
        #sculptBtn .power-cost {
            color: #8B4513;
        }
        
        #peaceBtn:hover:not(.disabled) {
            background: linear-gradient(135deg, rgba(255, 223, 186, 0.3) 0%, rgba(255, 235, 205, 0.2) 100%);
            border-color: rgba(255, 223, 186, 0.8);
            box-shadow: 0 0 20px rgba(255, 223, 186, 0.4);
        }
        
        #peaceBtn:hover:not(.disabled) svg {
            filter: drop-shadow(0 0 8px rgba(255, 223, 186, 1));
            transform: scale(1.1);
            transition: all 0.2s ease;
        }
        
        /* Active state for Peace button */
        #peaceBtn.active {
            background: linear-gradient(135deg, rgba(255, 223, 186, 0.4) 0%, rgba(255, 235, 205, 0.3) 100%);
            border-color: rgba(255, 223, 186, 1);
            box-shadow: 0 0 25px rgba(255, 223, 186, 0.7);
            transform: scale(1.08);
        }
        
        #peaceBtn.active::after {
            opacity: 1;
            border-color: rgba(255, 223, 186, 0.8);
        }
        
        #peaceBtn.active svg {
            filter: drop-shadow(0 0 12px rgba(255, 223, 186, 1));
        }
        
        /* Disabled state for Peace button */
        #peaceBtn.disabled {
            background: linear-gradient(135deg, rgba(100, 100, 100, 0.2) 0%, rgba(100, 100, 100, 0.1) 100%);
            border-color: rgba(100, 100, 100, 0.3);
            color: #666;
        }
        
        #peaceBtn.disabled .power-cost {
            color: #666;
        }
        
        #peaceBtn.disabled svg {
            filter: none;
            opacity: 0.5;
        }
        
        /* Portal button hover state */
        #portalBtn:hover:not(.disabled) {
            background: linear-gradient(135deg, rgba(147, 112, 219, 0.4) 0%, rgba(75, 0, 130, 0.3) 100%);
            border-color: rgba(147, 112, 219, 0.9);
            box-shadow: 0 0 25px rgba(147, 112, 219, 0.6);
        }
        
        #portalBtn:hover:not(.disabled) svg {
            filter: drop-shadow(0 0 10px rgba(147, 112, 219, 1));
            transform: scale(1.1);
            transition: all 0.2s ease;
        }
        
        /* Portal button active state */
        #portalBtn.active {
            background: linear-gradient(135deg, rgba(147, 112, 219, 0.5) 0%, rgba(75, 0, 130, 0.4) 100%);
            border-color: rgba(147, 112, 219, 1);
            box-shadow: 0 0 30px rgba(147, 112, 219, 0.8);
            transform: scale(1.08);
        }
        
        #portalBtn.active::after {
            opacity: 1;
            border-color: rgba(147, 112, 219, 0.8);
        }
        
        #portalBtn.active svg {
            filter: drop-shadow(0 0 15px rgba(147, 112, 219, 1));
        }
        
        /* Portal button disabled state */
        #portalBtn.disabled {
            background: linear-gradient(135deg, rgba(100, 100, 100, 0.2) 0%, rgba(100, 100, 100, 0.1) 100%);
            border-color: rgba(100, 100, 100, 0.3);
            color: #666;
        }
        
        #portalBtn.disabled .power-cost {
            color: #666;
        }
        
        #portalBtn.disabled svg {
            filter: none;
            opacity: 0.5;
        }
        
        /* AOE slider styles */
        .aoe-slider-container {
            display: flex;
            align-items: center;
            margin: 4px 0;
            gap: 3px;
            font-size: 11px;
            font-weight: bold;
            padding: 0 5px;
            opacity: 0.9;
            transition: opacity 0.2s ease;
            height: 20px;
        }
        
        .ability-container:hover .aoe-slider-container {
            opacity: 1;
        }
        
        .aoe-slider-container span:first-child {
            min-width: 28px;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
        }
        
        .aoe-slider {
            width: 55px;
            height: 5px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, 
                rgba(255, 255, 255, 0.1) 0%, 
                rgba(255, 255, 255, 0.2) 100%);
            outline: none;
            border-radius: 3px;
            cursor: pointer;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
            margin: 0 2px;
        }
        
        /* Custom slider track colors */
        #smiteAoeSlider {
            background: linear-gradient(to right, 
                rgba(100, 200, 255, 0.2) 0%, 
                rgba(100, 200, 255, 0.4) 100%);
        }
        
        #terraformAoeSlider {
            background: linear-gradient(to right, 
                rgba(210, 105, 30, 0.2) 0%, 
                rgba(210, 105, 30, 0.4) 100%);
        }
        
        #sculptAoeSlider {
            background: linear-gradient(to right, 
                rgba(139, 69, 19, 0.2) 0%, 
                rgba(139, 69, 19, 0.4) 100%);
        }
        
        .aoe-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 255, 255, 0.3), 
                currentColor 40%);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.6),
                        0 0 0 1px rgba(255, 255, 255, 0.2);
            transition: transform 0.1s ease;
        }
        
        .aoe-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        
        .aoe-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 255, 255, 0.3), 
                currentColor 40%);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.6),
                        0 0 0 1px rgba(255, 255, 255, 0.2);
            border: none;
            transition: transform 0.1s ease;
        }
        
        .aoe-slider::-moz-range-thumb:hover {
            transform: scale(1.1);
        }
        
        .aoe-value {
            min-width: 18px;
            text-align: center;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
            font-size: 12px;
            font-weight: bold;
        }
        
        /* Kingdom button disabled state */
        #kingdomBtn.disabled {
            background: linear-gradient(135deg, rgba(100, 100, 100, 0.2) 0%, rgba(100, 100, 100, 0.1) 100%);
            border-color: rgba(100, 100, 100, 0.3);
            color: #666;
        }
        
        #kingdomBtn.disabled .power-cost {
            color: #666;
        }
        
        #kingdomBtn.disabled svg {
            filter: none;
            opacity: 0.5;
        }
        
        /* Terraform button disabled state */
        #terraformBtn.disabled {
            background: linear-gradient(135deg, rgba(100, 100, 100, 0.2) 0%, rgba(100, 100, 100, 0.1) 100%);
            border-color: rgba(100, 100, 100, 0.3);
            color: #666;
        }
        
        #terraformBtn.disabled .power-cost {
            color: #666;
        }
        
        #terraformBtn.disabled svg {
            filter: none;
            opacity: 0.5;
        }
        
        /* Sculpt button disabled state */
        #sculptBtn.disabled {
            background: linear-gradient(135deg, rgba(100, 100, 100, 0.2) 0%, rgba(100, 100, 100, 0.1) 100%);
            border-color: rgba(100, 100, 100, 0.3);
            color: #666;
        }
        
        #sculptBtn.disabled .power-cost {
            color: #666;
        }
        
        #sculptBtn.disabled svg {
            filter: none;
            opacity: 0.5;
        }
        
        /* General rule for disabled button ability names */
        .ability-container:has(.power-btn.disabled) .ability-name {
            color: #666 !important;
        }
        
        /* General rule for locked button ability names */
        .ability-container:has(.power-btn.locked) .ability-name {
            color: #665544 !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        #abilityPanel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0.6) 100%);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px 20px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }
        
        .ability-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-height: 120px;
            justify-content: flex-end;
        }
        
        .ability-name {
            color: #ffd700;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            margin-bottom: 0;
        }
        
        .ability-aoe {
            font-size: 11px;
            font-weight: normal;
            margin-top: -4px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div class="panel">
            <h3>Divine Power</h3>
            <div class="power-bar">
                <div class="power-fill"></div>
            </div>
            <p style="margin-top: 5px; font-size: 12px;">Temples: <span id="templeCount">0</span></p>
            <p style="margin-top: 5px; font-size: 12px;">Year: <span id="gameYear">1</span></p>
            <p style="margin-top: 5px; font-size: 12px;">Power: <span id="powerAmount">10/10</span></p>
        </div>
        <div class="panel">
            <p>View: <span id="viewMode">Ethereal</span></p>
            <p>Zoom: <span id="zoom">1.0x</span></p>
            <p>FPS: <span id="fps">60</span> | TPS: <span id="tps">30</span></p>
        </div>
        <div class="panel">
            <div class="current-speed">
                <strong>Time:</strong> <span id="currentSpeed">5x</span>
            </div>
            <div class="speed-controls">
                <button class="speed-btn pause-btn" data-speed="0" title="Pause (Space)">⏸</button>
                <button class="speed-btn" data-speed="1" title="Normal Speed (1)">1x</button>
                <button class="speed-btn" data-speed="2" title="Fast (2)">2x</button>
                <button class="speed-btn active" data-speed="5" title="Faster (3)">5x</button>
            </div>
            <div class="speed-controls" style="margin-top: 5px;">
                <button class="speed-btn" data-speed="10" title="Very Fast (4)">10x</button>
                <button class="speed-btn" data-speed="25" title="Ultra Fast (5)">25x</button>
                <button class="speed-btn" data-speed="50" title="Maximum Speed (6)">50x</button>
                <button class="speed-btn" data-speed="100" title="Ludicrous Speed (7)">100x</button>
                <button class="speed-btn" data-speed="200" title="Divine Speed (8) - WARNING: May cause performance issues">200x ⚠️</button>
            </div>
            <p style="font-size: 11px; color: #aaa; margin-top: 5px;">Press 1-8 or Space</p>
        </div>
        <div class="panel" id="kingdomInfo" style="display: none;">
            <h4 id="kingdomName">Kingdom</h4>
            <p>Territory: <span id="kingdomTerritory">0</span> tiles</p>
            <p>Troops: <span id="kingdomTroops">0</span> / <span id="kingdomTroopCap">25</span></p>
            <p>State: <span id="kingdomState">Expanding</span></p>
            <p id="warWeariness" style="font-size: 11px; color: #aaa;"></p>
            <p id="blessCostInfo" style="font-size: 11px; color: #ffd700;"></p>
        </div>
    </div>
    
    <div id="abilityPanel">
        <div class="ability-container">
            <div class="ability-name">Smite</div>
            <div class="aoe-slider-container" style="color: #64c8ff;">
                <span>AOE:</span>
                <input type="range" class="aoe-slider" id="smiteAoeSlider" min="2" max="25" value="2" step="1" style="color: #64c8ff;">
                <span class="aoe-value" id="smiteAoeDisplay">2</span>
            </div>
            <button class="power-btn" id="smiteBtn" data-cost="12">
                <svg width="28" height="28" viewBox="0 0 28 28" style="filter: drop-shadow(0 0 4px rgba(100, 200, 255, 0.8));">
                    <path d="M16 2 L10 12 L15 12 L12 26 L18 14 L13 14 Z" 
                          fill="#64c8ff" 
                          stroke="#ffffff" 
                          stroke-width="0.5"
                          stroke-linejoin="round"/>
                </svg>
                <div class="ability-tooltip" id="smiteTooltip">Strike down armies and burn structures in 2 tile radius (12 power)</div>
                <div class="power-radius" id="smiteRadius">2</div>
                <div class="power-cost" id="smiteCost">12</div>
            </button>
        </div>
        <div class="ability-container">
            <div class="ability-name">Bless</div>
            <div style="height: 20px; margin: 4px 0;"></div>
            <button class="power-btn" id="blessBtn" data-cost="20">
                <svg width="28" height="28" viewBox="0 0 28 28" style="filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.8));">
                    <!-- Center sparkle -->
                    <path d="M14 4 L15 12 L14 14 L13 12 Z" fill="#ffd700" stroke="#ffffff" stroke-width="0.5"/>
                    <path d="M8 14 L12 13 L14 14 L12 15 Z" fill="#ffd700" stroke="#ffffff" stroke-width="0.5"/>
                    <path d="M20 14 L16 13 L14 14 L16 15 Z" fill="#ffd700" stroke="#ffffff" stroke-width="0.5"/>
                    <path d="M14 24 L13 16 L14 14 L15 16 Z" fill="#ffd700" stroke="#ffffff" stroke-width="0.5"/>
                    <!-- Small sparkles -->
                    <circle cx="7" cy="7" r="1.5" fill="#ffd700" stroke="#ffffff" stroke-width="0.3"/>
                    <circle cx="21" cy="7" r="1.5" fill="#ffd700" stroke="#ffffff" stroke-width="0.3"/>
                    <circle cx="7" cy="21" r="1.5" fill="#ffd700" stroke="#ffffff" stroke-width="0.3"/>
                    <circle cx="21" cy="21" r="1.5" fill="#ffd700" stroke="#ffffff" stroke-width="0.3"/>
                </svg>
                <div class="ability-tooltip">Triple recruit generation for 5 years (cost = kingdom tiles)</div>
                <div class="power-cost" id="blessCost">?</div>
            </button>
        </div>
        <div class="ability-container">
            <div class="ability-name">War</div>
            <div style="height: 20px; margin: 4px 0;"></div>
            <button class="power-btn" id="warBtn" data-cost="50">
                <svg width="28" height="28" viewBox="0 0 28 28" style="filter: drop-shadow(0 0 4px rgba(255, 100, 100, 0.8));">
                    <!-- Crossed swords -->
                    <path d="M6 6 L18 18 L16 20 L14 18 L10 22 L8 20 L12 16 L10 14 L8 16 L6 6 Z" 
                          fill="#ff6464" 
                          stroke="#ffffff" 
                          stroke-width="0.5"/>
                    <path d="M22 6 L10 18 L12 20 L14 18 L18 22 L20 20 L16 16 L18 14 L20 16 L22 6 Z" 
                          fill="#ff6464" 
                          stroke="#ffffff" 
                          stroke-width="0.5"/>
                    <!-- Sword handles -->
                    <circle cx="6" cy="6" r="2" fill="#444" stroke="#ffffff" stroke-width="0.5"/>
                    <circle cx="22" cy="6" r="2" fill="#444" stroke="#ffffff" stroke-width="0.5"/>
                </svg>
                <div class="ability-tooltip">Declare war between two kingdoms for 5 years (50 power)</div>
                <div class="power-cost" id="warCost">50</div>
            </button>
        </div>
        <div class="ability-container">
            <div class="ability-name">Peace</div>
            <div style="height: 20px; margin: 4px 0;"></div>
            <button class="power-btn" id="peaceBtn" data-cost="30">
                <svg width="28" height="28" viewBox="0 0 28 28" style="filter: drop-shadow(0 0 4px rgba(255, 223, 186, 0.8));">
                    <!-- Peace symbol -->
                    <circle cx="14" cy="14" r="10" fill="none" stroke="#ffdba8" stroke-width="2"/>
                    <!-- Peace sign inside -->
                    <path d="M14 4 L14 24 M14 14 L7 21 M14 14 L21 21" 
                          stroke="#ffdba8" 
                          stroke-width="2"
                          stroke-linecap="round"
                          fill="none"/>
                </svg>
                <div class="ability-tooltip">Create peace between two warring kingdoms (30 power)</div>
                <div class="power-cost" id="peaceCost">30</div>
            </button>
        </div>
        <div class="ability-container">
            <div class="ability-name">Portal</div>
            <div style="height: 20px; margin: 4px 0;"></div>
            <button class="power-btn" id="portalBtn" data-cost="40">
                <svg width="28" height="28" viewBox="0 0 28 28" style="filter: drop-shadow(0 0 4px rgba(75, 0, 130, 0.8));">
                    <!-- Portal oval -->
                    <ellipse cx="14" cy="14" rx="8" ry="12" fill="none" stroke="#9370DB" stroke-width="2"/>
                    <!-- Inner spiral -->
                    <path d="M14 6 Q20 14 14 22 Q8 14 14 6" 
                          fill="none" 
                          stroke="#9370DB" 
                          stroke-width="1.5"
                          opacity="0.8"/>
                    <!-- Center glow -->
                    <circle cx="14" cy="14" r="3" fill="#9370DB" opacity="0.6"/>
                    <circle cx="14" cy="14" r="1.5" fill="#ffffff" opacity="0.8"/>
                </svg>
                <div class="ability-tooltip">Connect two tiles with a divine portal lasting 100 years (40 power)</div>
                <div class="power-cost" id="portalCost">40</div>
            </button>
        </div>
        <div class="ability-container">
            <div class="ability-name">Kingdom</div>
            <div style="height: 20px; margin: 4px 0;"></div>
            <button class="power-btn" id="kingdomBtn" data-cost="50">
                <svg width="28" height="28" viewBox="0 0 28 28" style="filter: drop-shadow(0 0 4px rgba(128, 128, 128, 0.8));">
                    <!-- Crown base -->
                    <rect x="6" y="16" width="16" height="6" fill="#C0C0C0" stroke="#808080" stroke-width="1"/>
                    <!-- Crown points -->
                    <path d="M6 16 L6 10 L9 14 L14 8 L19 14 L22 10 L22 16 Z" 
                          fill="#C0C0C0" 
                          stroke="#808080" 
                          stroke-width="1"/>
                    <!-- Crown jewels -->
                    <circle cx="9" cy="18" r="1.5" fill="#ff69b4"/>
                    <circle cx="14" cy="18" r="1.5" fill="#40e0d0"/>
                    <circle cx="19" cy="18" r="1.5" fill="#ff69b4"/>
                </svg>
                <div class="ability-tooltip">Create a new kingdom with a capital on an empty tile (50 power)</div>
                <div class="power-cost" id="kingdomCost">50</div>
            </button>
        </div>
        <div class="ability-container">
            <div class="ability-name">Terraform</div>
            <div class="aoe-slider-container" style="color: #D2691E;">
                <span>AOE:</span>
                <input type="range" class="aoe-slider" id="terraformAoeSlider" min="1" max="15" value="8" step="1" style="color: #D2691E;">
                <span class="aoe-value" id="terraformAoeDisplay">8</span>
            </div>
            <button class="power-btn" id="terraformBtn" data-cost="25">
                <svg width="28" height="28" viewBox="0 0 28 28" style="filter: drop-shadow(0 0 4px rgba(210, 105, 30, 0.8));">
                    <!-- Mountain peaks -->
                    <path d="M4 20 L9 10 L14 16 L19 8 L24 20 Z" 
                          fill="#D2691E" 
                          stroke="#A0522D" 
                          stroke-width="1"/>
                    <!-- Snow caps -->
                    <path d="M9 10 L7 14 L11 14 Z" fill="#ffffff" opacity="0.8"/>
                    <path d="M19 8 L17 12 L21 12 Z" fill="#ffffff" opacity="0.8"/>
                    <!-- Valleys -->
                    <path d="M4 20 L24 20" stroke="#228b22" stroke-width="2"/>
                </svg>
                <div class="ability-tooltip">Click and drag to raise or lower terrain (25 power)</div>
                <div class="power-cost" id="terraformCost">25</div>
            </button>
        </div>
        
        <div class="ability-container">
            <div class="ability-name">Sculpt</div>
            <div class="aoe-slider-container" style="color: #8B4513;">
                <span>AOE:</span>
                <input type="range" class="aoe-slider" id="sculptAoeSlider" min="1" max="10" value="3" step="1" style="color: #8B4513;">
                <span class="aoe-value" id="sculptAoeDisplay">3</span>
            </div>
            <button class="power-btn" id="sculptBtn" data-cost="15">
                <svg width="28" height="28" viewBox="0 0 28 28" style="filter: drop-shadow(0 0 4px rgba(139, 69, 19, 0.8));">
                    <!-- Isometric tile -->
                    <path d="M14 4 L23 9 L14 14 L5 9 Z" fill="#8B4513" stroke="#654321" stroke-width="1.5"/>
                    <path d="M5 9 L5 18 L14 23 L14 14 Z" fill="#6B3410" stroke="#654321" stroke-width="1.5"/>
                    <path d="M14 14 L14 23 L23 18 L23 9 Z" fill="#7A3F15" stroke="#654321" stroke-width="1.5"/>
                    <!-- Minus symbol on left -->
                    <text x="2" y="15" font-size="11" fill="#ff0000" font-weight="bold" text-anchor="middle" dominant-baseline="middle">−</text>
                    <!-- Plus symbol on right -->
                    <text x="26" y="15" font-size="11" fill="#00ff00" font-weight="bold" text-anchor="middle" dominant-baseline="middle">+</text>
                </svg>
                <div class="ability-tooltip">Click to add or remove tiles (15 power)</div>
                <div class="power-cost" id="sculptCost">15</div>
            </button>
        </div>
    </div>
    
    <script>
        'use strict';
        
        // Polyfill for roundRect
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                return this;
            };
        }
        
        // Canvas setup
        var canvas = document.getElementById('gameCanvas');
        var ctx = canvas.getContext('2d');
        
        // Function to resize canvas to window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        // Initial resize
        resizeCanvas();
        
        // Handle window resize
        window.addEventListener('resize', resizeCanvas);
        
        // Gradient cache for performance
        var gradientCache = {
            wallGradients: new Map(), // Key: "r,g,b,type" Value: gradient
            skyGradients: {},
            borderCache: new Map(), // Key: "worldId,tick" Value: Map of "x,y" -> isBorder
            tileColors: new Map(), // Key: "worldColor,elevation" Value: rgb string
            worldRGB: new Map(), // Key: hex color Value: {r, g, b}
            isoCoords: new Map(), // Key: "x,y" Value: {x, y}
            tilePath: null, // Pre-rendered tile shape
            kingdomBlendColors: new Map(), // Key: "color1,color2,strength" Value: rgb string
            bannerDesigns: new Map() // Key: kingdom.id Value: pre-rendered banner canvas
        };
        
        // Spatial indexing for faster lookups
        var spatialIndex = {
            // Grid-based spatial index for kingdom territories
            territoryGrids: new Map(), // Key: worldId, Value: 10x10 grid of Set<kingdomId>
            // Border tiles for each kingdom
            kingdomBorders: new Map(), // Key: kingdomId, Value: Set of "x,y" strings
            // Cached neighbor data
            tileNeighbors: new Map(), // Key: "x,y" Value: array of {x,y} neighbors
            // Entity spatial indexing for distance calculations
            entityChunks: new Map(), // Key: worldId, Value: Map of chunkKey -> Set of entities
            // Last update tick for each index
            lastUpdate: new Map(),
            // Batch updates for performance
            pendingUpdates: new Map() // Key: worldId, Value: Set of entities to update
        };
        
        // Global neighbor cache with permanent storage
        const neighborCache = new Map(); // Key: "x,y,worldId" Value: array of valid neighbor positions
        
        function getNeighborsWithCache(x, y, worldId) {
            const key = `${x},${y},${worldId}`;
            
            if (!neighborCache.has(key)) {
                const neighbors = [];
                const candidates = [
                    {x: x-1, y: y}, {x: x+1, y: y},
                    {x: x, y: y-1}, {x: x, y: y+1}
                ];
                
                for (const pos of candidates) {
                    if (pos.x >= 0 && pos.x < WORLD_SIZE && 
                        pos.y >= 0 && pos.y < WORLD_SIZE) {
                        neighbors.push(pos);
                    }
                }
                
                neighborCache.set(key, neighbors);
            }
            
            return neighborCache.get(key);
        }
        
        const CHUNK_SIZE = 8; // 8x8 chunks for a 64x64 world = 8x8 chunks
        
        function getChunkKey(x, y) {
            const chunkX = Math.floor(x / CHUNK_SIZE);
            const chunkY = Math.floor(y / CHUNK_SIZE);
            return `${chunkX},${chunkY}`;
        }
        
        function updateEntityChunk(entity, worldId, immediate = false) {
            // If not immediate, add to pending updates for batch processing
            if (!immediate && game.timeScale >= 10) {
                const pending = spatialIndex.pendingUpdates.get(worldId) || new Set();
                pending.add(entity);
                spatialIndex.pendingUpdates.set(worldId, pending);
                return;
            }
            
            const chunks = spatialIndex.entityChunks.get(worldId) || new Map();
            
            // Remove from old chunk if it exists
            if (entity._chunkKey) {
                const oldChunk = chunks.get(entity._chunkKey);
                if (oldChunk) {
                    oldChunk.delete(entity);
                }
            }
            
            // Add to new chunk
            const newChunkKey = getChunkKey(entity.x, entity.y);
            const newChunk = chunks.get(newChunkKey) || new Set();
            newChunk.add(entity);
            chunks.set(newChunkKey, newChunk);
            
            entity._chunkKey = newChunkKey;
            spatialIndex.entityChunks.set(worldId, chunks);
        }
        
        // Process batch updates
        function processBatchChunkUpdates() {
            for (const [worldId, entities] of spatialIndex.pendingUpdates) {
                const chunks = spatialIndex.entityChunks.get(worldId) || new Map();
                
                for (const entity of entities) {
                    // Remove from old chunk if exists
                    if (entity._chunkKey) {
                        const oldChunk = chunks.get(entity._chunkKey);
                        if (oldChunk) {
                            oldChunk.delete(entity);
                        }
                    }
                    
                    const newChunkKey = getChunkKey(entity.x, entity.y);
                    const newChunk = chunks.get(newChunkKey) || new Set();
                    newChunk.add(entity);
                    chunks.set(newChunkKey, newChunk);
                    entity._chunkKey = newChunkKey;
                }
                
                spatialIndex.entityChunks.set(worldId, chunks);
            }
            
            spatialIndex.pendingUpdates.clear();
        }
        
        function getNearbyEntities(x, y, radius, worldId, entityType) {
            const chunks = spatialIndex.entityChunks.get(worldId);
            if (!chunks) return [];
            
            const chunkRadius = Math.ceil(radius / CHUNK_SIZE);
            const centerChunkX = Math.floor(x / CHUNK_SIZE);
            const centerChunkY = Math.floor(y / CHUNK_SIZE);
            
            const nearbyEntities = [];
            
            for (let dx = -chunkRadius; dx <= chunkRadius; dx++) {
                for (let dy = -chunkRadius; dy <= chunkRadius; dy++) {
                    const chunkKey = `${centerChunkX + dx},${centerChunkY + dy}`;
                    const chunk = chunks.get(chunkKey);
                    if (chunk) {
                        for (const entity of chunk) {
                            if (!entityType || entity.constructor.name === entityType) {
                                const dist = Math.abs(entity.x - x) + Math.abs(entity.y - y);
                                if (dist <= radius) {
                                    nearbyEntities.push(entity);
                                }
                            }
                        }
                    }
                }
            }
            
            return nearbyEntities;
        }
        
        // Create pre-rendered tile path
        gradientCache.tilePath = new Path2D();
        gradientCache.tilePath.moveTo(0, -17);
        gradientCache.tilePath.lineTo(33, 0);
        gradientCache.tilePath.lineTo(0, 17);
        gradientCache.tilePath.lineTo(-33, 0);
        gradientCache.tilePath.closePath();
        
        
        // Game state
        var game = {
            tickRate: 12,
            lastTick: 0,
            tickAccumulator: 0,
            currentTick: 0,
            fps: 60,
            lastFpsUpdate: 0,
            frameCount: 0,
            
            // Time control
            timeScale: 5, // Changed default from 1 to 5
            isPaused: false,
            maxTicksPerFrame: 200, // Increased to handle 6000 TPS (30 base * 200 = 6000)
            ticksPerSecond: 0,
            tickCount: 0,
            lastTpsUpdate: 0,
            
            // Player stats
            power: 10,
            maxPower: 10,
            temples: [],
            templeCount: 0,
            
            // Divine abilities
            abilities: {
                smite: {
                    cost: 78, // Will be dynamic based on radius
                    active: false,
                    targetX: 0,
                    targetY: 0,
                    radius: 2, // Current smite radius
                    minRadius: 2,
                    maxRadius: 25,
                    unlocked: true, // Smite starts unlocked
                    unlockCost: 0,
                    order: 0
                },
                bless: {
                    cost: 20,
                    active: false,
                    unlocked: false,
                    templeRequirement: 10, // Requires 10 temples to unlock
                    order: 1
                },
                war: {
                    cost: 50,
                    active: false,
                    firstKingdom: null,
                    secondKingdom: null,
                    unlocked: false,
                    templeRequirement: 14, // 10 * 1.35 rounded up
                    order: 2
                },
                peace: {
                    cost: 30,
                    active: false,
                    firstKingdom: null,
                    secondKingdom: null,
                    unlocked: false,
                    templeRequirement: 19, // 14 * 1.35 rounded up
                    order: 3
                },
                portal: {
                    cost: 40,
                    active: false,
                    firstTile: null,
                    secondTile: null,
                    unlocked: false,
                    templeRequirement: 26, // 19 * 1.35 rounded up
                    order: 4
                },
                kingdom: {
                    cost: 50,
                    active: false,
                    unlocked: false,
                    templeRequirement: 35, // 26 * 1.35 rounded down
                    order: 5
                },
                terraform: {
                    cost: 25,
                    active: false,
                    isDragging: false,
                    startTile: null,
                    startHeight: null,
                    dragStartY: null,
                    radius: 8, // Default terraform radius
                    unlocked: false,
                    templeRequirement: 47, // 35 * 1.35 rounded down
                    order: 6
                },
                sculpt: {
                    cost: 15,
                    active: false,
                    radius: 3, // Default sculpt radius
                    unlocked: false,
                    templeRequirement: 63, // 47 * 1.35 rounded down
                    order: 7
                }
            },
            
            // Active blessings
            blessedKingdoms: {}, // kingdomId -> expireTick
            
            // Active wars
            activeWars: [], // Array of {attacker: kingdomId, defender: kingdomId, startTick: tick, endTick: tick}
            
            // Active truces
            truces: [], // Array of {kingdom1: kingdomId, kingdom2: kingdomId, startTick: tick, endTick: tick}
            
            // Burned structures
            burnedCapitals: {}, // "x,y,worldId" -> recoveryTick
            burnedVillages: {}, // "x,y,worldId" -> recoveryTick
            
            // Effects & Cross-World
            battles: [],
            armySpawns: [],
            portals: [],
            divineEffects: [], // New array for particle effects
            sweatParticles: [], // Array for insufficient power feedback particles
            sweatParticleTimer: 0, // Timer for continuous sweat emission
            
            // Dirty tile tracking for optimized rendering
            dirtyTiles: new Map(), // Key: "worldId,x,y" Value: true
            tileCache: new Map(), // Key: "worldId" Value: OffscreenCanvas
            lastRenderState: new Map(), // Key: "worldId" Value: {zoom, cameraX, cameraY}
            
            // Giant Fish for Aqua world
            giantFish: {
                active: false,
                x: 0,
                y: 0,
                targetX: 0,
                targetY: 0,
                phase: 'waiting', // 'entering', 'watching', 'exiting', 'waiting'
                watchTimer: 0,
                watchDuration: 600, // ticks to stay in center (doubled)
                waitTimer: 0,
                waitDuration: 1800, // ticks between appearances (3 years)
                speed: 0.08, // Even slower movement
                currentSpeed: 0, // Current actual speed for smooth acceleration
                maxSpeed: 0.08,
                acceleration: 0.002, // How quickly it speeds up/slows down
                scale: 9.0,
                facingRight: true, // Direction the fish is facing
                eyeAngle: 0,
                targetEyeAngle: 0,
                trackedArmy: null,
                trackedRecruit: null,
                lastTrackedPosition: null,
                bodyWave: 0, // For undulating movement
                finWave: 0, // For fin animation
                glowIntensity: 0.7,
                entryDirection: 0, // Remember which direction it came from
                movementAngle: 0, // Angle of movement to continue after watching
                shadowOpacity: 0, // Current shadow opacity for smooth fading
                lastX: 0, // Previous X position for particle direction
                lastY: 0 // Previous Y position for particle direction
            },
            
            // Terra Witch
            terraWitch: {
                active: false,
                x: 0,
                y: 0,
                targetX: 0,
                targetY: 0,
                phase: 'waiting', // 'entering', 'finding_home', 'building_house', 'in_house', 'observing_spire', 'flying_patrol', 'hunting_army', 'attacking', 'returning_home'
                
                // House/Spire location
                houseX: null,
                houseY: null,
                hasHouse: false,
                
                // Timers
                waitTimer: 1790, // Start close to spawn time for testing
                waitDuration: 1800, // 3 years between spawns
                houseTimer: 0,
                houseDuration: 600, // 1 year in house
                patrolTimer: 0,
                patrolDuration: 7200, // 12 years flying
                buildingTimer: 0,
                buildingDuration: 30, // Time to build house
                roamingDuration: 1800, // 3 years of roaming before hunting
                attackTimer: 0,
                attackDuration: 30, // Duration of attack animation
                
                // Movement
                speed: 0.15, // Faster than fish
                currentSpeed: 0,
                maxSpeed: 0.15,
                acceleration: 0.004,
                
                // Circular patrol
                patrolAngle: 0, // Current angle around world center
                patrolRadius: 0, // Distance from center
                patrolWobble: 0, // Random variation
                patrolDirection: 1, // Start clockwise, will alternate
                patrolCycles: 0, // Count patrol cycles to alternate direction
                exitHouseTick: 0, // Track when witch exited house for hunting delay
                
                // Animation
                height: 150, // Flying height
                currentHeight: 150,
                bobOffset: 0, // Vertical floating animation
                bobPhase: 0,
                broomTilt: 0, // Broom angle
                armRaised: false, // For attack animation
                
                // Visual
                scale: 1.0, // Same size as recruit
                facingRight: true,
                shadowOpacity: 1,
                darkPowerCharge: 0, // For spawning effects
                
                // Army hunting
                targetArmy: null,
                lastConsumeTime: 0,
                consumeCooldown: 60, // 1 second between hunts (was 5 seconds)
                returningFromKill: false, // Track if returning after consuming unit
                
                // Entry
                entryDirection: 0,
                lastX: 0,
                lastY: 0,
                
                // House smoke particles
                smokeParticles: [],
                
                // Bones collection around spire
                bones: [],
                bonesDuringDarkPeriod: 0, // Track bones collected during dark period
                
                // Bone ritual
                boneRitualActive: false,
                boneRitualTimer: 0,
                boneRitualDuration: 360, // 6 seconds for the ritual
                magicCircleRadius: 0,
                magicCircleRotation: 0,
                consumedBones: [], // Track bones being consumed during ritual
                
                // Portal creation
                hasCreatedPortal: false,
                portalWorld: null, // Which world the portal leads to
                
                // Respawn
                deathTime: 0,
                respawnCooldown: 15000, // 25 years (600 ticks per year)
                
                // Smoke trail
                smokeTrail: []
            },
            
            // Terra darkness effect
            terraDarkness: {
                active: false,
                timer: 0,
                duration: 60000, // 100 years (600 ticks per year)
                transitionProgress: 0, // 0 = normal, 1 = fully dark
                transitionSpeed: 0.01, // Smooth transition
                // isPermanent removed - only Terra has darkness
            },
            
            // Dark cloud effects
            darkClouds: [],
            
            // worldWitches removed - only Terra has a witch
            
            // Performance optimization
            shouldRenderFrame: true,
            lastRenderTime: 0,
            renderInterval: 16, // 60 FPS target
            frameSkipCounter: 0,
            maxFrameSkip: 5,
            
            // Territory cache for performance
            territoryCache: new Map(),
            territoryCacheTick: -1
        };
        
        // Camera and UI state
        var camera = {
            x: 0,
            y: 0,
            zoom: 1,
            targetZoom: 1,
            viewMode: 'ethereal',
            currentWorld: null,
            isDragging: false,
            lastMouseX: 0,
            lastMouseY: 0,
            currentMouseX: 0,
            currentMouseY: 0,
            activeRequest: null,
            mouseDownX: 0,
            mouseDownY: 0,
            dragThreshold: 5, // Pixels moved before considered dragging
            dragStartX: 0,
            dragStartY: 0,
            hasDraggedSignificantly: false,
            blockPowerActivation: false, // New flag to prevent power activation after drag
            
            minWorldZoom: 0.2,
            maxWorldZoom: 4,
            etherealZoom: 1,
            
            zoomSpeed: 0.1,
            panSpeed: 0.15,
            
            transitionAlpha: 0,
            isTransitioning: false,
            isPortalTransitioning: false,
            portalCooldown: 0,
            
            // Entity following
            followingEntity: null,
            followOffsetX: 0,
            followOffsetY: 0,
            followSmoothness: 0.15,
            entityDiedTime: null,  // Track when followed entity died for delay
            
            zoomMouseX: 0,
            zoomMouseY: 0,
            isZooming: false
        };

        // Variable to track hovered tile for UI updates
        let hoveredTile = null;
        
        // Render temple function
        function renderTemple(ctx, temple, world) {
            const tile = world.tiles[temple.x][temple.y];
            if (!tile || !tile.active) return;
            
            // Use tile.renderY which already accounts for elevation
            const x = tile.isoX;
            const y = tile.renderY;
            
            // Draw shadow first (smaller, at pillar base)
            ctx.save();
            // Make shadow darker during dark phase (if in Terra)
            const shadowOpacity = world && world.name === 'Terra' && game.terraDarkness && game.terraDarkness.transitionProgress > 0 ? 
                0.2 + (game.terraDarkness.transitionProgress * 0.3) : 0.2;
            ctx.fillStyle = `rgba(0, 0, 0, ${shadowOpacity})`;
            ctx.beginPath();
            ctx.ellipse(x + 5, y - 3, 8, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Temple base
            ctx.save();
            
            // Apply grayscale filter if temple is deactivated
            if (!temple.active) {
                ctx.filter = 'grayscale(100%) brightness(0.7)';
            }
            
            // Glowing effect (only if active)
            if (temple.active) {
                const glowIntensity = 0.6 + Math.sin(temple.glowPhase) * 0.4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = `rgba(255, 215, 0, ${glowIntensity})`;
            }
            
            // Temple structure (isometric pillar reaching ground)
            const baseY = y - 5; // Pillar starts at ground level
            const columnHeight = 35; // Taller since it reaches the ground
            const columnWidth = 8;
            
            // Main column (isometric prism with V-shaped bottom)
            
            // Front face
            ctx.fillStyle = '#fff8dc';
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 1.5;
            
            ctx.beginPath();
            ctx.moveTo(x - columnWidth, baseY - 5); // Left side starts higher
            ctx.lineTo(x - columnWidth, baseY - columnHeight);
            ctx.lineTo(x, baseY - columnHeight - 4);
            ctx.lineTo(x, baseY + 5); // Center point extends down
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Right face
            ctx.fillStyle = '#ffe4b5';
            ctx.beginPath();
            ctx.moveTo(x, baseY + 5); // Center point extends down
            ctx.lineTo(x, baseY - columnHeight - 4);
            ctx.lineTo(x + columnWidth, baseY - columnHeight);
            ctx.lineTo(x + columnWidth, baseY - 5); // Right side starts higher
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Bottom face (V-shaped)
            ctx.fillStyle = '#ffd4a3';
            ctx.beginPath();
            ctx.moveTo(x - columnWidth, baseY - 5);
            ctx.lineTo(x, baseY + 5); // Point down
            ctx.lineTo(x + columnWidth, baseY - 5);
            ctx.lineTo(x, baseY - 1); // Back edge
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Top face of column
            ctx.fillStyle = '#fffacd';
            ctx.beginPath();
            ctx.moveTo(x - columnWidth, baseY - columnHeight);
            ctx.lineTo(x, baseY - columnHeight - 4);
            ctx.lineTo(x + columnWidth, baseY - columnHeight);
            ctx.lineTo(x, baseY - columnHeight + 4);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            
            // Glowing orb at top
            const orbY = baseY - columnHeight - 8;
            
            if (temple.active) {
                const orbGlow = 0.7 + Math.sin(temple.glowPhase * 2) * 0.3;
                ctx.fillStyle = `rgba(255, 255, 255, ${orbGlow})`;
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(255, 215, 0, 1)';
            } else {
                // Dim orb for inactive temples
                ctx.fillStyle = 'rgba(150, 150, 150, 0.5)';
                ctx.shadowBlur = 0;
            }
            
            ctx.beginPath();
            ctx.arc(x, orbY, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner orb
            ctx.fillStyle = temple.active ? '#ffd700' : '#888888';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(x, orbY, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Render temple spawn particle
        function renderTempleSpawnParticle(ctx, particle) {
            const alpha = 1 - (particle.currentTick / particle.duration);
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#ffd700';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffd700';
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        // Render temple destruction particle
        function renderTempleDestructionParticle(ctx, particle) {
            const alpha = 1 - (particle.currentTick / particle.duration);
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(particle.x, particle.y);
            ctx.rotate(particle.rotation);
            
            // Draw a temple fragment
            ctx.fillStyle = particle.color;
            ctx.strokeStyle = '#8b7500';
            ctx.lineWidth = 1;
            ctx.shadowBlur = 5;
            ctx.shadowColor = particle.color;
            
            // Draw triangular fragment
            ctx.beginPath();
            ctx.moveTo(-particle.size, particle.size);
            ctx.lineTo(particle.size, particle.size);
            ctx.lineTo(0, -particle.size);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
        }
        
        // Check and unlock abilities based on temple count
        function checkAbilityUnlocks() {
            // Only count active temples
            const templeCount = game.temples ? game.temples.filter(t => t.active).length : 0;
            
            // Check each ability for unlock
            for (const abilityName in game.abilities) {
                const ability = game.abilities[abilityName];
                if (!ability.unlocked && ability.templeRequirement !== undefined) {
                    if (templeCount >= ability.templeRequirement) {
                        ability.unlocked = true;
                        console.log(`Unlocked ${abilityName} ability with ${templeCount} temples!`);
                    }
                }
            }
        }
        
        // Check if a divine action completes a request
        function checkRequestCompletion(actionType, data, world) {
            console.log('checkRequestCompletion called:', actionType, data);
            world.kingdoms.forEach(kingdom => {
                if (kingdom.alive && kingdom.templeRequests.length > 0) {
                    const request = kingdom.templeRequests[0];
                    if (request.completed) return;
                    
                    let completed = false;
                    
                    switch (actionType) {
                        case 'smite':
                            if (request.type === 'attack' && request.target) {
                                console.log('Checking smite request:', {
                                    requestTarget: request.target.id,
                                    requestTargetName: request.target.name,
                                    hitTargets: data.hitTargets
                                });
                                // Check if smite hit any units or buildings of the target kingdom
                                if (data.hitTargets && data.hitTargets.length > 0) {
                                    // Check if any of the hit targets belong to the requested kingdom
                                    const hitTargetKingdom = data.hitTargets.some(hit => {
                                        console.log('Comparing:', hit.kingdomId, 'with', request.target.id, 
                                                   'types:', typeof hit.kingdomId, typeof request.target.id);
                                        // Use == instead of === to handle string/number comparison
                                        return hit.kingdomId == request.target.id;
                                    });
                                    if (hitTargetKingdom) {
                                        completed = true;
                                        console.log('Request completed! Hit target kingdom:', request.target.name);
                                    }
                                }
                            }
                            break;
                            
                        case 'blessing':
                            if (request.type === 'blessing' && data.kingdom.id === kingdom.id) {
                                completed = true;
                            }
                            break;
                            
                            
                        case 'peace':
                            if (request.type === 'peace' && request.target) {
                                if ((data.kingdom1 === kingdom.id && data.kingdom2 === request.target.id) ||
                                    (data.kingdom2 === kingdom.id && data.kingdom1 === request.target.id)) {
                                    completed = true;
                                }
                            }
                            break;
                            
                            
                        case 'portal':
                            if (request.type === 'portal' && request.location) {
                                // Check if portal was created near requested location
                                if (data.tile1 && data.tile2) {
                                    const dist1 = Math.abs(data.tile1.x - request.location.x) + Math.abs(data.tile1.y - request.location.y);
                                    const dist2 = Math.abs(data.tile2.x - request.location.x) + Math.abs(data.tile2.y - request.location.y);
                                    if (dist1 <= 5 || dist2 <= 5) {
                                        completed = true;
                                    }
                                }
                            }
                            break;
                    }
                    
                    if (completed) {
                        request.completed = true;
                        kingdom.lastRequestCompletedTick = game.currentTick;
                        
                        // Clean up messenger if exists
                        if (request.messengerArmy && request.messengerArmy.alive) {
                            // Send messenger home immediately
                            request.messengerArmy.isReturning = true;
                            request.messengerArmy.targetX = request.messengerArmy.returnTarget.x;
                            request.messengerArmy.targetY = request.messengerArmy.returnTarget.y;
                            request.messengerArmy.path = request.messengerArmy.calculatePath();
                            request.messengerArmy.pathIndex = 0;
                            request.messengerArmy.moveProgress = 0;
                        }
                        
                        // Reactivate all temples belonging to this kingdom
                        game.temples.forEach(temple => {
                            if (temple.kingdomId === kingdom.id) {
                                temple.active = true;
                            }
                        });
                        
                        // Create temple after a short delay
                        setTimeout(() => {
                            if (kingdom.alive) {
                                const temple = createTemple(kingdom, world, request.capital);
                                if (!temple) {
                                    console.warn('Failed to create temple for kingdom', kingdom.name);
                                }
                            }
                        }, 500);
                    }
                }
            });
        }
        
        // World configuration
        var worlds = [];
        var WORLD_COUNT = 7;
        var WORLD_SIZE = 50;
        var KINGDOMS_PER_WORLD = 11;
        
        // Crystal Ball state
        var crystalBall = {
            currentWorld: null,
            targetWorld: null,
            viewX: 0,
            viewY: 0,
            targetX: 0,
            targetY: 0,
            zoom: 0.75, // 50% zoomed out (smaller zoom value = more zoomed out)
            transitionProgress: 0,
            lastSwitch: 0,
            lastLocationSwitch: 0, // Track when we last switched locations within a world
            minSwitchInterval: 600, // 10 seconds at 60fps
            minLocationSwitchInterval: 300, // 5 seconds for location switches within same world
            hoveredWorld: null,
            followingEvent: null,
            eventTypes: ['battle', 'conquest', 'armyMovement', 'portalCreation', 'worldEffect'],
            fogTrailOpacity: 0,
            targetFogOpacity: 0,
            previousWorld: null
        };
        
        // Mouse tracking
        var mouseX = 0;
        var mouseY = 0;
        
        // Kingdom AI states
        var KingdomState = {
            EXPANDING: 'expanding',
            PREPARING_WAR: 'preparing_war',
            AT_WAR: 'at_war',
            DEFENDING: 'defending',
            RECOVERING: 'recovering',
            INVADING: 'invading'
        };
        
        // Kingdom names
        var kingdomPrefixes = ['North', 'South', 'East', 'West', 'High', 'Low', 'Dark', 'Bright', 'Ancient', 'New', 'Old', 'Greater', 'Lesser', 'First', 'Last'];
        var kingdomSuffixes = ['realm', 'shire', 'land', 'haven', 'hold', 'garde', 'march', 'vale', 'fell', 'moor', 'wood', 'wald', 'heim', 'gard', 'stead'];
        
        // Nomad Tribe for Aether world
        function createNomadTribe(worldId) {
            const tribe = {
                worldId: worldId,
                wagons: [],
                angle: 0, // Current angle around the center
                speed: 0.001, // 50% slower movement
                radius: WORLD_SIZE / 4, // 50% closer to center (quarter radius instead of half)
                centerX: WORLD_SIZE / 2,
                centerY: WORLD_SIZE / 2,
                // Subtle randomness parameters
                noisePhase: Math.random() * Math.PI * 2,
                radiusNoise: 0,
                speedNoise: 0,
                // Movement pattern for first wagon (12 years move, 6 years stop)
                movementTimer: 0,  // Tracks years for movement pattern
                isMoving: true,     // Whether the first wagon is currently moving
                // Campfire stop animation
                stopPhase: 'moving', // 'moving', 'stopping', 'camping', 'packingUp'
                stopTimer: 0, // Timer for current stop phase
                campfire: {
                    active: false,
                    x: 0,
                    y: 0,
                    sticks: [], // Array of placed sticks
                    fireIntensity: 0,
                    smokeParticles: [],
                    glowRadius: 0,
                    flameParticles: []
                }
            };
            
            // Create 7 wagons - alternating black and white starting with black
            for (let i = 0; i < 7; i++) {
                const wagon = {
                    id: i,
                    color: i % 2 === 0 ? 'black' : 'white',
                    x: 0,
                    y: 0,
                    prevX: 0,
                    prevY: 0,
                    isLead: i === 0,
                    wheelRotation: 0,
                    facingRight: false,
                    man: {
                        color: 'black',
                        headColor: 'white',
                        bootColor: 'white',
                        hatColor: 'black',
                        state: 'pulling', // 'pulling', 'disconnecting', 'walking', 'atFire', 'returning', 'connecting'
                        x: 0,
                        y: 0,
                        targetX: 0,
                        targetY: 0,
                        orbitAngle: 0,
                        orbitSpeed: 0.010,
                        orbitRadius: 0.9
                    },
                    woman: {
                        visible: false,
                        x: 0,
                        y: 0,
                        targetX: 0,
                        targetY: 0,
                        hasStick: true,
                        color: 'white',
                        dressColor: i % 2 === 0 ? 'black' : 'white', // matches wagon
                        headColor: 'white',
                        state: 'inside', // 'inside', 'exiting', 'walking', 'atFire', 'returning', 'entering'
                        orbitAngle: 0,
                        orbitSpeed: 0.010,
                        orbitRadius: 0.9
                    },
                    // Trail positions for snake movement
                    trail: []
                };
                tribe.wagons.push(wagon);
            }
            
            // Initialize wheel trail marks storage
            tribe.wheelTrails = [];
            
            // Initialize positions
            updateNomadTribePosition(tribe);
            
            return tribe;
        }
        
        function updateNomadTribePosition(tribe) {
            // Check if there are any wagons left
            if (!tribe.wagons || tribe.wagons.length === 0) {
                return; // No wagons to update
            }
            
            // Update movement pattern timer (12 years move, 6 years stop)
            if (game.currentTick % 600 === 0) { // Every year
                tribe.movementTimer++;
                
                // Check if we need to change movement state
                if (tribe.isMoving && tribe.movementTimer >= 12) {
                    // Stop after 12 years of movement
                    tribe.isMoving = false;
                    tribe.movementTimer = 0;
                    tribe.stopPhase = 'stopping';
                    tribe.stopTimer = 0;
                } else if (!tribe.isMoving && tribe.movementTimer >= 6) {
                    // Resume after 6 years of stopping
                    tribe.isMoving = true;
                    tribe.movementTimer = 0;
                    tribe.stopPhase = 'moving';
                }
            }
            
            // Handle stop phase animations
            if (!tribe.isMoving && tribe.stopPhase !== 'moving') {
                tribe.stopTimer++;
                
                switch (tribe.stopPhase) {
                    case 'stopping':
                        // Deceleration phase (30 ticks)
                        if (tribe.stopTimer >= 30) {
                            tribe.stopPhase = 'disconnecting';
                            tribe.stopTimer = 0;
                            
                            // Initialize people positions at wagon locations
                            tribe.wagons.forEach(wagon => {
                                // Position man at front of wagon
                                const iso = worldToIsometric(wagon.x, wagon.y);
                                const manOffset = wagon.facingRight ? 25 : -25;
                                wagon.man.x = wagon.x;
                                wagon.man.y = wagon.y;
                                wagon.man.targetX = wagon.x;
                                wagon.man.targetY = wagon.y;
                                
                                // Position woman inside wagon (will exit later)
                                wagon.woman.x = wagon.x;
                                wagon.woman.y = wagon.y;
                                wagon.woman.targetX = wagon.x;
                                wagon.woman.targetY = wagon.y;
                            });
                        }
                        break;
                        
                    case 'disconnecting':
                        // Men disconnect from wagons (60 ticks after stop)
                        if (tribe.stopTimer === 1) {
                            // Men step away from wagons
                            tribe.wagons.forEach(wagon => {
                                wagon.man.state = 'disconnecting';
                                // Step to the side of the wagon, but closer
                                const sideOffset = wagon.facingRight ? -1 : 1;
                                wagon.man.targetX = wagon.x + sideOffset;
                                wagon.man.targetY = wagon.y + 0.5;
                            });
                        }
                        
                        // Animate men moving
                        let menInPosition = true;
                        tribe.wagons.forEach(wagon => {
                            const dx = wagon.man.targetX - wagon.man.x;
                            const dy = wagon.man.targetY - wagon.man.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0.05) {
                                wagon.man.x += dx * 0.1;
                                wagon.man.y += dy * 0.1;
                                menInPosition = false;
                            }
                        });
                        
                        if (menInPosition && tribe.stopTimer >= 30) {
                            tribe.stopPhase = 'womenExiting';
                            tribe.stopTimer = 0;
                        }
                        break;
                        
                    case 'womenExiting':
                        // Women emerge from wagons (90 ticks after stop)
                        if (tribe.stopTimer === 1) {
                            // Make women visible and animate them exiting
                            tribe.wagons.forEach(wagon => {
                                wagon.woman.visible = true;
                                wagon.woman.state = 'exiting';
                                // Exit toward the center of the map, but much closer to wagon
                                const dirToCenter = Math.atan2(tribe.centerY - wagon.y, tribe.centerX - wagon.x);
                                wagon.woman.targetX = wagon.x + Math.cos(dirToCenter) * 0.5;
                                wagon.woman.targetY = wagon.y + Math.sin(dirToCenter) * 0.5;
                            });
                            
                            // Set campfire position
                            const firstWagon = tribe.wagons[0];
                            // Position campfire very close to lead wagon, toward center
                            const dirToCenter = Math.atan2(tribe.centerY - firstWagon.y, tribe.centerX - firstWagon.x);
                            tribe.campfire.x = firstWagon.x + Math.cos(dirToCenter) * 1.5;
                            tribe.campfire.y = firstWagon.y + Math.sin(dirToCenter) * 1.5;
                        }
                        
                        // Animate women exiting
                        let womenExited = true;
                        tribe.wagons.forEach(wagon => {
                            const dx = wagon.woman.targetX - wagon.woman.x;
                            const dy = wagon.woman.targetY - wagon.woman.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0.05) {
                                wagon.woman.x += dx * 0.1;
                                wagon.woman.y += dy * 0.1;
                                womenExited = false;
                            }
                        });
                        
                        if (womenExited && tribe.stopTimer >= 40) {
                            tribe.stopPhase = 'gathering';
                            tribe.stopTimer = 0;
                        }
                        break;
                        
                    case 'gathering':
                        // People move to campfire location (150 ticks after stop)
                        if (tribe.stopTimer === 1) {
                            // Set target positions for all people in a circle
                            tribe.wagons.forEach((wagon, wagonIndex) => {
                                wagon.man.state = 'walking';
                                wagon.woman.state = 'walking';
                                
                                // Calculate positions in circle around campfire - evenly spaced
                                const angleStep = (2 * Math.PI) / 14;
                                // Alternate man-woman around the circle
                                const manAngle = (wagonIndex * 2) * angleStep;
                                const womanAngle = (wagonIndex * 2 + 1) * angleStep;
                                const radius = 0.9; // Even closer circle
                                
                                wagon.man.targetX = tribe.campfire.x + Math.cos(manAngle) * radius;
                                wagon.man.targetY = tribe.campfire.y + Math.sin(manAngle) * radius;
                                wagon.woman.targetX = tribe.campfire.x + Math.cos(womanAngle) * radius;
                                wagon.woman.targetY = tribe.campfire.y + Math.sin(womanAngle) * radius;
                            });
                        }
                        
                        // Move people toward their targets
                        let allAtPosition = true;
                        tribe.wagons.forEach(wagon => {
                            // Move man
                            if (wagon.man.state === 'walking') {
                                const dx = wagon.man.targetX - wagon.man.x;
                                const dy = wagon.man.targetY - wagon.man.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 0.1) {
                                    wagon.man.x += (dx / dist) * 0.1;
                                    wagon.man.y += (dy / dist) * 0.1;
                                    allAtPosition = false;
                                } else {
                                    wagon.man.x = wagon.man.targetX;
                                    wagon.man.y = wagon.man.targetY;
                                }
                            }
                            // Move woman
                            if (wagon.woman.state === 'walking') {
                                const dx = wagon.woman.targetX - wagon.woman.x;
                                const dy = wagon.woman.targetY - wagon.woman.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 0.1) {
                                    wagon.woman.x += (dx / dist) * 0.1;
                                    wagon.woman.y += (dy / dist) * 0.1;
                                    allAtPosition = false;
                                } else {
                                    wagon.woman.x = wagon.woman.targetX;
                                    wagon.woman.y = wagon.woman.targetY;
                                }
                            }
                        });
                        
                        if (allAtPosition && tribe.stopTimer >= 90) {
                            tribe.stopPhase = 'placingSticks';
                            tribe.stopTimer = 0;
                        }
                        break;
                        
                    case 'placingSticks':
                        // Women place sticks (240 ticks after stop)
                        if (tribe.stopTimer <= 70) {
                            // One woman places stick every 10 ticks
                            const stickIndex = Math.floor(tribe.stopTimer / 10);
                            if (stickIndex < 7 && tribe.stopTimer % 10 === 0 && stickIndex < tribe.wagons.length) {
                                const wagon = tribe.wagons[stickIndex];
                                if (wagon && wagon.woman.hasStick) {
                                    wagon.woman.hasStick = false;
                                    // Add stick to campfire in isometric pattern
                                    const angle = (stickIndex * 2 * Math.PI) / 7;
                                    // Place sticks in a smaller radius for campfire
                                    const stickRadius = 0.3;
                                    tribe.campfire.sticks.push({
                                        x: tribe.campfire.x + Math.cos(angle) * stickRadius,
                                        y: tribe.campfire.y + Math.sin(angle) * stickRadius,
                                        angle: angle + (Math.random() - 0.5) * 0.4 // Random angles for natural look
                                    });
                                }
                            }
                        }
                        
                        // Make sure we wait long enough for all 7 sticks (70 ticks = 7 sticks * 10 ticks each)
                        if (tribe.stopTimer >= 70) {
                            // Double check all sticks are placed
                            if (tribe.campfire.sticks.length < 7) {
                                // Force place any missing sticks
                                tribe.wagons.forEach((wagon, idx) => {
                                    if (wagon.woman.hasStick) {
                                        wagon.woman.hasStick = false;
                                        const angle = (idx * 2 * Math.PI) / 7;
                                        const stickRadius = 0.3;
                                        tribe.campfire.sticks.push({
                                            x: tribe.campfire.x + Math.cos(angle) * stickRadius,
                                            y: tribe.campfire.y + Math.sin(angle) * stickRadius,
                                            angle: angle + (Math.random() - 0.5) * 0.4
                                        });
                                    }
                                });
                            }
                            tribe.stopPhase = 'lighting';
                            tribe.stopTimer = 0;
                        }
                        break;
                        
                    case 'lighting':
                        // Light the campfire (300 ticks after stop)
                        if (tribe.stopTimer === 1) {
                            tribe.campfire.active = true;
                            tribe.campfire.fireIntensity = 1.0;
                            tribe.campfire.glowRadius = 20; // Smaller glow
                            // Set all people to 'atFire' state and initialize orbital movement
                            tribe.wagons.forEach((wagon, wagonIndex) => {
                                wagon.man.state = 'atFire';
                                wagon.woman.state = 'atFire';
                                
                                // Initialize orbital parameters - evenly space all 14 people
                                // Each person gets 2π/14 radians of space
                                const angleStep = (2 * Math.PI) / 14;
                                // Alternate man-woman around the circle
                                wagon.man.orbitAngle = (wagonIndex * 2) * angleStep;
                                wagon.woman.orbitAngle = (wagonIndex * 2 + 1) * angleStep;
                                
                                // Same speed for everyone
                                wagon.man.orbitSpeed = 0.010;
                                wagon.woman.orbitSpeed = 0.010;
                                wagon.man.orbitRadius = 0.9;
                                wagon.woman.orbitRadius = 0.9;
                                
                                // Set initial positions based on orbit
                                wagon.man.x = tribe.campfire.x + Math.cos(wagon.man.orbitAngle) * wagon.man.orbitRadius;
                                wagon.man.y = tribe.campfire.y + Math.sin(wagon.man.orbitAngle) * wagon.man.orbitRadius;
                                wagon.woman.x = tribe.campfire.x + Math.cos(wagon.woman.orbitAngle) * wagon.woman.orbitRadius;
                                wagon.woman.y = tribe.campfire.y + Math.sin(wagon.woman.orbitAngle) * wagon.woman.orbitRadius;
                            });
                        }
                        if (tribe.stopTimer >= 30) {
                            tribe.stopPhase = 'camping';
                            tribe.stopTimer = 0;
                        }
                        break;
                        
                    case 'camping':
                        // Main camping phase (330 to 3270 ticks)
                        // Generate smoke particles
                        if (tribe.campfire.active && game.currentTick % 10 === 0 && tribe.campfire.smokeParticles.length < 30) {
                            tribe.campfire.smokeParticles.push({
                                x: tribe.campfire.x + (Math.random() - 0.5) * 0.3,
                                y: tribe.campfire.y + (Math.random() - 0.5) * 0.3,
                                vx: (Math.random() - 0.5) * 0.01,
                                vy: -0.03 - Math.random() * 0.01,
                                age: 0,
                                maxAge: 150,
                                size: 0.2 + Math.random() * 0.1
                            });
                        }
                        
                        // Orbital movement throughout camping phase
                        tribe.wagons.forEach(wagon => {
                            // Update orbit angles
                            wagon.man.orbitAngle += wagon.man.orbitSpeed;
                            wagon.woman.orbitAngle += wagon.woman.orbitSpeed;
                            
                            // Calculate new positions based on orbit
                            wagon.man.x = tribe.campfire.x + Math.cos(wagon.man.orbitAngle) * wagon.man.orbitRadius;
                            wagon.man.y = tribe.campfire.y + Math.sin(wagon.man.orbitAngle) * wagon.man.orbitRadius;
                            wagon.woman.x = tribe.campfire.x + Math.cos(wagon.woman.orbitAngle) * wagon.woman.orbitRadius;
                            wagon.woman.y = tribe.campfire.y + Math.sin(wagon.woman.orbitAngle) * wagon.woman.orbitRadius;
                        });
                        
                        // Check if it's time to pack up (after ~2940 ticks of camping)
                        if (tribe.stopTimer >= 2940) {
                            tribe.stopPhase = 'packingUp';
                            tribe.stopTimer = 0;
                        }
                        break;
                        
                    case 'packingUp':
                        // Women return to wagons (3270 ticks after stop)
                        if (tribe.stopTimer === 1) {
                            // Women start returning
                            tribe.wagons.forEach(wagon => {
                                wagon.woman.state = 'returning';
                                wagon.man.state = 'atFire'; // Men stay at fire
                                // Women go directly to wagon position
                                wagon.woman.targetX = wagon.x;
                                wagon.woman.targetY = wagon.y;
                            });
                        }
                        
                        // Move women back
                        let allWomenReturned = true;
                        tribe.wagons.forEach(wagon => {
                            if (wagon.woman.state === 'returning') {
                                const dx = wagon.woman.targetX - wagon.woman.x;
                                const dy = wagon.woman.targetY - wagon.woman.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 0.1) {
                                    wagon.woman.x += (dx / dist) * 0.1;
                                    wagon.woman.y += (dy / dist) * 0.1;
                                    allWomenReturned = false;
                                } else {
                                    wagon.woman.state = 'entering';
                                    wagon.woman.visible = false;
                                    wagon.woman.hasStick = true; // Reset for next stop
                                }
                            }
                        });
                        
                        // After women are in, men return
                        if (allWomenReturned && tribe.stopTimer >= 60) {
                            tribe.stopPhase = 'menReturning';
                            tribe.stopTimer = 0;
                            // Start extinguishing fire
                            tribe.campfire.fireIntensity = 0.5;
                        }
                        break;
                        
                    case 'menReturning':
                        // Men return to wagons (3330 ticks after stop)
                        if (tribe.stopTimer === 1) {
                            // Men start returning to pulling position
                            tribe.wagons.forEach(wagon => {
                                wagon.man.state = 'returning';
                                // Return directly to wagon position
                                wagon.man.targetX = wagon.x;
                                wagon.man.targetY = wagon.y;
                            });
                        }
                        
                        // Move men back
                        let allMenReturned = true;
                        tribe.wagons.forEach(wagon => {
                            if (wagon.man.state === 'returning') {
                                const dx = wagon.man.targetX - wagon.man.x;
                                const dy = wagon.man.targetY - wagon.man.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 0.1) {
                                    wagon.man.x += (dx / dist) * 0.1;
                                    wagon.man.y += (dy / dist) * 0.1;
                                    allMenReturned = false;
                                } else {
                                    wagon.man.state = 'connecting';
                                }
                            }
                        });
                        
                        // Fade out campfire
                        if (tribe.campfire.fireIntensity > 0) {
                            tribe.campfire.fireIntensity -= 0.02;
                            tribe.campfire.glowRadius = tribe.campfire.fireIntensity * 30;
                        }
                        
                        if (allMenReturned && tribe.stopTimer >= 60) {
                            // Clean up campfire
                            tribe.campfire.active = false;
                            tribe.campfire.sticks = [];
                            tribe.campfire.smokeParticles = [];
                            tribe.campfire.flameParticles = [];
                            // Set all men to pulling
                            tribe.wagons.forEach(wagon => {
                                wagon.man.state = 'pulling';
                            });
                            // Ready to resume movement when timer expires
                        }
                        break;
                }
            }
            
            // Update smoke particles
            if (tribe.campfire.smokeParticles.length > 0) {
                tribe.campfire.smokeParticles = tribe.campfire.smokeParticles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.98; // Drag
                    particle.vy -= 0.0002; // Slight upward acceleration
                    particle.age++;
                    return particle.age < particle.maxAge;
                });
            }
            
            // Update flame particles
            if (tribe.campfire.active && tribe.campfire.fireIntensity > 0) {
                // Generate new flame particles
                if (game.currentTick % 3 === 0 && tribe.campfire.flameParticles.length < 10) {
                    tribe.campfire.flameParticles.push({
                        x: (Math.random() - 0.5) * 0.5,
                        y: 0,
                        vx: (Math.random() - 0.5) * 0.02,
                        vy: -0.1 - Math.random() * 0.05,
                        age: 0,
                        maxAge: 30 + Math.random() * 20,
                        size: 0.3 + Math.random() * 0.2
                    });
                }
                
                // Update existing flame particles
                tribe.campfire.flameParticles = tribe.campfire.flameParticles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.95;
                    particle.age++;
                    return particle.age < particle.maxAge && tribe.campfire.fireIntensity > 0;
                });
            }
            
            // Update subtle noise
            tribe.noisePhase += 0.005;
            
            // Very subtle radius variation (±2 tiles max)
            tribe.radiusNoise = Math.sin(tribe.noisePhase) * 1 + Math.sin(tribe.noisePhase * 1.7) * 0.5;
            
            // Very subtle speed variation
            tribe.speedNoise = Math.sin(tribe.noisePhase * 0.7) * 0.0002;
            
            // Update lead wagon position with subtle variation
            const leadWagon = tribe.wagons[0];
            
            const currentRadius = tribe.radius + tribe.radiusNoise;
            const currentSpeed = tribe.speed + tribe.speedNoise;
            
            // Only update positions if the tribe is moving
            if (tribe.isMoving) {
                leadWagon.prevX = leadWagon.x;
                leadWagon.prevY = leadWagon.y;
                leadWagon.x = tribe.centerX + Math.cos(tribe.angle) * currentRadius;
                leadWagon.y = tribe.centerY + Math.sin(tribe.angle) * currentRadius;
                
                // Add to trail
                leadWagon.trail.push({x: leadWagon.x, y: leadWagon.y});
                if (leadWagon.trail.length > 1500) { // Extra long trail for 180 follow distance
                    leadWagon.trail.shift();
                }
                
                // Update following wagons
                const followDistance = 180; // Extra large follow distance for more spacing between wagons
                for (let i = 1; i < tribe.wagons.length; i++) {
                    const wagon = tribe.wagons[i];
                    const targetIndex = Math.max(0, leadWagon.trail.length - (i * followDistance));
                    
                    if (leadWagon.trail[targetIndex]) {
                        wagon.prevX = wagon.x;
                        wagon.prevY = wagon.y;
                        wagon.x = leadWagon.trail[targetIndex].x;
                        wagon.y = leadWagon.trail[targetIndex].y;
                    }
                }
            }
            
            // Update wagon properties (rotation, direction, trails)
            tribe.wagons.forEach(wagon => {
                // Calculate movement direction
                const dx = wagon.x - wagon.prevX;
                const dy = wagon.y - wagon.prevY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Update wheel rotation only if tribe is moving (counter-clockwise, 15x faster)
                if (distance > 0.01 && tribe.isMoving) {
                    wagon.wheelRotation -= distance * 3.0; // 50% faster than 2.0
                    if (wagon.wheelRotation < -Math.PI * 2) {
                        wagon.wheelRotation += Math.PI * 2;
                    }
                }
                
                // Update facing direction based on movement
                const screenDx = dx - dy; // Convert to screen coordinates
                wagon.facingRight = screenDx > 0;
                
                
                // Initialize wheel emitters if not present
                if (!wagon.leftWheelEmitter) {
                    wagon.leftWheelEmitter = { lastEmitTime: 0 };
                    wagon.rightWheelEmitter = { lastEmitTime: 0 };
                }
                
                // Emit trail particles from wheels if moving
                if (distance > 0.01 && tribe.wheelTrails.length < 500) {
                    const currentTime = game.currentTick;
                    const emitInterval = 3; // Emit every 3 ticks
                    
                    // Check if it's time to emit from each wheel
                    if (currentTime - wagon.leftWheelEmitter.lastEmitTime >= emitInterval) {
                        wagon.leftWheelEmitter.lastEmitTime = currentTime;
                        
                        // Emit from left wheel
                        tribe.wheelTrails.push({
                            x: wagon.x,
                            y: wagon.y,
                            age: 0,
                            maxAge: 100,
                            size: 1.5 + Math.random() * 1,
                            wheelSide: 'left',
                            wagonId: wagon.id,
                            facingRight: wagon.facingRight
                        });
                    }
                    
                    if (currentTime - wagon.rightWheelEmitter.lastEmitTime >= emitInterval) {
                        wagon.rightWheelEmitter.lastEmitTime = currentTime;
                        
                        // Emit from right wheel
                        tribe.wheelTrails.push({
                            x: wagon.x,
                            y: wagon.y,
                            age: 0,
                            maxAge: 100,
                            size: 1.5 + Math.random() * 1,
                            wheelSide: 'right',
                            wagonId: wagon.id,
                            facingRight: wagon.facingRight
                        });
                    }
                }
            });
            
            // Update and clean wheel trails
            tribe.wheelTrails = tribe.wheelTrails.filter(trail => {
                trail.age++;
                return trail.age < trail.maxAge;
            });
            
            // Update angle for next frame with current speed (only if first wagon is moving)
            if (tribe.isMoving) {
                tribe.angle += currentSpeed;
                if (tribe.angle > Math.PI * 2) {
                    tribe.angle -= Math.PI * 2;
                }
            }
        }
        
        // updateWorldWitch function removed - only Terra has a witch
        function updateWorldWitch_removed(witch, world) {
            // Similar to Terra witch but with world-specific logic
            switch (witch.phase) {
                case 'entering':
                    if (!witch.hasHouse) {
                        const secludedTile = findSecludedTileForWitch(world);
                        if (secludedTile) {
                            witch.targetX = secludedTile.x;
                            witch.targetY = secludedTile.y;
                            witch.phase = 'finding_home';
                        } else {
                            witch.targetX = WORLD_SIZE / 2 + (Math.random() - 0.5) * 20;
                            witch.targetY = WORLD_SIZE / 2 + (Math.random() - 0.5) * 20;
                            witch.phase = 'finding_home';
                        }
                    }
                    break;
                    
                case 'finding_home':
                    const homeDistX = witch.targetX - witch.x;
                    const homeDistY = witch.targetY - witch.y;
                    const homeDist = Math.sqrt(homeDistX * homeDistX + homeDistY * homeDistY);
                    
                    const homeIso = worldToIsometric(witch.x, witch.y);
                    const targetHomeIso = worldToIsometric(witch.targetX, witch.targetY);
                    witch.facingRight = targetHomeIso.x > homeIso.x;
                    
                    witch.currentSpeed = Math.min(witch.currentSpeed + witch.acceleration, witch.maxSpeed);
                    
                    if (homeDist > 1) {
                        witch.x += (homeDistX / homeDist) * witch.currentSpeed;
                        witch.y += (homeDistY / homeDist) * witch.currentSpeed;
                    } else {
                        witch.phase = 'building_house';
                        witch.buildingTimer = 0;
                        witch.currentSpeed = 0;
                        witch.darkPowerCharge = 0;
                    }
                    break;
                    
                case 'building_house':
                    const buildX = Math.floor(witch.x);
                    const buildY = Math.floor(witch.y);
                    if (buildX >= 0 && buildX < WORLD_SIZE && buildY >= 0 && buildY < WORLD_SIZE) {
                        const buildTile = world.tiles[buildX][buildY];
                        if (!buildTile || !buildTile.active || buildTile.elevation <= 0) {
                            const nearestLand = findNearestLandTile(world, witch.x, witch.y);
                            if (nearestLand) {
                                witch.x = nearestLand.x;
                                witch.y = nearestLand.y;
                                witch.buildingTimer = 0;
                            }
                        } else {
                            witch.buildingTimer++;
                            witch.darkPowerCharge = Math.min(witch.buildingTimer / witch.buildingDuration, 1);
                            
                            if (witch.buildingTimer >= witch.buildingDuration) {
                                witch.currentHeight = witch.height;
                                createWitchHouse(world, witch.x, witch.y);
                                witch.houseX = witch.x;
                                witch.houseY = witch.y;
                                witch.hasHouse = true;
                                witch.phase = 'in_house';
                                witch.houseTimer = 0;
                                witch.darkPowerCharge = 0;
                            }
                        }
                    }
                    break;
                    
                case 'in_house':
                    witch.houseTimer++;
                    witch.currentHeight = 0;
                    
                    if (witch.houseTimer >= witch.houseDuration || witch.bones.length >= 15) {
                        witch.phase = 'flying_patrol';
                        witch.patrolTimer = 0;
                        witch.currentSpeed = 0;
                        
                        witch.patrolRadius = 15 + Math.random() * 10;
                        witch.patrolAngle = Math.random() * Math.PI * 2;
                        witch.patrolWobble = Math.random() * 5;
                    }
                    break;
                    
                case 'flying_patrol':
                    witch.currentHeight = Math.min(witch.height, witch.currentHeight + 5);
                    witch.patrolTimer++;
                    
                    witch.patrolAngle += 0.005 * witch.patrolDirection;
                    if (witch.patrolAngle > Math.PI * 2) witch.patrolAngle -= Math.PI * 2;
                    if (witch.patrolAngle < 0) witch.patrolAngle += Math.PI * 2;
                    
                    if (Math.random() < 0.002) {
                        witch.patrolDirection *= -1;
                    }
                    
                    const wobbleOffset = Math.sin(game.currentTick * 0.02) * witch.patrolWobble;
                    const targetPatrolX = WORLD_SIZE / 2 + Math.cos(witch.patrolAngle) * (witch.patrolRadius + wobbleOffset);
                    const targetPatrolY = WORLD_SIZE / 2 + Math.sin(witch.patrolAngle) * (witch.patrolRadius + wobbleOffset);
                    
                    const patrolDistX = targetPatrolX - witch.x;
                    const patrolDistY = targetPatrolY - witch.y;
                    const patrolDist = Math.sqrt(patrolDistX * patrolDistX + patrolDistY * patrolDistY);
                    
                    const patrolIso = worldToIsometric(witch.x, witch.y);
                    const targetPatrolIso = worldToIsometric(targetPatrolX, targetPatrolY);
                    witch.facingRight = targetPatrolIso.x > patrolIso.x;
                    
                    witch.currentSpeed = Math.min(witch.currentSpeed + witch.acceleration, witch.maxSpeed);
                    
                    if (patrolDist > 0.5) {
                        witch.x += (patrolDistX / patrolDist) * witch.currentSpeed;
                        witch.y += (patrolDistY / patrolDist) * witch.currentSpeed;
                    }
                    
                    // Look for armies to hunt after 3 years of flying
                    if (witch.patrolTimer > witch.roamingDuration && game.currentTick - witch.lastConsumeTime > witch.consumeCooldown) {
                        const loneTarget = findLoneArmyForWitch(world, witch);
                        if (loneTarget) {
                            witch.targetArmy = loneTarget;
                            witch.phase = 'hunting_army';
                        }
                    }
                    
                    // Check for bone ritual
                    if (witch.bones.length >= 15 && !witch.boneRitualActive) {
                        witch.phase = 'bone_ritual_ascending';
                        witch.boneRitualTimer = 0;
                        witch.boneRitualActive = true;
                        witch.magicCircleRadius = 0;
                        witch.magicCircleRotation = 0;
                        witch.consumedBones = [];
                    }
                    
                    if (witch.patrolTimer >= witch.patrolDuration) {
                        witch.phase = 'returning_home';
                        witch.targetX = witch.houseX;
                        witch.targetY = witch.houseY;
                    }
                    break;
                    
                case 'hunting_army':
                    if (!witch.targetArmy || !witch.targetArmy.alive) {
                        witch.targetArmy = null;
                        witch.phase = 'flying_patrol';
                        break;
                    }
                    
                    const targetX = witch.targetArmy.currentX || witch.targetArmy.x;
                    const targetY = witch.targetArmy.currentY || witch.targetArmy.y;
                    const huntDistX = targetX - witch.x;
                    const huntDistY = targetY - witch.y;
                    const huntDist = Math.sqrt(huntDistX * huntDistX + huntDistY * huntDistY);
                    
                    const huntIso = worldToIsometric(witch.x, witch.y);
                    const targetHuntIso = worldToIsometric(targetX, targetY);
                    witch.facingRight = targetHuntIso.x > huntIso.x;
                    
                    if (huntDist > 5) {
                        witch.currentSpeed = Math.min(witch.currentSpeed + witch.acceleration, witch.maxSpeed);
                        witch.x += (huntDistX / huntDist) * witch.currentSpeed;
                        witch.y += (huntDistY / huntDist) * witch.currentSpeed;
                    } else if (huntDist > 0.5) {
                        witch.currentHeight = Math.max(5, witch.currentHeight - 8);
                        witch.x += (huntDistX / huntDist) * witch.maxSpeed * 1.2;
                        witch.y += (huntDistY / huntDist) * witch.maxSpeed * 1.2;
                    } else {
                        consumeArmyWithDarkPower(world, witch, witch.targetArmy);
                        witch.targetArmy = null;
                        witch.lastConsumeTime = game.currentTick;
                        witch.returningFromKill = true;
                        witch.phase = 'returning_home';
                        witch.targetX = witch.houseX;
                        witch.targetY = witch.houseY;
                        witch.currentHeight = witch.height;
                    }
                    break;
                    
                case 'returning_home':
                    const returnDistX = witch.targetX - witch.x;
                    const returnDistY = witch.targetY - witch.y;
                    const returnDist = Math.sqrt(returnDistX * returnDistX + returnDistY * returnDistY);
                    
                    const returnIso = worldToIsometric(witch.x, witch.y);
                    const targetReturnIso = worldToIsometric(witch.targetX, witch.targetY);
                    witch.facingRight = targetReturnIso.x > returnIso.x;
                    
                    witch.currentSpeed = Math.min(witch.currentSpeed + witch.acceleration, witch.maxSpeed);
                    
                    if (returnDist > 1) {
                        witch.x += (returnDistX / returnDist) * witch.currentSpeed;
                        witch.y += (returnDistY / returnDist) * witch.currentSpeed;
                    } else {
                        // Add bone if returning from kill
                        if (witch.returningFromKill) {
                            const tileX = Math.floor(witch.houseX);
                            const tileY = Math.floor(witch.houseY);
                            const angle = Math.random() * Math.PI;
                            const radius = 0.15 + Math.random() * 0.25;
                            const boneX = tileX + 0.5 + Math.cos(angle) * radius - 0.5;
                            const boneY = tileY + 0.5 + Math.sin(angle) * radius - 0.5;
                            
                            witch.bones.push({
                                x: boneX,
                                y: boneY,
                                rotation: Math.random() * Math.PI * 2,
                                scale: 0.3 + Math.random() * 0.2,
                                type: Math.random() < 0.5 ? 'skull' : 'bone'
                            });
                            
                            witch.returningFromKill = false;
                            
                            if (witch.bones.length >= 15 && !witch.boneRitualActive) {
                                witch.phase = 'bone_ritual_ascending';
                                witch.boneRitualTimer = 0;
                                witch.boneRitualActive = true;
                                witch.magicCircleRadius = 0;
                                witch.magicCircleRotation = 0;
                                witch.consumedBones = [];
                            }
                        }
                        
                        witch.phase = 'in_house';
                        witch.houseTimer = 0;
                        witch.currentSpeed = 0;
                    }
                    break;
                    
                case 'bone_ritual_ascending':
                    const spireHeight = 60;
                    const targetHeight = spireHeight;
                    
                    if (witch.currentHeight < targetHeight) {
                        witch.currentHeight = Math.min(targetHeight, witch.currentHeight + 3);
                        witch.x = witch.houseX;
                        witch.y = witch.houseY;
                    } else {
                        witch.phase = 'bone_ritual_channeling';
                        witch.facingRight = true;
                    }
                    break;
                    
                case 'bone_ritual_channeling':
                    witch.boneRitualTimer++;
                    
                    if (witch.boneRitualTimer < 60) {
                        witch.magicCircleRadius = (witch.boneRitualTimer / 60) * 4;
                    } else {
                        witch.magicCircleRadius = 4;
                    }
                    
                    witch.magicCircleRotation += 0.02;
                    
                    if (witch.boneRitualTimer >= 60 && witch.bones.length > 0) {
                        const consumeRate = 2;
                        for (let i = 0; i < consumeRate && witch.bones.length > 0; i++) {
                            const bone = witch.bones.shift();
                            witch.consumedBones.push({
                                ...bone,
                                startX: bone.x,
                                startY: bone.y,
                                progress: 0,
                                spiralAngle: Math.atan2(bone.y - witch.houseY, bone.x - witch.houseX)
                            });
                        }
                    }
                    
                    witch.consumedBones = witch.consumedBones.filter(bone => {
                        bone.progress += 0.03;
                        if (bone.progress >= 1) {
                            for (let i = 0; i < 5; i++) {
                                game.divineEffects.push(new WitchDarkPowerParticle(
                                    witch.houseX,
                                    witch.houseY,
                                    world.id,
                                    witch
                                ));
                            }
                            return false;
                        }
                        
                        const radius = (1 - bone.progress) * Math.sqrt(
                            Math.pow(bone.startX - witch.houseX, 2) + 
                            Math.pow(bone.startY - witch.houseY, 2)
                        );
                        bone.spiralAngle += 0.1 * (1 + bone.progress);
                        bone.x = witch.houseX + Math.cos(bone.spiralAngle) * radius;
                        bone.y = witch.houseY + Math.sin(bone.spiralAngle) * radius;
                        bone.scale *= 0.98;
                        
                        return true;
                    });
                    
                    witch.darkPowerCharge = Math.min(1, witch.boneRitualTimer / 180);
                    
                    if (witch.boneRitualTimer >= witch.boneRitualDuration) {
                        witch.phase = 'bone_ritual_descending';
                        witch.boneRitualTimer = 0;
                        witch.darkPowerCharge = 0;
                        witch.magicCircleRadius = 0;
                        witch.boneRitualActive = false;
                        
                        // Activate world-specific darkness
                        witch.worldDarkness.active = true;
                        witch.worldDarkness.timer = 0;
                        
                        for (let i = 0; i < 20; i++) {
                            const angle = (Math.PI * 2 / 20) * i;
                            game.divineEffects.push(new DarkPowerConsumeParticle(
                                witch.houseX,
                                witch.houseY + witch.currentHeight,
                                world.id,
                                angle,
                                3
                            ));
                        }
                    }
                    break;
                    
                case 'bone_ritual_descending':
                    if (witch.currentHeight > 0) {
                        witch.currentHeight = Math.max(0, witch.currentHeight - 3);
                    } else {
                        witch.phase = 'in_house';
                        witch.houseTimer = 0;
                    }
                    break;
                    
                case 'eternal_hunt':
                    // Same as Terra witch eternal hunt
                    if (!witch.targetArmy || !witch.targetArmy.alive) {
                        const searchRadius = 50; // Increased from 30
                        let nearestTarget = null;
                        let nearestDist = searchRadius;
                        
                        for (const army of world.armies) {
                            if (army.alive && army.units > 0) {
                                const dist = Math.abs(army.currentX - witch.x) + Math.abs(army.currentY - witch.y);
                                if (dist < nearestDist) {
                                    nearestDist = dist;
                                    nearestTarget = army;
                                }
                            }
                        }
                        
                        if (!nearestTarget) {
                            for (const kingdom of world.kingdoms) {
                                if (kingdom.alive) {
                                    for (const group of kingdom.recruitGroups) {
                                        if (group.alive && group.recruits > 0) {
                                            const dist = Math.abs(group.x - witch.x) + Math.abs(group.y - witch.y);
                                            if (dist < nearestDist) {
                                                nearestDist = dist;
                                                nearestTarget = group;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        witch.targetArmy = nearestTarget;
                    }
                    
                    if (witch.targetArmy) {
                        const targetX = witch.targetArmy.currentX || witch.targetArmy.x;
                        const targetY = witch.targetArmy.currentY || witch.targetArmy.y;
                        const huntDistX = targetX - witch.x;
                        const huntDistY = targetY - witch.y;
                        const huntDist = Math.sqrt(huntDistX * huntDistX + huntDistY * huntDistY);
                        
                        const huntIso = worldToIsometric(witch.x, witch.y);
                        const targetHuntIso = worldToIsometric(targetX, targetY);
                        witch.facingRight = targetHuntIso.x > huntIso.x;
                        
                        if (huntDist > 5) {
                            witch.currentSpeed = Math.min(witch.currentSpeed + witch.acceleration, witch.maxSpeed);
                            witch.x += (huntDistX / huntDist) * witch.currentSpeed;
                            witch.y += (huntDistY / huntDist) * witch.currentSpeed;
                        } else if (huntDist > 0.5) {
                            witch.currentHeight = Math.max(5, witch.currentHeight - 8);
                            witch.x += (huntDistX / huntDist) * witch.maxSpeed * 1.2;
                            witch.y += (huntDistY / huntDist) * witch.maxSpeed * 1.2;
                        } else {
                            consumeArmyWithDarkPower(world, witch, witch.targetArmy);
                            witch.targetArmy = null;
                            witch.currentHeight = witch.height;
                        }
                    } else {
                        witch.currentSpeed = witch.maxSpeed * 0.5;
                        const wanderAngle = game.currentTick * 0.01;
                        witch.x += Math.cos(wanderAngle) * witch.currentSpeed;
                        witch.y += Math.sin(wanderAngle) * witch.currentSpeed;
                        
                        witch.x = Math.max(5, Math.min(WORLD_SIZE - 5, witch.x));
                        witch.y = Math.max(5, Math.min(WORLD_SIZE - 5, witch.y));
                    }
                    break;
            }
            
            // Update world-specific darkness
            if (witch.worldDarkness.active) {
                witch.worldDarkness.timer++;
                
                if (witch.worldDarkness.transitionProgress < 1) {
                    witch.worldDarkness.transitionProgress = Math.min(1, witch.worldDarkness.transitionProgress + witch.worldDarkness.transitionSpeed);
                }
                
                if (!game.terraDarkness.isPermanent && witch.worldDarkness.timer >= witch.worldDarkness.duration) {
                    witch.worldDarkness.active = false;
                }
            } else if (witch.worldDarkness.transitionProgress > 0 && !game.terraDarkness.isPermanent) {
                witch.worldDarkness.transitionProgress = Math.max(0, witch.worldDarkness.transitionProgress - witch.worldDarkness.transitionSpeed);
            }
            
            // Update animations
            witch.lastX = witch.x;
            witch.lastY = witch.y;
            
            if (witch.smokeParticles.length > 0) {
                witch.smokeParticles = witch.smokeParticles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.98;
                    particle.vy -= 0.0002;
                    particle.age++;
                    return particle.age < particle.maxAge;
                });
            }
            
            if (witch.hasHouse && game.currentTick % 15 === 0 && witch.smokeParticles.length < 20) {
                witch.smokeParticles.push({
                    x: witch.houseX + (Math.random() - 0.5) * 0.5,
                    y: witch.houseY + (Math.random() - 0.5) * 0.5,
                    vx: (Math.random() - 0.5) * 0.01,
                    vy: -0.02 - Math.random() * 0.01,
                    age: 0,
                    maxAge: 120,
                    size: 0.3 + Math.random() * 0.2
                });
            }
            
            witch.bobPhase += 0.05;
            witch.bobOffset = Math.sin(witch.bobPhase) * 5;
            
            const targetTilt = witch.currentSpeed > 0 ? (witch.facingRight ? 0.1 : -0.1) : 0;
            witch.broomTilt += (targetTilt - witch.broomTilt) * 0.1;
            
            const targetOpacity = Math.max(0.1, 1 - (witch.currentHeight / 200));
            witch.shadowOpacity += (targetOpacity - witch.shadowOpacity) * 0.1;
            
            // Create smoke trail when flying
            if ((witch.phase === 'flying_patrol' || witch.phase === 'hunting_army' || witch.phase === 'returning_home' || witch.phase === 'eternal_hunt') && 
                witch.currentSpeed > 0) {
                // Get broom position
                const broomAngle = witch.facingRight ? 0 : Math.PI;
                const broomLength = 6; // Length to bristles
                const broomX = witch.x + Math.cos(broomAngle) * 0.1; // Small offset in world units
                const broomY = witch.y + Math.sin(broomAngle) * 0.1;
                
                // Add to smoke trail
                witch.smokeTrail.push({
                    x: broomX,
                    y: broomY,
                    age: 0,
                    size: 1.5
                });
                
                // Limit trail length
                if (witch.smokeTrail.length > 30) {
                    witch.smokeTrail.shift();
                }
            }
            
            // Update smoke trail
            witch.smokeTrail = witch.smokeTrail.filter(point => {
                point.age++;
                return point.age < 60; // Trail lasts 1 second
            });
        }

        // Giant Fish update function
        function updateGiantFish() {
            const fish = game.giantFish;
            const aquaWorld = worlds.find(w => w.name === 'Aqua');
            
            if (!aquaWorld || camera.viewMode !== 'world' || camera.currentWorld !== aquaWorld) return; // Only update when viewing Aqua world
            
            // Function to find a new army or recruit to track
            function findNewArmyToTrack() {
                // Reset current tracking
                fish.trackedArmy = null;
                fish.trackedRecruit = null;
                
                // Get all armies in Aqua world
                const aquaArmies = [];
                // Loop through all worlds to find kingdoms
                for (let w = 0; w < worlds.length; w++) {
                    if (worlds[w].kingdoms) {
                        worlds[w].kingdoms.forEach(kingdom => {
                            if (kingdom.armies) {
                                kingdom.armies.forEach(army => {
                                    if (army.worldId === aquaWorld.id && army.alive) {
                                        aquaArmies.push(army);
                                    }
                                });
                            }
                        });
                    }
                }
                
                // If there are armies, pick a random one
                if (aquaArmies.length > 0) {
                    fish.trackedArmy = aquaArmies[Math.floor(Math.random() * aquaArmies.length)];
                    return;
                }
                
                // No armies found, look for recruits
                const aquaRecruits = [];
                for (let w = 0; w < worlds.length; w++) {
                    if (worlds[w].kingdoms) {
                        worlds[w].kingdoms.forEach(kingdom => {
                            if (kingdom.pendingRecruits) {
                                kingdom.pendingRecruits.forEach(recruit => {
                                    if (recruit.worldId === aquaWorld.id && recruit.alive) {
                                        aquaRecruits.push(recruit);
                                    }
                                });
                            }
                        });
                    }
                }
                
                // If there are recruits, pick a random one
                if (aquaRecruits.length > 0) {
                    fish.trackedRecruit = aquaRecruits[Math.floor(Math.random() * aquaRecruits.length)];
                }
                
                // If still nothing found, the eye will just look forward
            }
            
            // Update eye tracking regardless of phase
            let targetX, targetY, targetAlive = false;
            
            if (fish.trackedArmy && fish.trackedArmy.alive) {
                // Tracking an army
                targetX = fish.trackedArmy.currentX;
                targetY = fish.trackedArmy.currentY;
                targetAlive = true;
            } else if (fish.trackedRecruit && fish.trackedRecruit.alive) {
                // Tracking a recruit
                targetX = fish.trackedRecruit.x;
                targetY = fish.trackedRecruit.y;
                targetAlive = true;
            }
            
            if (targetAlive) {
                // Track the target with the eye - convert to isometric for proper angle
                const fishIso = worldToIsometric(fish.x, fish.y);
                const targetIso = worldToIsometric(targetX, targetY);
                
                // Calculate angle from eye position to target position in screen space
                // The eye is at fish position but 720 pixels higher, and 25 units to the right
                const eyeScreenX = fishIso.x + (fish.facingRight ? 25 * fish.scale : -25 * fish.scale);
                const eyeScreenY = fishIso.y - 864;
                
                // Target is on the ground
                const dx = targetIso.x - eyeScreenX;
                const dy = targetIso.y - eyeScreenY;
                
                // Calculate the angle from eye to target
                fish.targetEyeAngle = Math.atan2(dy, dx);
                
                // When facing left, we need to adjust the angle since the eye rotates differently
                if (!fish.facingRight) {
                    fish.targetEyeAngle = Math.PI - fish.targetEyeAngle;
                }
                
                // Check if target died
                if ((fish.trackedArmy && !fish.trackedArmy.alive) || 
                    (fish.trackedRecruit && !fish.trackedRecruit.alive)) {
                    findNewArmyToTrack();
                }
            } else {
                // Lost target, find a new one
                findNewArmyToTrack();
            }
            
            // Smooth eye movement
            let angleDiff = fish.targetEyeAngle - fish.eyeAngle;
            // Normalize angle difference to [-PI, PI]
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            fish.eyeAngle += angleDiff * 0.1;
            
            // Handle different phases
            switch (fish.phase) {
                case 'waiting':
                    fish.waitTimer++;
                    if (fish.waitTimer >= fish.waitDuration) {
                        // Start entering from random direction
                        fish.phase = 'entering';
                        fish.active = true;
                        
                        // Random entry direction (0-3: left, right, top, bottom)
                        const entryDirection = Math.floor(Math.random() * 4);
                        fish.entryDirection = entryDirection;
                        const offset = 50; // Spawn close but with room to accelerate
                        
                        switch (entryDirection) {
                            case 0: // From left
                                fish.x = -offset;
                                fish.y = WORLD_SIZE * (0.2 + Math.random() * 0.6);
                                break;
                            case 1: // From right
                                fish.x = WORLD_SIZE + offset;
                                fish.y = WORLD_SIZE * (0.2 + Math.random() * 0.6);
                                break;
                            case 2: // From top
                                fish.x = WORLD_SIZE * (0.2 + Math.random() * 0.6);
                                fish.y = -offset;
                                break;
                            case 3: // From bottom
                                fish.x = WORLD_SIZE * (0.2 + Math.random() * 0.6);
                                fish.y = WORLD_SIZE + offset;
                                break;
                        }
                        
                        // Target the exact center of the map
                        fish.targetX = WORLD_SIZE / 2; // Exact center X
                        fish.targetY = WORLD_SIZE / 2; // Exact center Y
                        fish.waitTimer = 0;
                        findNewArmyToTrack();
                    }
                    break;
                    
                case 'entering':
                    // Move towards center
                    const enterDx = fish.targetX - fish.x;
                    const enterDy = fish.targetY - fish.y;
                    const enterDist = Math.sqrt(enterDx * enterDx + enterDy * enterDy);
                    
                    // Update facing direction based on screen movement (isometric projection)
                    // Convert current and target positions to screen coordinates
                    const currentIso = worldToIsometric(fish.x, fish.y);
                    const targetIso = worldToIsometric(fish.targetX, fish.targetY);
                    const screenDx = targetIso.x - currentIso.x;
                    
                    if (Math.abs(screenDx) > 0.1) {
                        fish.facingRight = screenDx > 0;
                    }
                    
                    if (enterDist > 20) {
                        // Far from target - accelerate
                        fish.currentSpeed = Math.min(fish.currentSpeed + fish.acceleration, fish.maxSpeed);
                    } else if (enterDist > 1) {
                        // Close to target - decelerate
                        fish.currentSpeed = Math.max(fish.currentSpeed - fish.acceleration * 2, 0.01);
                    } else {
                        // Reached center, start watching
                        fish.phase = 'watching';
                        fish.watchTimer = 0;
                        fish.currentSpeed = 0;
                        // Calculate movement angle to continue in same direction
                        fish.movementAngle = Math.atan2(enterDy, enterDx);
                        findNewArmyToTrack();
                        break;
                    }
                    
                    // Apply movement with current speed
                    fish.x += (enterDx / enterDist) * fish.currentSpeed;
                    fish.y += (enterDy / enterDist) * fish.currentSpeed;
                    break;
                    
                case 'watching':
                    fish.watchTimer++;
                    
                    if (fish.watchTimer >= fish.watchDuration) {
                        // Time to exit - continue in original direction
                        fish.phase = 'exiting';
                        
                        // Continue in the direction it was moving
                        const exitDistance = WORLD_SIZE + 50; // Exit close to world bounds
                        fish.targetX = fish.x + Math.cos(fish.movementAngle) * exitDistance;
                        fish.targetY = fish.y + Math.sin(fish.movementAngle) * exitDistance;
                    }
                    break;
                    
                case 'exiting':
                    // Move towards exit
                    const exitDx = fish.targetX - fish.x;
                    const exitDy = fish.targetY - fish.y;
                    const exitDist = Math.sqrt(exitDx * exitDx + exitDy * exitDy);
                    
                    // Update facing direction based on screen movement (isometric projection)
                    const exitCurrentIso = worldToIsometric(fish.x, fish.y);
                    const exitTargetIso = worldToIsometric(fish.targetX, fish.targetY);
                    const exitScreenDx = exitTargetIso.x - exitCurrentIso.x;
                    
                    if (Math.abs(exitScreenDx) > 0.1) {
                        fish.facingRight = exitScreenDx > 0;
                    }
                    
                    // Accelerate when leaving
                    fish.currentSpeed = Math.min(fish.currentSpeed + fish.acceleration, fish.maxSpeed);
                    
                    if (exitDist > 1) {
                        fish.x += (exitDx / exitDist) * fish.currentSpeed;
                        fish.y += (exitDy / exitDist) * fish.currentSpeed;
                    } else {
                        // Check if fish is actually off-screen (just outside world bounds)
                        const margin = 55;
                        if (fish.x < -margin || fish.x > WORLD_SIZE + margin || 
                            fish.y < -margin || fish.y > WORLD_SIZE + margin) {
                            // Exited, start waiting
                            fish.phase = 'waiting';
                            fish.active = false;
                            fish.waitTimer = 0;
                            fish.currentSpeed = 0;
                        }
                    }
                    break;
            }
            
            // Update animation waves
            fish.bodyWave += 0.02;
            fish.finWave += 0.04;
            
            // Update shadow opacity based on current tile
            const tileX = Math.floor(fish.x);
            const tileY = Math.floor(fish.y);
            let targetShadowOpacity = 0;
            
            if (tileX >= 0 && tileX < WORLD_SIZE && tileY >= 0 && tileY < WORLD_SIZE) {
                const tile = aquaWorld.tiles[tileX][tileY];
                if (tile && tile.elevation > 0) {
                    targetShadowOpacity = 1; // Full opacity over land
                }
            }
            
            // Smooth transition
            const shadowFadeSpeed = 0.05;
            if (fish.shadowOpacity < targetShadowOpacity) {
                fish.shadowOpacity = Math.min(fish.shadowOpacity + shadowFadeSpeed, targetShadowOpacity);
            } else if (fish.shadowOpacity > targetShadowOpacity) {
                fish.shadowOpacity = Math.max(fish.shadowOpacity - shadowFadeSpeed, targetShadowOpacity);
            }
            
            // Generate particles when moving (not during watching phase)
            // Particle emission removed
        }
        
        // Terra Witch update function
        function updateTerraWitch() {
            const witch = game.terraWitch;
            const terraWorld = worlds.find(w => w.name === 'Terra');
            
            if (!terraWorld) return;
            
            // Handle different phases
            switch (witch.phase) {
                case 'waiting':
                    witch.waitTimer++;
                    // Check if we're in respawn cooldown
                    const timeSinceDeath = game.currentTick - witch.deathTime;
                    const canRespawn = witch.deathTime === 0 || timeSinceDeath >= witch.respawnCooldown;
                    
                    if (witch.waitTimer >= witch.waitDuration && canRespawn) {
                        // Start entering
                        witch.phase = 'entering';
                        witch.active = true;
                        
                        // Random entry direction (0-3: left, right, top, bottom)
                        witch.entryDirection = Math.floor(Math.random() * 4);
                        const offset = 50; // Spawn distance from map edge
                        
                        switch (witch.entryDirection) {
                            case 0: // From left
                                witch.x = -offset;
                                witch.y = WORLD_SIZE * (0.2 + Math.random() * 0.6);
                                break;
                            case 1: // From right
                                witch.x = WORLD_SIZE + offset;
                                witch.y = WORLD_SIZE * (0.2 + Math.random() * 0.6);
                                break;
                            case 2: // From top
                                witch.x = WORLD_SIZE * (0.2 + Math.random() * 0.6);
                                witch.y = -offset;
                                break;
                            case 3: // From bottom
                                witch.x = WORLD_SIZE * (0.2 + Math.random() * 0.6);
                                witch.y = WORLD_SIZE + offset;
                                break;
                        }
                        
                        witch.waitTimer = 0;
                        witch.currentSpeed = 0;
                        witch.currentHeight = witch.height;
                    }
                    break;
                    
                case 'entering':
                    if (!witch.hasHouse) {
                        // Find secluded tile for house
                        const secludedTile = findSecludedTileForWitch(terraWorld);
                        if (secludedTile) {
                            witch.targetX = secludedTile.x;
                            witch.targetY = secludedTile.y;
                            witch.phase = 'finding_home';
                        } else {
                            // If no secluded tile found, try a less restrictive search
                            console.log("No secluded tile found for witch, using fallback");
                            // Use center of world as fallback
                            witch.targetX = WORLD_SIZE / 2 + (Math.random() - 0.5) * 20;
                            witch.targetY = WORLD_SIZE / 2 + (Math.random() - 0.5) * 20;
                            witch.phase = 'finding_home';
                        }
                    } else {
                        // Return to house after respawn
                        witch.targetX = witch.houseX;
                        witch.targetY = witch.houseY;
                        witch.phase = 'returning_home';
                    }
                    break;
                    
                case 'finding_home':
                    // Fly to secluded tile
                    const homeDistX = witch.targetX - witch.x;
                    const homeDistY = witch.targetY - witch.y;
                    const homeDist = Math.sqrt(homeDistX * homeDistX + homeDistY * homeDistY);
                    
                    // Update facing direction
                    const homeIso = worldToIsometric(witch.x, witch.y);
                    const targetHomeIso = worldToIsometric(witch.targetX, witch.targetY);
                    witch.facingRight = targetHomeIso.x > homeIso.x;
                    
                    // Accelerate
                    witch.currentSpeed = Math.min(witch.currentSpeed + witch.acceleration, witch.maxSpeed);
                    
                    if (homeDist > 1) {
                        witch.x += (homeDistX / homeDist) * witch.currentSpeed;
                        witch.y += (homeDistY / homeDist) * witch.currentSpeed;
                    } else {
                        // Arrived at home location
                        witch.phase = 'building_house';
                        witch.buildingTimer = 0;
                        witch.currentSpeed = 0;
                        witch.darkPowerCharge = 0;
                    }
                    break;
                    
                case 'building_house':
                    // Validate the tile is actually land before building
                    const buildX = Math.floor(witch.x);
                    const buildY = Math.floor(witch.y);
                    if (buildX >= 0 && buildX < WORLD_SIZE && buildY >= 0 && buildY < WORLD_SIZE) {
                        const buildTile = terraWorld.tiles[buildX][buildY];
                        if (!buildTile || !buildTile.active || buildTile.elevation <= 0) {
                            // Can't build on water or air tiles, find nearest land
                            const nearbyLand = findNearestLandTile(terraWorld, witch.x, witch.y);
                            if (nearbyLand) {
                                witch.targetX = nearbyLand.x;
                                witch.targetY = nearbyLand.y;
                                witch.phase = 'finding_home';
                                witch.buildingTimer = 0;
                                break;
                            } else {
                                // No land nearby, respawn
                                witch.phase = 'waiting';
                                witch.active = false;
                                witch.waitTimer = 0;
                                break;
                            }
                        }
                    } else {
                        // Witch is outside map bounds, find nearest land
                        const nearbyLand = findNearestLandTile(terraWorld, witch.x, witch.y);
                        if (nearbyLand) {
                            witch.x = nearbyLand.x;
                            witch.y = nearbyLand.y;
                            witch.buildingTimer = 0;
                        } else {
                            // No valid location, respawn
                            witch.phase = 'waiting';
                            witch.active = false;
                            witch.waitTimer = 0;
                            break;
                        }
                    }
                    
                    // Land on ground first
                    if (witch.currentHeight > 0) {
                        witch.currentHeight = Math.max(0, witch.currentHeight - 5);
                    } else {
                        // On ground, start building
                        witch.buildingTimer++;
                        witch.darkPowerCharge = Math.min(witch.buildingTimer / witch.buildingDuration, 1);
                        
                        // Create dark power particles
                        if (witch.buildingTimer % 2 === 0) {
                            for (let i = 0; i < 3; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const radius = Math.random() * 30;
                                game.divineEffects.push(new WitchDarkPowerParticle(
                                    witch.x + Math.cos(angle) * radius,
                                    witch.y + Math.sin(angle) * radius,
                                    terraWorld.id,
                                    witch
                                ));
                            }
                        }
                        
                        if (witch.buildingTimer >= witch.buildingDuration) {
                            // Create house/spire
                            createWitchHouse(terraWorld, witch.x, witch.y);
                            witch.hasHouse = true;
                            witch.houseX = witch.x;
                            witch.houseY = witch.y;
                            witch.phase = 'in_house';
                            witch.houseTimer = 0;
                            witch.darkPowerCharge = 0;
                            witch.currentHeight = witch.height; // Fly back up after building
                        }
                    }
                    break;
                    
                case 'in_house':
                    witch.houseTimer++;
                    
                    // Generate smoke particles while in house
                    if (game.currentTick % 10 === 0 && witch.smokeParticles.length < 30) {
                        // Calculate the actual chimney position accounting for spire twist
                        const topTwist = Math.sin(6 * 0.8) * 4; // Same twist as top of spire
                        
                        // Convert chimney screen position to world coordinates
                        // Chimney is at houseX + houseWidth/2 - 5, but we need to account for twist
                        // and convert from isometric screen units to world units
                        const chimneyScreenX = topTwist + 7 - 3.5; // topTwist + houseWidth/2 - 3.5 (7 is half of 14, 3.5 positions chimney)
                        const chimneyScreenY = 0; // At house level
                        
                        // Convert isometric offset to world coordinates
                        const chimneyWorldOffsetX = chimneyScreenX / 20; // Approximate conversion
                        const chimneyWorldOffsetY = chimneyScreenY / 20;
                        
                        witch.smokeParticles.push({
                            x: witch.houseX + chimneyWorldOffsetX + (Math.random() - 0.5) * 0.1,
                            y: witch.houseY + chimneyWorldOffsetY + (Math.random() - 0.5) * 0.1,
                            vx: (Math.random() - 0.5) * 0.01,
                            vy: -0.03 - Math.random() * 0.01,
                            age: 0,
                            maxAge: 150,
                            size: 0.2 + Math.random() * 0.1
                        });
                    }
                    
                    if (witch.houseTimer >= witch.houseDuration) {
                        // Check if patrol time is up
                        if (witch.patrolTimer >= witch.patrolDuration) {
                            // Patrol period has ended, go back to waiting
                            witch.phase = 'waiting';
                            witch.active = false;
                            witch.waitTimer = 0;
                            witch.patrolTimer = 0;
                        } else {
                            // Exit house to platform
                            witch.phase = 'observing_spire';
                            witch.observeTimer = 0;
                            witch.houseTimer = 0;
                        }
                        
                        // Calculate platform height
                        const topTwist = Math.sin(6 * 0.8) * 4;
                        let actualSpireHeight = 0;
                        for (let j = 0; j < 6; j++) {
                            const floorHeight = (j === 0 || j === 5) ? 12 : 10;
                            actualSpireHeight += floorHeight - (j > 0 ? 1 : 0);
                        }
                        
                        // Get tile position at witch house location
                        const tileX = Math.floor(witch.houseX);
                        const tileY = Math.floor(witch.houseY);
                        
                        // Position at tile center (same as spire)
                        witch.x = tileX;
                        witch.y = tileY;
                        let tileElevation = 0;
                        if (tileX >= 0 && tileX < WORLD_SIZE && tileY >= 0 && tileY < WORLD_SIZE) {
                            const tile = terraWorld.tiles[tileX][tileY];
                            if (tile) {
                                // Tile elevation offset (same calculation as in rendering)
                                tileElevation = (tile.height - 0.65) * 240;
                            }
                        }
                        
                        witch.currentHeight = tileElevation + actualSpireHeight; // Tile elevation + spire height
                        
                        // Face away from center (observing outward)
                        const centerX = WORLD_SIZE / 2;
                        const centerY = WORLD_SIZE / 2;
                        const angleFromCenter = Math.atan2(witch.y - centerY, witch.x - centerX);
                        witch.facingRight = Math.cos(angleFromCenter) > 0;
                    }
                    break;
                    
                case 'observing_spire':
                    witch.observeTimer++;
                    
                    // Subtle idle animation - slight sway
                    witch.bobOffset = Math.sin(witch.observeTimer * 0.02) * 2;
                    
                    // After observing, start flying
                    if (witch.observeTimer >= 180) { // 3 seconds of observing
                        witch.phase = 'flying_patrol';
                        // Only reset patrol timer if witch hasn't completed initial roaming period
                        if (witch.patrolTimer < witch.roamingDuration) {
                            witch.patrolTimer = 0;
                        }
                        witch.observeTimer = 0;
                        
                        // Track when witch exited house for hunting delay
                        witch.exitHouseTick = game.currentTick;
                        
                        // Start flying from spire height
                        witch.currentHeight = 60; // Spire height
                        
                        // Initialize patrol position
                        const centerX = WORLD_SIZE / 2;
                        const centerY = WORLD_SIZE / 2;
                        witch.patrolRadius = WORLD_SIZE * 0.2;
                        witch.patrolAngle = Math.atan2(witch.y - centerY, witch.x - centerX);
                        witch.patrolWobble = 0;
                        
                        // Alternate direction each patrol cycle
                        witch.patrolCycles++;
                        witch.patrolDirection = (witch.patrolCycles % 2 === 0) ? -1 : 1; // Even = counter-clockwise, Odd = clockwise
                        
                        // Start taking off - gradual ascent
                        witch.currentSpeed = witch.maxSpeed * 0.5;
                    }
                    break;
                    
                    
                case 'flying_patrol':
                    witch.patrolTimer++;
                    
                    // Gradually rise to patrol height during first few seconds
                    if (witch.currentHeight < witch.height) {
                        witch.currentHeight = Math.min(witch.height, witch.currentHeight + 2);
                        // Also accelerate during takeoff
                        witch.currentSpeed = Math.min(witch.currentSpeed + witch.acceleration, witch.maxSpeed);
                    } else {
                        witch.currentHeight = witch.height;
                    }
                    
                    // Update patrol position
                    const centerX = WORLD_SIZE / 2;
                    const centerY = WORLD_SIZE / 2;
                    
                    // Update angle based on direction
                    witch.patrolAngle += 0.0017 * witch.patrolDirection; // Completes circle in 12 years (7200 ticks)
                    if (witch.patrolAngle > Math.PI * 2) {
                        witch.patrolAngle -= Math.PI * 2;
                    }
                    if (witch.patrolAngle < -Math.PI * 2) {
                        witch.patrolAngle += Math.PI * 2;
                    }
                    
                    // Add wobble
                    witch.patrolWobble += 0.02;
                    const wobbleX = Math.sin(witch.patrolWobble) * 10;
                    const wobbleY = Math.cos(witch.patrolWobble * 1.3) * 10;
                    
                    // Calculate target position
                    witch.targetX = centerX + Math.cos(witch.patrolAngle) * witch.patrolRadius + wobbleX;
                    witch.targetY = centerY + Math.sin(witch.patrolAngle) * witch.patrolRadius + wobbleY;
                    
                    // Move toward target
                    const patrolDistX = witch.targetX - witch.x;
                    const patrolDistY = witch.targetY - witch.y;
                    const patrolDist = Math.sqrt(patrolDistX * patrolDistX + patrolDistY * patrolDistY);
                    
                    // Update facing
                    const patrolIso = worldToIsometric(witch.x, witch.y);
                    const targetPatrolIso = worldToIsometric(witch.targetX, witch.targetY);
                    witch.facingRight = targetPatrolIso.x > patrolIso.x;
                    
                    if (patrolDist > 0.5) {
                        witch.x += (patrolDistX / patrolDist) * witch.maxSpeed;
                        witch.y += (patrolDistY / patrolDist) * witch.maxSpeed;
                    }
                    
                    // Bob up and down
                    witch.bobPhase += 0.05;
                    witch.bobOffset = Math.sin(witch.bobPhase) * 10;
                    
                    // Check for armies to hunt after 3 years total AND 2 years since leaving house
                    const timeSinceExitHouse = game.currentTick - witch.exitHouseTick;
                    const twoYears = 1200; // 2 years = 1200 ticks
                    
                    if (witch.patrolTimer > witch.roamingDuration && 
                        timeSinceExitHouse >= twoYears &&
                        game.currentTick - witch.lastConsumeTime > witch.consumeCooldown && 
                        !witch.targetArmy) {
                        const loneTarget = findLoneArmyForWitch(terraWorld, witch);
                        if (loneTarget) {
                            witch.targetArmy = loneTarget;
                            witch.phase = 'hunting_army';
                        }
                    }
                    
                    // Check if patrol time is up
                    if (witch.patrolTimer >= witch.patrolDuration) {
                        witch.phase = 'returning_home';
                        witch.targetX = witch.houseX;
                        witch.targetY = witch.houseY;
                        // Don't reset patrol timer - witch has already waited the required time
                    }
                    break;
                    
                case 'hunting_army':
                    if (witch.targetArmy && witch.targetArmy.alive) {
                        // Dive toward target (army or recruit)
                        const targetX = witch.targetArmy.currentX || witch.targetArmy.x;
                        const targetY = witch.targetArmy.currentY || witch.targetArmy.y;
                        const huntDistX = targetX - witch.x;
                        const huntDistY = targetY - witch.y;
                        const huntDist = Math.sqrt(huntDistX * huntDistX + huntDistY * huntDistY);
                        
                        // Update facing
                        const huntIso = worldToIsometric(witch.x, witch.y);
                        const targetHuntIso = worldToIsometric(targetX, targetY);
                        witch.facingRight = targetHuntIso.x > huntIso.x;
                        
                        // Dynamic hunting behavior
                        if (huntDist > 8) {
                            // Far away - maintain height and accelerate
                            witch.currentHeight = Math.min(witch.height, witch.currentHeight + 2);
                            witch.x += (huntDistX / huntDist) * witch.maxSpeed * 1.8;
                            witch.y += (huntDistY / huntDist) * witch.maxSpeed * 1.8;
                        } else if (huntDist > 3) {
                            // Mid-range - start diving
                            witch.currentHeight = Math.max(40, witch.currentHeight - 4);
                            witch.x += (huntDistX / huntDist) * witch.maxSpeed * 1.5;
                            witch.y += (huntDistY / huntDist) * witch.maxSpeed * 1.5;
                            
                            // Removed anticipation particles to avoid confusion
                        } else if (huntDist > 0.5) {
                            // Close - rapid dive
                            witch.currentHeight = Math.max(5, witch.currentHeight - 8);
                            witch.x += (huntDistX / huntDist) * witch.maxSpeed * 1.2;
                            witch.y += (huntDistY / huntDist) * witch.maxSpeed * 1.2;
                        } else {
                            // Start attack animation
                            witch.phase = 'attacking';
                            witch.attackTimer = 0;
                            witch.armRaised = false;
                            witch.currentSpeed = 0;
                        }
                    } else {
                        // Lost target, return to patrol
                        witch.targetArmy = null;
                        witch.phase = 'flying_patrol';
                        witch.currentHeight = witch.height;
                    }
                    break;
                    
                case 'attacking':
                    // Attack animation phase
                    witch.attackTimer++;
                    
                    // Check if target is still alive at start
                    if (witch.attackTimer === 1 && (!witch.targetArmy || !witch.targetArmy.alive)) {
                        // Target died, cancel attack
                        witch.phase = 'flying_patrol';
                        witch.armRaised = false;
                        break;
                    }
                    
                    // Raise arm at start of attack
                    if (witch.attackTimer === 5) {
                        witch.armRaised = true;
                    }
                    
                    // Cast spell midway through
                    if (witch.attackTimer === 15 && witch.targetArmy && witch.targetArmy.alive) {
                        // Consume the target
                        consumeArmyWithDarkPower(terraWorld, witch, witch.targetArmy);
                        witch.targetArmy = null;
                        witch.lastConsumeTime = game.currentTick;
                        witch.returningFromKill = true;
                    }
                    
                    // Wait for spell to finish
                    if (witch.attackTimer >= witch.attackDuration) {
                        witch.armRaised = false;
                        // Always return home after attack attempt
                        witch.phase = 'returning_home';
                        witch.targetX = witch.houseX;
                        witch.targetY = witch.houseY;
                        // Don't reset height - continue from current height
                    }
                    break;
                    
                case 'returning_home':
                    // Target is always the house position for proper entry
                    const returnDistX = witch.houseX - witch.x;
                    const returnDistY = witch.houseY - witch.y;
                    const returnDist = Math.sqrt(returnDistX * returnDistX + returnDistY * returnDistY);
                    const targetHeight = 60; // Spire height
                    const heightDiff = Math.abs(witch.currentHeight - targetHeight);
                    
                    // Update facing
                    const returnIso = worldToIsometric(witch.x, witch.y);
                    const targetReturnIso = worldToIsometric(witch.houseX, witch.houseY);
                    witch.facingRight = targetReturnIso.x > returnIso.x;
                    
                    // Move toward house position
                    witch.currentSpeed = Math.min(witch.currentSpeed + witch.acceleration, witch.maxSpeed);
                    
                    // If not close enough to house position or not at right height, keep moving
                    if (returnDist > 0.5 || heightDiff > 5) {
                        // Horizontal movement
                        if (returnDist > 0.1) {
                            witch.x += (returnDistX / returnDist) * witch.currentSpeed;
                            witch.y += (returnDistY / returnDist) * witch.currentSpeed;
                        }
                        
                        // Vertical movement toward spire height
                        if (witch.currentHeight < targetHeight) {
                            witch.currentHeight = Math.min(targetHeight, witch.currentHeight + 3);
                        } else if (witch.currentHeight > targetHeight) {
                            witch.currentHeight = Math.max(targetHeight, witch.currentHeight - 3);
                        }
                    } else {
                        // Close enough to enter house
                        witch.x = witch.houseX;
                        witch.y = witch.houseY;
                        witch.currentHeight = targetHeight;
                        witch.phase = 'in_house';
                        witch.houseTimer = 0;
                        witch.currentSpeed = 0;
                            
                            // If returning from a kill, place a bone
                            if (witch.returningFromKill) {
                            // Center on the exact tile the spire is on
                            const tileX = Math.floor(witch.houseX);
                            const tileY = Math.floor(witch.houseY);
                            
                            // Place bone only on bottom half of circle (angles from 0 to PI)
                            const angle = Math.random() * Math.PI; // 0 to PI = bottom half
                            const radius = 0.15 + Math.random() * 0.25; // 0.15-0.4 tiles from center
                            
                            // Bones positioned relative to tile center, moved half tile up (north) and half tile left (west)
                            const boneX = tileX + 0.5 + Math.cos(angle) * radius - 0.5; // Subtract 0.5 to move left
                            const boneY = tileY + 0.5 + Math.sin(angle) * radius - 0.5; // Subtract 0.5 to move up
                            
                            witch.bones.push({
                                x: boneX,
                                y: boneY,
                                rotation: Math.random() * Math.PI * 2,
                                scale: 0.3 + Math.random() * 0.2, // Much smaller: 0.3-0.5 scale
                                type: Math.random() < 0.5 ? 'skull' : 'bone'
                            });
                            
                            // Track bones collected during dark period
                            if (game.terraDarkness.active) {
                                witch.bonesDuringDarkPeriod++;
                            }
                            
                            witch.returningFromKill = false;
                            
                            // Check if we've reached required bones for ritual
                            if (witch.bones.length >= 5 && !witch.boneRitualActive && game.terraDarkness.active) {
                                // During dark phase, create dark cloud for 5 bones
                                witch.phase = 'dark_cloud_ritual_ascending';
                                witch.boneRitualTimer = 0;
                                witch.boneRitualActive = true;
                                witch.magicCircleRadius = 0;
                                witch.magicCircleRotation = 0;
                                witch.consumedBones = [];
                            } else if (witch.bones.length >= 15 && !witch.boneRitualActive) {
                                // Normal bone ritual for darkening
                                witch.phase = 'bone_ritual_ascending';
                                witch.boneRitualTimer = 0;
                                witch.boneRitualActive = true;
                                witch.magicCircleRadius = 0;
                                witch.magicCircleRotation = 0;
                                witch.consumedBones = [];
                            }
                        }
                    }
                    break;
                    
                case 'bone_ritual_ascending':
                    // Ascend to spire top
                    const spireHeight = 60;
                    const ritualTargetHeight = spireHeight;
                    
                    if (witch.currentHeight < ritualTargetHeight) {
                        witch.currentHeight = Math.min(ritualTargetHeight, witch.currentHeight + 3);
                        // Position at exact spire location
                        witch.x = witch.houseX;
                        witch.y = witch.houseY;
                    } else {
                        // Reached top, start ritual
                        witch.phase = 'bone_ritual_channeling';
                        witch.facingRight = true; // Face right during ritual
                    }
                    break;
                    
                case 'bone_ritual_channeling':
                    witch.boneRitualTimer++;
                    
                    // Grow magic circle
                    if (witch.boneRitualTimer < 60) {
                        // First second: circle grows
                        witch.magicCircleRadius = (witch.boneRitualTimer / 60) * 4; // Max 4 tiles radius
                    } else {
                        witch.magicCircleRadius = 4;
                    }
                    
                    // Rotate magic circle
                    witch.magicCircleRotation += 0.02; // Clockwise rotation
                    
                    // Start consuming bones after circle is formed
                    if (witch.boneRitualTimer >= 60 && witch.bones.length > 0) {
                        // Consume bones gradually
                        const consumeRate = 2; // Bones per tick
                        for (let i = 0; i < consumeRate && witch.bones.length > 0; i++) {
                            const bone = witch.bones.shift();
                            // Add to consumed bones for animation
                            witch.consumedBones.push({
                                ...bone,
                                startX: bone.x,
                                startY: bone.y,
                                progress: 0,
                                spiralAngle: Math.atan2(bone.y - witch.houseY, bone.x - witch.houseX)
                            });
                        }
                    }
                    
                    // Update consumed bones animation
                    witch.consumedBones = witch.consumedBones.filter(bone => {
                        bone.progress += 0.03;
                        if (bone.progress >= 1) {
                            // Create dark power burst when bone reaches center
                            for (let i = 0; i < 5; i++) {
                                game.divineEffects.push(new WitchDarkPowerParticle(
                                    witch.houseX,
                                    witch.houseY,
                                    terraWorld.id,
                                    witch
                                ));
                            }
                            return false;
                        }
                        
                        // Spiral motion toward witch
                        const radius = (1 - bone.progress) * Math.sqrt(
                            Math.pow(bone.startX - witch.houseX, 2) + 
                            Math.pow(bone.startY - witch.houseY, 2)
                        );
                        bone.spiralAngle += 0.1;
                        bone.x = witch.houseX + Math.cos(bone.spiralAngle) * radius;
                        bone.y = witch.houseY + Math.sin(bone.spiralAngle) * radius;
                        bone.scale *= 0.98; // Shrink as approaching center
                        
                        return true;
                    });
                    
                    // Dark power charge effect
                    witch.darkPowerCharge = Math.min(1, witch.boneRitualTimer / 180); // Builds over 3 seconds
                    
                    // End ritual
                    if (witch.boneRitualTimer >= witch.boneRitualDuration) {
                        witch.phase = 'bone_ritual_descending';
                        witch.boneRitualTimer = 0;
                        witch.darkPowerCharge = 0;
                        witch.magicCircleRadius = 0;
                        witch.boneRitualActive = false;
                        
                        // Activate Terra darkness
                        game.terraDarkness.active = true;
                        game.terraDarkness.timer = 0;
                        
                        // Create final burst effect
                        for (let i = 0; i < 20; i++) {
                            const angle = (Math.PI * 2 / 20) * i;
                            game.divineEffects.push(new DarkPowerConsumeParticle(
                                witch.houseX,
                                witch.houseY + witch.currentHeight,
                                terraWorld.id,
                                angle,
                                3
                            ));
                        }
                    }
                    break;
                    
                case 'bone_ritual_descending':
                    // Descend back to house level
                    if (witch.currentHeight > 0) {
                        witch.currentHeight = Math.max(0, witch.currentHeight - 3);
                    } else {
                        // Back at ground, resume normal routine
                        witch.phase = 'in_house';
                        witch.houseTimer = 0;
                    }
                    break;
                    
                case 'dark_cloud_ritual_ascending':
                    // Ascend to spire top for dark cloud ritual
                    const cloudSpireHeight = 60;
                    const cloudTargetHeight = cloudSpireHeight;
                    
                    if (witch.currentHeight < cloudTargetHeight) {
                        witch.currentHeight = Math.min(cloudTargetHeight, witch.currentHeight + 3);
                        witch.x = witch.houseX;
                        witch.y = witch.houseY;
                    } else {
                        witch.phase = 'dark_cloud_ritual_channeling';
                        witch.facingRight = true;
                    }
                    break;
                    
                case 'dark_cloud_ritual_channeling':
                    witch.boneRitualTimer++;
                    
                    // Create dark cloud ritual - smaller circle, only needs 5 bones
                    if (witch.boneRitualTimer < 60) {
                        witch.magicCircleRadius = (witch.boneRitualTimer / 60) * 3; // Smaller circle
                    } else {
                        witch.magicCircleRadius = 3;
                    }
                    
                    witch.magicCircleRotation += 0.02; // Slower rotation for cloud
                    
                    // Consume bones (only need 5)
                    if (witch.boneRitualTimer >= 60 && witch.bones.length > 0 && witch.consumedBones.length < 5) {
                        const bone = witch.bones.shift();
                        witch.consumedBones.push({
                            ...bone,
                            startX: bone.x,
                            startY: bone.y,
                            progress: 0,
                            spiralAngle: Math.atan2(bone.y - witch.houseY, bone.x - witch.houseX)
                        });
                    }
                    
                    // Update consumed bones animation
                    witch.consumedBones = witch.consumedBones.filter(bone => {
                        bone.progress += 0.03;
                        if (bone.progress >= 1) {
                            for (let i = 0; i < 4; i++) {
                                game.divineEffects.push(new WitchDarkPowerParticle(
                                    witch.houseX,
                                    witch.houseY,
                                    terraWorld.id,
                                    witch
                                ));
                            }
                            return false;
                        }
                        
                        const radius = (1 - bone.progress) * Math.sqrt(
                            Math.pow(bone.startX - witch.houseX, 2) + 
                            Math.pow(bone.startY - witch.houseY, 2)
                        );
                        bone.spiralAngle += 0.08 * (1 + bone.progress);
                        bone.x = witch.houseX + Math.cos(bone.spiralAngle) * radius;
                        bone.y = witch.houseY + Math.sin(bone.spiralAngle) * radius;
                        bone.scale *= 0.98;
                        
                        return true;
                    });
                    
                    witch.darkPowerCharge = Math.min(1, witch.boneRitualTimer / 180); // Builds over 3 seconds
                    
                    // End ritual and create dark cloud
                    if (witch.boneRitualTimer >= 180) { // 3 seconds for cloud ritual
                        witch.phase = 'dark_cloud_ritual_complete';
                        witch.boneRitualTimer = 0;
                        witch.darkPowerCharge = 0;
                        witch.magicCircleRadius = 0;
                        witch.boneRitualActive = false;
                        
                        // Create dark cloud above the map
                        const darkCloud = {
                            x: WORLD_SIZE / 2, // Center of map
                            y: WORLD_SIZE / 2,
                            worldId: terraWorld.id,
                            radius: WORLD_SIZE * 0.8, // Covers most of the map
                            duration: 6000, // 10 years (600 ticks per year)
                            timer: 0,
                            opacity: 0,
                            targetOpacity: 0.7,
                            fadeSpeed: 0.01
                        };
                        
                        game.darkClouds.push(darkCloud);
                        
                        // Create final burst effect
                        for (let i = 0; i < 20; i++) {
                            const angle = (Math.PI * 2 / 20) * i;
                            const speed = 1.5 + Math.random() * 1.5;
                            game.divineEffects.push(new DarkPowerConsumeParticle(
                                witch.houseX,
                                witch.houseY + witch.currentHeight,
                                terraWorld.id,
                                angle,
                                speed
                            ));
                        }
                    }
                    break;
                    
                case 'dark_cloud_ritual_complete':
                    // Descend after portal creation
                    if (witch.currentHeight > 0) {
                        witch.currentHeight = Math.max(0, witch.currentHeight - 3);
                    } else {
                        // If world is permanently dark, go on eternal hunt
                        witch.phase = 'in_house';
                        witch.houseTimer = 0;
                    }
                    break;
                    
                case 'eternal_hunt':
                    // When world is permanently dark, witch hunts forever
                    // Find nearest army or recruit
                    if (!witch.targetArmy || !witch.targetArmy.alive) {
                        const searchRadius = 50; // Increased from 30
                        let nearestTarget = null;
                        let nearestDist = searchRadius;
                        
                        // Search for armies
                        for (const army of terraWorld.armies) {
                            if (army.alive && army.units > 0) {
                                const dist = Math.abs(army.currentX - witch.x) + Math.abs(army.currentY - witch.y);
                                if (dist < nearestDist) {
                                    nearestDist = dist;
                                    nearestTarget = army;
                                }
                            }
                        }
                        
                        // Search for recruits if no armies found
                        if (!nearestTarget) {
                            for (const kingdom of terraWorld.kingdoms) {
                                if (kingdom.alive) {
                                    for (const group of kingdom.recruitGroups) {
                                        if (group.alive && group.recruits > 0) {
                                            const dist = Math.abs(group.x - witch.x) + Math.abs(group.y - witch.y);
                                            if (dist < nearestDist) {
                                                nearestDist = dist;
                                                nearestTarget = group;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        witch.targetArmy = nearestTarget;
                    }
                    
                    // Hunt the target
                    if (witch.targetArmy) {
                        const targetX = witch.targetArmy.currentX || witch.targetArmy.x;
                        const targetY = witch.targetArmy.currentY || witch.targetArmy.y;
                        const huntDistX = targetX - witch.x;
                        const huntDistY = targetY - witch.y;
                        const huntDist = Math.sqrt(huntDistX * huntDistX + huntDistY * huntDistY);
                        
                        // Update facing
                        const huntIso = worldToIsometric(witch.x, witch.y);
                        const targetHuntIso = worldToIsometric(targetX, targetY);
                        witch.facingRight = targetHuntIso.x > huntIso.x;
                        
                        // Move toward target
                        if (huntDist > 5) {
                            witch.currentSpeed = Math.min(witch.currentSpeed + witch.acceleration, witch.maxSpeed);
                            witch.x += (huntDistX / huntDist) * witch.currentSpeed;
                            witch.y += (huntDistY / huntDist) * witch.currentSpeed;
                        } else if (huntDist > 0.5) {
                            witch.currentHeight = Math.max(5, witch.currentHeight - 8);
                            witch.x += (huntDistX / huntDist) * witch.maxSpeed * 1.2;
                            witch.y += (huntDistY / huntDist) * witch.maxSpeed * 1.2;
                        } else {
                            // Start attack animation even in eternal hunt
                            witch.phase = 'eternal_hunt_attacking';
                            witch.attackTimer = 0;
                            witch.armRaised = false;
                            witch.currentSpeed = 0;
                        }
                    } else {
                        // Wander if no targets
                        witch.currentSpeed = witch.maxSpeed * 0.5;
                        const wanderAngle = game.currentTick * 0.01;
                        witch.x += Math.cos(wanderAngle) * witch.currentSpeed;
                        witch.y += Math.sin(wanderAngle) * witch.currentSpeed;
                        
                        // Keep within world bounds
                        witch.x = Math.max(5, Math.min(WORLD_SIZE - 5, witch.x));
                        witch.y = Math.max(5, Math.min(WORLD_SIZE - 5, witch.y));
                    }
                    break;
                    
                case 'eternal_hunt_attacking':
                    // Attack animation in eternal hunt mode
                    witch.attackTimer++;
                    
                    // Raise arm at start of attack
                    if (witch.attackTimer === 5) {
                        witch.armRaised = true;
                    }
                    
                    // Cast spell midway through
                    if (witch.attackTimer === 15 && witch.targetArmy && witch.targetArmy.alive) {
                        // Consume the target
                        consumeArmyWithDarkPower(terraWorld, witch, witch.targetArmy);
                        witch.targetArmy = null;
                    }
                    
                    // Wait for spell to finish then continue hunting
                    if (witch.attackTimer >= witch.attackDuration) {
                        witch.armRaised = false;
                        witch.phase = 'eternal_hunt';
                        // Don't reset height - continue from current height
                    }
                    break;
            }
            
            // Update last position for particle effects
            witch.lastX = witch.x;
            witch.lastY = witch.y;
            
            // Update smoke particles
            if (witch.smokeParticles.length > 0) {
                witch.smokeParticles = witch.smokeParticles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.98; // Drag
                    particle.vy -= 0.0002; // Slight upward acceleration
                    particle.age++;
                    return particle.age < particle.maxAge;
                });
            }
        }
        
        // Find nearest land tile to a position
        function findNearestLandTile(world, x, y) {
            let nearestTile = null;
            let minDistance = Infinity;
            
            // Search in expanding circles
            for (let radius = 1; radius < 10 && !nearestTile; radius++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        // Only check tiles on the perimeter
                        if (Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;
                        
                        const checkX = Math.floor(x) + dx;
                        const checkY = Math.floor(y) + dy;
                        
                        if (checkX >= 0 && checkX < WORLD_SIZE && checkY >= 0 && checkY < WORLD_SIZE) {
                            const tile = world.tiles[checkX][checkY];
                            if (tile && tile.active && tile.elevation > 0) {
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    nearestTile = { x: checkX, y: checkY };
                                }
                            }
                        }
                    }
                }
            }
            
            return nearestTile;
        }
        
        // Find secluded tile for witch house
        function findSecludedTileForWitch(world) {
            const candidates = [];
            
            // Search for suitable tiles, further from center
            const minDistFromCenter = WORLD_SIZE * 0.3; // At least 30% from center
            for (let y = 10; y < WORLD_SIZE - 10; y++) {
                for (let x = 10; x < WORLD_SIZE - 10; x++) {
                    // Check distance from center
                    const distFromCenter = Math.sqrt(Math.pow(x - WORLD_SIZE/2, 2) + Math.pow(y - WORLD_SIZE/2, 2));
                    if (distFromCenter < minDistFromCenter) continue;
                    const tile = world.tiles[x][y];
                    if (!tile.active || tile.elevation <= 0) continue; // Must be active land tile
                    
                    // Check distance from buildings
                    let tooCloseToBuild = false;
                    for (const building of world.buildings) {
                        const dist = Math.sqrt(Math.pow(building.x - x, 2) + Math.pow(building.y - y, 2));
                        if (dist < 5) { // Reduced from 8 to 5
                            tooCloseToBuild = true;
                            break;
                        }
                    }
                    if (tooCloseToBuild) continue;
                    
                    // Check distance from kingdom borders - less restrictive
                    let tooCloseToKingdom = false;
                    for (let dy = -5; dy <= 5; dy++) { // Reduced from 10 to 5
                        for (let dx = -5; dx <= 5; dx++) {
                            const checkX = x + dx;
                            const checkY = y + dy;
                            if (checkX >= 0 && checkX < WORLD_SIZE && checkY >= 0 && checkY < WORLD_SIZE) {
                                if (world.tiles[checkX][checkY].owner !== null) {
                                    tooCloseToKingdom = true;
                                    break;
                                }
                            }
                        }
                        if (tooCloseToKingdom) break;
                    }
                    if (tooCloseToKingdom) continue;
                    
                    // Check for armies
                    let tooCloseToArmy = false;
                    for (const kingdom of world.kingdoms) {
                        for (const army of kingdom.armies) {
                            const dist = Math.sqrt(Math.pow(army.currentX - x, 2) + Math.pow(army.currentY - y, 2));
                            if (dist < 7) { // Reduced from 12 to 7
                                tooCloseToArmy = true;
                                break;
                            }
                        }
                        if (tooCloseToArmy) break;
                    }
                    if (tooCloseToArmy) continue;
                    
                    // This tile is suitable
                    candidates.push({ x, y, elevation: tile.elevation });
                }
            }
            
            // Prefer higher elevation
            candidates.sort((a, b) => b.elevation - a.elevation);
            
            // Return best candidate or random from top 10
            if (candidates.length > 0) {
                const topCandidates = candidates.slice(0, Math.min(10, candidates.length));
                return topCandidates[Math.floor(Math.random() * topCandidates.length)];
            }
            
            return null;
        }
        
        // Find best target for witch to hunt
        function findLoneArmyForWitch(world, witch) {
            const candidates = [];
            const MIN_DISTANCE = 5;
            const MAX_DISTANCE = 25;
            
            // Check all armies in the world
            for (const kingdom of world.kingdoms) {
                for (const army of kingdom.armies) {
                    if (!army.alive || army.units <= 0) continue;
                    
                    // Calculate distance from witch
                    const dist = Math.sqrt(
                        Math.pow((army.currentX || army.x) - witch.x, 2) + 
                        Math.pow((army.currentY || army.y) - witch.y, 2)
                    );
                    
                    // Only consider armies within range
                    if (dist >= MIN_DISTANCE && dist <= MAX_DISTANCE) {
                        candidates.push(army);
                    }
                }
            }
            
            // Check recruits
            for (const recruit of world.recruits) {
                if (!recruit.alive) continue;
                
                const dist = Math.sqrt(
                    Math.pow(recruit.x - witch.x, 2) + 
                    Math.pow(recruit.y - witch.y, 2)
                );
                
                // Only consider recruits 7-10 tiles away
                if (dist >= MIN_DISTANCE && dist <= MAX_DISTANCE) {
                    candidates.push(recruit);
                }
            }
            
            // Pick a random target from candidates
            if (candidates.length > 0) {
                return candidates[Math.floor(Math.random() * candidates.length)];
            }
            
            return null;
        }
        
        // Create witch house/spire
        function createWitchHouse(world, x, y) {
            // Add special building to world
            const house = {
                x: Math.floor(x),
                y: Math.floor(y),
                type: 'witch_house',
                isWitchHouse: true,
                worldId: world.id
            };
            
            world.buildings.push(house);
            
            // Mark tile as occupied
            world.tiles[Math.floor(x)][Math.floor(y)].hasBuilding = true;
            world.tiles[Math.floor(x)][Math.floor(y)].buildingType = 'witch_house';
        }
        
        // createWitchInWorld function removed - only Terra has a witch
        function createWitchInWorld_removed(world) {
            if (game.worldWitches[world.id]) return; // Already has a witch
            
            const witch = {
                active: true,
                worldId: world.id,
                x: 0,
                y: 0,
                targetX: 0,
                targetY: 0,
                phase: 'entering',
                
                // House/Spire location
                houseX: null,
                houseY: null,
                hasHouse: false,
                
                // Timers
                waitTimer: 0,
                houseTimer: 0,
                houseDuration: 600, // 1 year in house
                patrolTimer: 0,
                patrolDuration: 7200,
                buildingTimer: 0,
                buildingDuration: 30,
                
                // Movement
                speed: 0.15,
                currentSpeed: 0,
                maxSpeed: 0.15,
                acceleration: 0.004,
                
                // Circular patrol
                patrolAngle: 0,
                patrolRadius: 0,
                patrolWobble: 0,
                patrolDirection: -1,
                
                // Animation
                height: 150,
                currentHeight: 150,
                bobOffset: 0,
                bobPhase: 0,
                broomTilt: 0,
                
                // Visual
                scale: 1.0,
                facingRight: true,
                shadowOpacity: 1,
                darkPowerCharge: 0,
                
                // Army hunting
                targetArmy: null,
                lastConsumeTime: 0,
                consumeCooldown: 1800,
                returningFromKill: false,
                
                // Entry
                entryDirection: Math.floor(Math.random() * 4),
                lastX: 0,
                lastY: 0,
                
                // House smoke particles
                smokeParticles: [],
                
                // Bones collection
                bones: [],
                bonesDuringDarkPeriod: 0,
                
                // Bone ritual
                boneRitualActive: false,
                boneRitualTimer: 0,
                boneRitualDuration: 360,
                magicCircleRadius: 0,
                magicCircleRotation: 0,
                consumedBones: [],
                
                // World-specific darkness
                worldDarkness: {
                    active: false,
                    timer: 0,
                    duration: 30000, // 50 years
                    transitionProgress: 0,
                    transitionSpeed: 0.01
                },
                
                // Smoke trail
                smokeTrail: []
            };
            
            // Set entry position
            const offset = 50;
            switch (witch.entryDirection) {
                case 0: // From left
                    witch.x = -offset;
                    witch.y = WORLD_SIZE * (0.2 + Math.random() * 0.6);
                    break;
                case 1: // From right
                    witch.x = WORLD_SIZE + offset;
                    witch.y = WORLD_SIZE * (0.2 + Math.random() * 0.6);
                    break;
                case 2: // From top
                    witch.x = WORLD_SIZE * (0.2 + Math.random() * 0.6);
                    witch.y = -offset;
                    break;
                case 3: // From bottom
                    witch.x = WORLD_SIZE * (0.2 + Math.random() * 0.6);
                    witch.y = WORLD_SIZE + offset;
                    break;
            }
            
            game.worldWitches[world.id] = witch;
        }
        
        // checkForPermanentDarkness function removed - only Terra has a witch
        function checkForPermanentDarkness_removed() {
            const witchWorlds = ['Terra', 'Ignis', 'Aqua', 'Aether'];
            let allHaveWitches = true;
            
            for (const worldName of witchWorlds) {
                const world = worlds.find(w => w.name === worldName);
                if (world) {
                    if (worldName === 'Terra') {
                        if (!game.terraWitch.active) {
                            allHaveWitches = false;
                            break;
                        }
                    } else {
                        if (!game.worldWitches[world.id]) {
                            allHaveWitches = false;
                            break;
                        }
                    }
                }
            }
            
            if (allHaveWitches) {
                // Make darkness permanent for all worlds
                game.terraDarkness.isPermanent = true;
                game.terraDarkness.active = true;
                game.terraDarkness.timer = 0;
                
                // Set all witches to eternal hunt mode
                if (game.terraWitch.active && game.terraWitch.phase !== 'eternal_hunt') {
                    game.terraWitch.phase = 'eternal_hunt';
                    game.terraWitch.currentHeight = game.terraWitch.height;
                }
                
                for (const worldId in game.worldWitches) {
                    const witch = game.worldWitches[worldId];
                    if (witch.phase !== 'eternal_hunt') {
                        witch.phase = 'eternal_hunt';
                        witch.currentHeight = witch.height;
                    }
                }
            }
        }
        
        // Consume army or recruit with dark power
        function consumeArmyWithDarkPower(world, witch, target) {
            const targetX = target.currentX || target.x;
            const targetY = target.currentY || target.y;
            const isRecruit = !target.currentX; // Recruits have .x, armies have .currentX
            
            // Create dark power effect - more particles for armies
            const particleCount = isRecruit ? 12 : 20;
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 / particleCount) * i;
                const speed = isRecruit ? 1.5 + Math.random() * 0.5 : 2 + Math.random();
                game.divineEffects.push(new DarkPowerConsumeParticle(
                    targetX,
                    targetY,
                    world.id,
                    angle,
                    speed
                ));
            }
            
            // Add swirling vortex effect
            for (let i = 0; i < 8; i++) {
                const delay = i * 3;
                setTimeout(() => {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 15 - i * 1.5;
                    game.divineEffects.push(new WitchDarkPowerParticle(
                        targetX + Math.cos(angle) * distance,
                        targetY + Math.sin(angle) * distance,
                        world.id,
                        witch
                    ));
                }, delay * 16);
            }
            
            // Kill the target
            target.alive = false;
            if (!isRecruit) {
                target.currentLife = 0;
            }
            
            // Remove from appropriate list
            if (isRecruit) {
                // Remove from world recruits
                world.recruits = world.recruits.filter(r => r !== target);
            } else {
                // Remove from kingdom armies
                const kingdom = world.kingdoms.find(k => k.id === target.kingdomId);
                if (kingdom) {
                    kingdom.armies = kingdom.armies.filter(a => a !== target);
                }
            }
            
            // Witch gains power from consumption
            witch.darkPowerCharge = Math.min(1, witch.darkPowerCharge + 0.2);
        }
        
        // Helper functions
        function calculateSmiteCost(radius) {
            // Full world (25 tiles) = 1000 power
            // Quadratic scaling for reasonable progression
            // cost = (radius/25)^2 * 1000
            const cost = Math.floor(Math.pow(radius / 25, 2) * 1000);
            return Math.max(10, cost); // Minimum cost of 10
        }
        
        function updateSmiteRadius(newRadius) {
            game.abilities.smite.radius = newRadius;
            game.abilities.smite.cost = calculateSmiteCost(newRadius);
            
            // Update UI elements
            document.getElementById('smiteRadius').textContent = newRadius === 25 ? '∞' : newRadius;
            document.getElementById('smiteCost').textContent = game.abilities.smite.cost;
            document.getElementById('smiteBtn').setAttribute('data-cost', game.abilities.smite.cost);
            
            // Update AOE display
            const aoeDisplay = document.getElementById('smiteAoeDisplay');
            if (aoeDisplay) {
                aoeDisplay.textContent = newRadius === 25 ? '∞' : newRadius;
            }
            
            // Update tooltip
            let radiusText = newRadius === 25 ? 'entire world' : newRadius + ' tile radius';
            document.getElementById('smiteTooltip').textContent = 
                `Strike down armies and burn structures in ${radiusText} (${game.abilities.smite.cost} power)`;
            
            // Update button state
            updatePowerDisplay();
        }
        
        function generateKingdomColor() {
            var hue = Math.random() * 360;
            var saturation = 50 + Math.random() * 30;
            var lightness = 40 + Math.random() * 20;
            return 'hsl(' + hue + ', ' + saturation + '%, ' + lightness + '%)';
        }
        
        function generateKingdomName() {
            var prefix = kingdomPrefixes[Math.floor(Math.random() * kingdomPrefixes.length)];
            var suffix = kingdomSuffixes[Math.floor(Math.random() * kingdomSuffixes.length)];
            return prefix + suffix;
        }

        // NEW: Incremental border update helper
        function manhattanDistance(x1, y1, x2, y2) {
            return Math.abs(x2 - x1) + Math.abs(y2 - y1);
        }
        
        function markTileDirty(worldId, x, y) {
            const key = `${worldId},${x},${y}`;
            game.dirtyTiles.set(key, true);
            
            // Also mark neighboring tiles as dirty for border updates
            const neighbors = [
                {dx: 1, dy: 0}, {dx: -1, dy: 0},
                {dx: 0, dy: 1}, {dx: 0, dy: -1}
            ];
            
            for (const n of neighbors) {
                const nx = x + n.dx;
                const ny = y + n.dy;
                if (nx >= 0 && nx < WORLD_SIZE && ny >= 0 && ny < WORLD_SIZE) {
                    game.dirtyTiles.set(`${worldId},${nx},${ny}`, true);
                }
            }
        }
        
        function markAllTilesDirty(worldId) {
            for (let y = 0; y < WORLD_SIZE; y++) {
                for (let x = 0; x < WORLD_SIZE; x++) {
                    game.dirtyTiles.set(`${worldId},${x},${y}`, true);
                }
            }
        }
        
        function addWearToTile(world, x, y, wearAmount) {
            var tileX = Math.floor(x);
            var tileY = Math.floor(y);
            if (tileX >= 0 && tileX < WORLD_SIZE && tileY >= 0 && tileY < WORLD_SIZE) {
                var tile = world.tiles[tileX][tileY];
                if (tile.active && tile.wear < 1) {
                    tile.wear = Math.min(tile.wear + wearAmount, 1);
                    markTileDirty(world.id, tileX, tileY);
                }
            }
        }
        
        function notifyArmiesOfTileCapture(world, tileX, tileY, newOwnerId) {
            // Notify all armies targeting this tile that it has been captured
            const tileKey = tileX + ',' + tileY + ',' + world.id;
            
            // Check all kingdoms' armies
            for (let w = 0; w < worlds.length; w++) {
                if (worlds[w].kingdoms) {
                    worlds[w].kingdoms.forEach(kingdom => {
                        if (kingdom.alive) {
                            kingdom.armies.forEach(army => {
                                if (army.alive && army.targetX === tileX && army.targetY === tileY && 
                                    army.worldId === world.id && army.kingdom.id !== newOwnerId) {
                                    // Mark this army for retargeting
                                    army.needsRetargeting = true;
                                }
                            });
                        }
                    });
                }
            }
        }
        
        function updateBordersAroundTile(world, x, y, oldOwner, newOwner) {
            // Get all kingdoms that might be affected (max 5: old owner, new owner, and 4 neighbors)
            const affectedKingdoms = new Set();
            
            if (oldOwner !== null) {
                const oldKingdom = findKingdomById(oldOwner);
                if (oldKingdom) affectedKingdoms.add(oldKingdom);
            }
            
            if (newOwner !== null) {
                const newKingdom = findKingdomById(newOwner);
                if (newKingdom) affectedKingdoms.add(newKingdom);
            }
            
            // Check all 4 neighbors
            const neighbors = [
                {x: x+1, y: y}, {x: x-1, y: y},
                {x: x, y: y+1}, {x: x, y: y-1}
            ];
            
            for (const n of neighbors) {
                if (n.x >= 0 && n.x < WORLD_SIZE && n.y >= 0 && n.y < WORLD_SIZE) {
                    const neighborOwner = world.tiles[n.x][n.y].owner;
                    if (neighborOwner !== null) {
                        const neighborKingdom = findKingdomById(neighborOwner);
                        if (neighborKingdom) affectedKingdoms.add(neighborKingdom);
                    }
                }
            }
            
            // Update borders for all affected kingdoms
            for (const kingdom of affectedKingdoms) {
                updateKingdomBordersAroundTile(kingdom, world, x, y);
            }
        }
        
        function updateKingdomBordersAroundTile(kingdom, world, centerX, centerY) {
            // Check a 3x3 area around the changed tile
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const checkX = centerX + dx;
                    const checkY = centerY + dy;
                    
                    if (checkX >= 0 && checkX < WORLD_SIZE && checkY >= 0 && checkY < WORLD_SIZE) {
                        const tile = world.tiles[checkX][checkY];
                        const tileKey = checkX + ',' + checkY;
                        
                        if (tile.owner === kingdom.id) {
                            // This is our tile - check if it's a border
                            let isBorder = false;
                            const neighbors = [
                                {x: checkX+1, y: checkY}, {x: checkX-1, y: checkY},
                                {x: checkX, y: checkY+1}, {x: checkX, y: checkY-1}
                            ];
                            
                            for (const n of neighbors) {
                                if (n.x >= 0 && n.x < WORLD_SIZE && n.y >= 0 && n.y < WORLD_SIZE) {
                                    if (world.tiles[n.x][n.y].owner !== kingdom.id) {
                                        isBorder = true;
                                        break;
                                    }
                                }
                            }
                            
                            if (isBorder) {
                                kingdom.borderTiles.add(tileKey);
                            } else {
                                kingdom.borderTiles.delete(tileKey);
                            }
                        } else {
                            // Not our tile - remove from borders if it was there
                            kingdom.borderTiles.delete(tileKey);
                        }
                    }
                }
            }
        }
        
        function findKingdomById(id) {
            // Search all worlds for this kingdom ID
            for (let w = 0; w < worlds.length; w++) {
                const kingdom = worlds[w].kingdoms.find(k => k.id === id);
                if (kingdom) return kingdom;
            }
            return null;
        }
        
        function checkKingdomsBorder(kingdom1Id, kingdom2Id) {
            // Check if two kingdoms border each other (including through portals)
            for (let w = 0; w < worlds.length; w++) {
                const world = worlds[w];
                for (let x = 0; x < WORLD_SIZE; x++) {
                    for (let y = 0; y < WORLD_SIZE; y++) {
                        if (world.tiles[x][y].owner === kingdom1Id) {
                            // Check all neighbors
                            const neighbors = getNeighborsWithCache(x, y, w);
                            for (const neighbor of neighbors) {
                                if (world.tiles[neighbor.x][neighbor.y].owner === kingdom2Id) {
                                    return true;
                                }
                            }
                            // Check portal connections
                            for (const portal of game.portals) {
                                if (portal.active) {
                                    // Check if this tile has a portal
                                    if (portal.worldA === w && portal.tileA.x === x && portal.tileA.y === y) {
                                        // Check if the connected tile belongs to kingdom2
                                        if (worlds[portal.worldB].tiles[portal.tileB.x][portal.tileB.y].owner === kingdom2Id) {
                                            return true;
                                        }
                                    } else if (portal.worldB === w && portal.tileB.x === x && portal.tileB.y === y) {
                                        // Check the other side of the portal
                                        if (worlds[portal.worldA].tiles[portal.tileA.x][portal.tileA.y].owner === kingdom2Id) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }
        
        function declareWar(attackerId, defenderId) {
            // Consume power
            game.power -= game.abilities.war.cost;
            
            // Remove any existing truce between these kingdoms
            game.truces = game.truces.filter(truce => 
                !((truce.kingdom1 === attackerId && truce.kingdom2 === defenderId) ||
                  (truce.kingdom1 === defenderId && truce.kingdom2 === attackerId))
            );
            
            // Add war to active wars
            const warDuration = 5 * 52; // 5 years in ticks
            game.activeWars.push({
                attacker: attackerId,
                defender: defenderId,
                startTick: game.currentTick,
                endTick: game.currentTick + warDuration
            });
            
            // Find the attacker's original capital for god ray effect
            const attacker = findKingdomById(attackerId);
            if (attacker && attacker.originalCapital) {
                // Create red god ray effect
                const capital = attacker.originalCapital;
                game.divineEffects.push(new RedGodRay(capital.x, capital.y, attacker.worldId, warDuration));
            }
            
            // Make attacker target defender
            if (attacker) {
                attacker.targetKingdom = defenderId;
                // Remove truces and set enemies
                delete attacker.truces[defenderId];
                attacker.enemies[defenderId] = true;
                
                // Force attacker to AT_WAR state for divine wars
                attacker.state = KingdomState.AT_WAR;
                attacker.warTarget = defender;
            }
            
            // Find defender and update their state too
            const defender = findKingdomById(defenderId);
            if (defender) {
                delete defender.truces[attackerId];
                defender.enemies[attackerId] = true;
                
                // Defender should be aware they're under attack
                if (!defender.warTarget) {
                    defender.warTarget = attacker;
                    if (defender.state !== KingdomState.AT_WAR) {
                        defender.state = KingdomState.DEFENDING;
                    }
                }
            }
            
            updatePowerDisplay();
        }
        
        function areKingdomsAtWar(kingdom1Id, kingdom2Id) {
            // Check if these kingdoms are currently at war via War god power
            const hasActiveWar = game.activeWars.some(war => 
                (war.attacker === kingdom1Id && war.defender === kingdom2Id) ||
                (war.attacker === kingdom2Id && war.defender === kingdom1Id)
            );
            
            if (hasActiveWar) return true;
            
            // Also check if kingdoms consider each other enemies
            const kingdom1 = findKingdomById(kingdom1Id);
            const kingdom2 = findKingdomById(kingdom2Id);
            
            if (kingdom1 && kingdom2) {
                return (kingdom1.enemies[kingdom2Id] && kingdom2.enemies[kingdom1Id]) && 
                       (!kingdom1.truces[kingdom2Id] && !kingdom2.truces[kingdom1Id]);
            }
            
            return false;
        }
        
        function declarePeace(kingdom1Id, kingdom2Id) {
            // Consume power
            game.power -= game.abilities.peace.cost;
            
            // Remove the war between these kingdoms
            game.activeWars = game.activeWars.filter(war => 
                !((war.attacker === kingdom1Id && war.defender === kingdom2Id) ||
                  (war.attacker === kingdom2Id && war.defender === kingdom1Id))
            );
            
            // Add truce
            const truceDuration = 5 * 52; // 5 years truce
            game.truces.push({
                kingdom1: kingdom1Id,
                kingdom2: kingdom2Id,
                startTick: game.currentTick,
                endTick: game.currentTick + truceDuration
            });
            
            // Find kingdoms for peace effect
            const kingdom1 = findKingdomById(kingdom1Id);
            const kingdom2 = findKingdomById(kingdom2Id);
            
            // Update kingdoms' internal truces (store end tick, not just true)
            const truceEndTick = game.currentTick + truceDuration;
            if (kingdom1) {
                kingdom1.truces[kingdom2Id] = truceEndTick;
                // Remove from enemies list
                delete kingdom1.enemies[kingdom2Id];
            }
            if (kingdom2) {
                kingdom2.truces[kingdom1Id] = truceEndTick;
                // Remove from enemies list
                delete kingdom2.enemies[kingdom1Id];
            }
            
            // Create golden/white god ray effect at both capitals
            if (kingdom1 && kingdom1.originalCapital) {
                const capital = kingdom1.originalCapital;
                game.divineEffects.push(new GoldenGodRay(capital.x, capital.y, kingdom1.worldId, truceDuration));
            }
            if (kingdom2 && kingdom2.originalCapital) {
                const capital = kingdom2.originalCapital;
                game.divineEffects.push(new GoldenGodRay(capital.x, capital.y, kingdom2.worldId, truceDuration));
            }
            
            // Reset target kingdoms if they were targeting each other
            if (kingdom1 && kingdom1.targetKingdom === kingdom2Id) {
                kingdom1.targetKingdom = null;
            }
            if (kingdom2 && kingdom2.targetKingdom === kingdom1Id) {
                kingdom2.targetKingdom = null;
            }
            
            // Reset war states
            if (kingdom1 && kingdom1.warTarget && kingdom1.warTarget.id === kingdom2Id) {
                kingdom1.warTarget = null;
                if (kingdom1.state === KingdomState.AT_WAR || kingdom1.state === KingdomState.DEFENDING) {
                    kingdom1.state = KingdomState.EXPANDING;
                }
            }
            if (kingdom2 && kingdom2.warTarget && kingdom2.warTarget.id === kingdom1Id) {
                kingdom2.warTarget = null;
                if (kingdom2.state === KingdomState.AT_WAR || kingdom2.state === KingdomState.DEFENDING) {
                    kingdom2.state = KingdomState.EXPANDING;
                }
            }
            
            // Make all armies from both kingdoms retarget if they were attacking each other
            if (kingdom1) {
                kingdom1.armies.forEach(army => {
                    if (army.alive && army.targetX !== undefined && army.targetY !== undefined) {
                        // Check if this army is targeting territory of kingdom2
                        const targetWorld = worlds[army.worldId];
                        if (targetWorld && targetWorld.tiles[army.targetX] && 
                            targetWorld.tiles[army.targetX][army.targetY] &&
                            targetWorld.tiles[army.targetX][army.targetY].owner === kingdom2Id) {
                            army.needsRetargeting = true;
                            army.targetX = undefined;
                            army.targetY = undefined;
                        }
                    }
                });
            }
            
            if (kingdom2) {
                kingdom2.armies.forEach(army => {
                    if (army.alive && army.targetX !== undefined && army.targetY !== undefined) {
                        // Check if this army is targeting territory of kingdom1
                        const targetWorld = worlds[army.worldId];
                        if (targetWorld && targetWorld.tiles[army.targetX] && 
                            targetWorld.tiles[army.targetX][army.targetY] &&
                            targetWorld.tiles[army.targetX][army.targetY].owner === kingdom1Id) {
                            army.needsRetargeting = true;
                            army.targetX = undefined;
                            army.targetY = undefined;
                        }
                    }
                });
            }
            
            updatePowerDisplay();
        }
        
        function applyTerraformChanges(world, centerX, centerY, targetHeight) {
            const centerTile = world.tiles[centerX][centerY];
            if (!centerTile || !centerTile.active) return;
            
            const oldCenterHeight = centerTile.height;
            
            // Allow dragging beyond limits to ensure tiles at max/min can still be affected
            // The actual tile heights will be clamped later
            const minDragHeight = -0.5; // Allow dragging below minimum
            const maxDragHeight = 2.0;  // Allow dragging above maximum
            targetHeight = Math.max(minDragHeight, Math.min(maxDragHeight, targetHeight));
            
            const desiredHeightChange = targetHeight - oldCenterHeight;
            
            // Check if we're creating lava (at extreme heights)
            const lavaThreshold = 0.15; // Near minimum
            const peakThreshold = 1.45; // Near maximum
            const minHeight = 0.1;
            const maxHeight = 1.5;
            
            // Apply smooth falloff to all tiles including center
            const maxDistance = game.abilities.terraform.radius; // Use dynamic radius
            const falloffPower = 1.2; // Lower = more gradual falloff
            
            // Store height changes for all affected tiles
            const heightChanges = new Map();
            
            // Calculate height changes for all tiles in the affected area
            for (let dx = -maxDistance; dx <= maxDistance; dx++) {
                for (let dy = -maxDistance; dy <= maxDistance; dy++) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    
                    if (x >= 0 && x < WORLD_SIZE && y >= 0 && y < WORLD_SIZE) {
                        const tile = world.tiles[x][y];
                        if (tile && tile.active) {
                            // Calculate distance from center
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            // Calculate influence based on distance
                            const influence = Math.pow(1 - Math.min(distance / maxDistance, 1), falloffPower);
                            
                            // Calculate the height change for this tile
                            const tileHeightChange = desiredHeightChange * influence;
                            heightChanges.set(`${x},${y}`, {
                                tile: tile,
                                change: tileHeightChange,
                                influence: influence
                            });
                        }
                    }
                }
            }
            
            // Apply height changes with smoothing
            heightChanges.forEach((data, key) => {
                const {tile, change, influence} = data;
                
                // Apply the height change with a dampening factor for smoother terrain
                const dampening = 0.7; // Reduce the rate of change for smoother results
                const newHeight = tile.height + (change * dampening);
                
                // Clamp and apply the new height
                tile.height = Math.max(minHeight, Math.min(maxHeight, newHeight));
                
                // Check if this tile should become lava
                if (tile.height <= lavaThreshold || tile.height >= peakThreshold) {
                    tile.isLava = true;
                    // Deactivate temples of the kingdom that owns this tile
                    if (tile.owner !== null) {
                        // Find all temples belonging to this kingdom
                        game.temples.forEach(temple => {
                            if (temple.kingdomId === tile.owner) {
                                temple.active = false;
                            }
                        });
                        console.log(`Lava created in kingdom ${tile.owner}'s territory - deactivating their temples`);
                    }
                    
                    // Destroy any building on this tile
                    if (tile.hasBuilding) {
                        // Check if it's a village - remove it entirely
                        const villageIndex = world.villages.findIndex(v => v.x === x && v.y === y);
                        if (villageIndex !== -1) {
                            world.villages.splice(villageIndex, 1);
                            console.log(`Village completely destroyed by terraform lava at ${x}, ${y}`);
                        }
                        
                        // Check if it's a capital - remove it entirely
                        const capitalIndex = world.capitals.findIndex(c => c.x === x && c.y === y);
                        if (capitalIndex !== -1) {
                            const capital = world.capitals[capitalIndex];
                            world.capitals.splice(capitalIndex, 1);
                            
                            // Also remove from kingdom's controlled capitals
                            const kingdom = world.kingdoms.find(k => k.id === tile.owner);
                            if (kingdom) {
                                const controlIndex = kingdom.controlledCapitals.findIndex(c => c.x === x && c.y === y);
                                if (controlIndex !== -1) {
                                    kingdom.controlledCapitals.splice(controlIndex, 1);
                                    
                                    // Destroy temple requests from this capital
                                    kingdom.templeRequests = kingdom.templeRequests.filter(request => {
                                        if (request.capital && request.capital.x === x && request.capital.y === y) {
                                            console.log(`Temple request destroyed from lava-destroyed capital at ${x}, ${y}`);
                                            return false;
                                        }
                                        return true;
                                    });
                                    
                                    // Check if kingdom has no capitals left
                                    if (kingdom.controlledCapitals.length === 0) {
                                        kingdom.alive = false;
                                        kingdom.deathTick = game.currentTick;
                                        console.log(`Kingdom ${kingdom.name} destroyed - no capitals remaining after lava destruction`);
                                        
                                        // Immediately clear tile ownership
                                        for (let clearX = 0; clearX < WORLD_SIZE; clearX++) {
                                            for (let clearY = 0; clearY < WORLD_SIZE; clearY++) {
                                                if (world.tiles[clearX][clearY].owner === kingdom.id) {
                                                    world.tiles[clearX][clearY].owner = null;
                                                    markTileDirty(world.id, clearX, clearY);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            console.log(`Capital completely destroyed by terraform lava at ${x}, ${y}`);
                        }
                        
                        // Check if it's a temple - remove it entirely
                        const templeIndex = game.temples.findIndex(t => t.x === x && t.y === y && t.worldId === world.id);
                        if (templeIndex !== -1) {
                            game.temples.splice(templeIndex, 1);
                            // Update max power
                            game.maxPower = Math.max(10, game.maxPower - 10);
                            updatePowerDisplay();
                            console.log(`Temple completely destroyed by terraform lava at ${x}, ${y}`);
                        }
                        
                        tile.hasBuilding = false;
                        tile.buildingType = null;
                    }
                    
                    // Destroy any armies on this tile
                    worlds.forEach(checkWorld => {
                        checkWorld.kingdoms.forEach(kingdom => {
                            if (kingdom.alive) {
                                kingdom.armies.forEach(army => {
                                    if (army.alive && army.worldId === world.id) {
                                        const pos = army.getPosition();
                                        const armyX = Math.floor(pos.x);
                                        const armyY = Math.floor(pos.y);
                                        if (armyX === x && armyY === y) {
                                            army.alive = false;
                                            army.troops = 0;
                                            console.log(`Army destroyed by terraform lava at ${x}, ${y}`);
                                        }
                                    }
                                });
                            }
                        });
                    });
                    
                    // Destroy any recruits on this tile
                    if (world.recruits) {
                        world.recruits.forEach(recruit => {
                            if (recruit.alive) {
                                const pos = recruit.getPosition();
                                const recruitX = Math.floor(pos.x);
                                const recruitY = Math.floor(pos.y);
                                if (recruitX === x && recruitY === y) {
                                    recruit.alive = false;
                                    recruit.size = 0;
                                    console.log(`Recruit group destroyed by terraform lava at ${x}, ${y}`);
                                }
                            }
                        });
                    }
                }
                
                // Update tile's elevation offset
                const tileElevationOffset = (tile.height - 0.65) * 240;
                tile.renderY = tile.isoY - tileElevationOffset;
            });
            
            // Add terraform effect
            game.divineEffects.push(new TerraformEffect(world.id, centerX, centerY));
        }
        
        function applySculptChanges(world, tileX, tileY, mode) {
            const tile = world.tiles[tileX][tileY];
            if (!tile) return;
            
            if (mode === 'add') {
                // Activate inactive tiles
                if (!tile.active) {
                    tile.active = true;
                    
                    // Give the new tile reasonable height based on neighbors
                    let totalHeight = 0;
                    let activeNeighbors = 0;
                    const neighbors = getNeighborsWithCache(tileX, tileY, world.id);
                    
                    neighbors.forEach(pos => {
                        const neighbor = world.tiles[pos.x][pos.y];
                        if (neighbor && neighbor.active) {
                            totalHeight += neighbor.height;
                            activeNeighbors++;
                        }
                    });
                    
                    // Set height to average of neighbors or default
                    if (activeNeighbors > 0) {
                        tile.height = totalHeight / activeNeighbors;
                    } else {
                        tile.height = 0.5; // Default height
                    }
                    
                    // Update tile's elevation offset
                    const tileElevationOffset = (tile.height - 0.65) * 240;
                    tile.renderY = tile.isoY - tileElevationOffset;
                    
                    // Update spatial index for the newly active tile
                    updateTileSpatialIndex(world, tileX, tileY);
                    
                    // Mark tile and neighbors as dirty
                    markTileDirty(world.id, tileX, tileY);
                    neighbors.forEach(pos => markTileDirty(world.id, pos.x, pos.y));
                }
            } else if (mode === 'remove') {
                // Deactivate active tiles
                if (tile.active) {
                    // Check if tile has important things on it
                    if (tile.owner !== null) {
                        // Remove ownership
                        const kingdom = world.kingdoms.find(k => k.id === tile.owner);
                        if (kingdom && kingdom.alive) {
                            // Update kingdom borders
                            updateBordersAroundTile(world, tileX, tileY, tile.owner, null);
                        }
                        tile.owner = null;
                    }
                    
                    // Remove any buildings
                    if (tile.hasBuilding) {
                        tile.hasBuilding = false;
                        tile.buildingType = null;
                        
                        // Remove from world buildings array
                        world.buildings = world.buildings.filter(b => 
                            !(b.x === tileX && b.y === tileY)
                        );
                    }
                    
                    // Deactivate the tile
                    tile.active = false;
                    tile.height = 0;
                    tile.renderY = tile.isoY;
                    
                    // Update spatial index
                    removeTileFromSpatialIndex(world, tileX, tileY);
                    
                    // Mark tile and neighbors as dirty
                    markTileDirty(world.id, tileX, tileY);
                    const neighbors = getNeighborsWithCache(tileX, tileY, world.id);
                    neighbors.forEach(pos => markTileDirty(world.id, pos.x, pos.y));
                    
                    // Check if we orphaned any kingdom tiles
                    checkForOrphanedTiles(world, tileX, tileY);
                }
            }
            
            // Add sculpt effect
            const effectX = tile.isoX;
            const effectY = tile.active ? tile.renderY : tile.isoY;
            game.divineEffects.push(new SculptEffect(
                effectX, 
                effectY, 
                mode === 'add' ? '#4682b4' : '#ff6347'
            ));
        }
        
        function updateTileSpatialIndex(world, x, y) {
            // Update territory grid for spatial queries
            const gridX = Math.floor(x / 10);
            const gridY = Math.floor(y / 10);
            const gridKey = `${gridX},${gridY}`;
            
            if (!spatialIndex.territoryGrids.has(world.id)) {
                spatialIndex.territoryGrids.set(world.id, new Map());
            }
            
            const worldGrid = spatialIndex.territoryGrids.get(world.id);
            if (!worldGrid.has(gridKey)) {
                worldGrid.set(gridKey, new Set());
            }
        }
        
        function removeTileFromSpatialIndex(world, x, y) {
            const gridX = Math.floor(x / 10);
            const gridY = Math.floor(y / 10);
            const gridKey = `${gridX},${gridY}`;
            
            const worldGrid = spatialIndex.territoryGrids.get(world.id);
            if (worldGrid && worldGrid.has(gridKey)) {
                const gridCell = worldGrid.get(gridKey);
                // Remove any kingdom associations for this tile
                const tile = world.tiles[x][y];
                if (tile.owner !== null) {
                    gridCell.delete(tile.owner);
                }
            }
        }
        
        function checkForOrphanedTiles(world, removedX, removedY) {
            // Check if removing this tile orphaned any kingdom territories
            const neighbors = getNeighborsWithCache(removedX, removedY, world.id);
            const checkedTiles = new Set();
            
            neighbors.forEach(pos => {
                const neighborTile = world.tiles[pos.x][pos.y];
                if (neighborTile && neighborTile.active && neighborTile.owner !== null) {
                    // Check if this tile is still connected to its capital
                    const kingdom = world.kingdoms.find(k => k.id === neighborTile.owner);
                    if (kingdom && kingdom.alive) {
                        const isConnected = isConnectedToCapital(world, pos.x, pos.y, kingdom);
                        if (!isConnected) {
                            // Orphaned tile - remove ownership
                            updateBordersAroundTile(world, pos.x, pos.y, neighborTile.owner, null);
                            neighborTile.owner = null;
                            markTileDirty(world.id, pos.x, pos.y);
                        }
                    }
                }
            });
        }
        
        function isConnectedToCapital(world, x, y, kingdom) {
            // BFS to check if tile is connected to any capital
            const visited = new Set();
            const queue = [{x, y}];
            visited.add(`${x},${y}`);
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Check if we reached a capital
                if (kingdom.controlledCapitals.some(cap => cap.x === current.x && cap.y === current.y)) {
                    return true;
                }
                
                // Check neighbors
                const neighbors = getNeighborsWithCache(current.x, current.y, world.id);
                neighbors.forEach(pos => {
                    const key = `${pos.x},${pos.y}`;
                    if (!visited.has(key)) {
                        const tile = world.tiles[pos.x][pos.y];
                        if (tile && tile.active && tile.owner === kingdom.id) {
                            visited.add(key);
                            queue.push(pos);
                        }
                    }
                });
            }
            
            return false;
        }
        
        function createDivineKingdom(world, x, y) {
            // Consume power
            game.power -= game.abilities.kingdom.cost;
            
            // Generate unique kingdom ID
            const newKingdomId = world.kingdoms.length;
            const name = generateKingdomName();
            const color = generateKingdomColor();
            
            // Create the new kingdom
            const newKingdom = new Kingdom(newKingdomId, name, color, x, y, world.id);
            newKingdom.troops = 30; // Give divine kingdoms more starting troops
            newKingdom.controlledCapitals = [{ x: x, y: y }];
            newKingdom.isDivine = true; // Mark as divinely created
            
            // Add kingdom to world
            world.kingdoms.push(newKingdom);
            world.capitals.push({ x: x, y: y });
            
            // Expand initial territory (bigger than normal kingdoms)
            const initialTiles = 8 + Math.floor(Math.random() * 5); // 8-12 tiles
            expandKingdomTerritory(world, newKingdom, initialTiles);
            
            // Create visual effects
            const iso = worldToIsometric(x, y);
            game.divineEffects.push(new KingdomCreationEffect(x, y, world.id, color));
            
            // Create divine light beam
            game.divineEffects.push(new GoldenGodRay(x, y, world.id));
            
            updatePowerDisplay();
        }
        
        function createDivinePortal(tile1, tile2) {
            // Consume power
            game.power -= game.abilities.portal.cost;
            
            // Create the portal with 100-year duration (60000 ticks)
            const portal = {
                id: game.portals.length,
                worldA: tile1.worldId,
                worldB: tile2.worldId,
                tileA: { x: tile1.x, y: tile1.y },
                tileB: { x: tile2.x, y: tile2.y },
                ownerId: null, // Divine portal has no owner
                isDivine: true, // Mark as divine portal
                expiresTick: game.currentTick + 60000, // 100 years
                active: true
            };
            
            game.portals.push(portal);
            
            // Create visual effects at both ends
            const world1 = worlds[tile1.worldId];
            const world2 = worlds[tile2.worldId];
            
            // Add portal creation effects
            const iso1 = worldToIsometric(tile1.x, tile1.y);
            const iso2 = worldToIsometric(tile2.x, tile2.y);
            
            // Create divine light effects at both portal locations
            game.divineEffects.push(new PortalCreationEffect(tile1.x, tile1.y, tile1.worldId));
            game.divineEffects.push(new PortalCreationEffect(tile2.x, tile2.y, tile2.worldId));
            
            // Check for request completion
            const world = game.worlds[tile1.worldId];
            if (world) {
                checkRequestCompletion('portal', { tile1, tile2 }, world);
            }
            
            updatePowerDisplay();
        }

        
        // Divine ability implementations
        function useSmite(world, centerX, centerY) {
            // Deduct power
            game.power -= game.abilities.smite.cost;
            updatePowerDisplay();
            
            // Find all armies within dynamic radius
            const radius = game.abilities.smite.radius;
            const smitten = [];
            const hitTargets = []; // Track what was hit for request completion
            
            // Check for capitals and villages within radius
            const burnDuration = 3000; // 5 years (600 ticks per year)
            
            // Check all capitals in this world
            world.capitals.forEach(capital => {
                const distance = Math.abs(capital.x - centerX) + Math.abs(capital.y - centerY);
                if (distance <= radius) {
                    // Check if the capital's owner is blessed
                    const tile = world.tiles[capital.x][capital.y];
                    if (tile.owner !== null) {
                        const isBlessed = game.blessedKingdoms[tile.owner] && 
                                        game.blessedKingdoms[tile.owner] > game.currentTick;
                        
                        if (!isBlessed) {
                            // Burn the capital
                            const key = capital.x + ',' + capital.y + ',' + world.id;
                            game.burnedCapitals[key] = game.currentTick + burnDuration;
                            
                            // Track hit for request completion
                            hitTargets.push({ type: 'capital', kingdomId: tile.owner });
                            
                            // Create burn effect
                            const iso = worldToIsometric(capital.x, capital.y);
                            game.divineEffects.push(new StructureBurnEffect(iso.x, iso.y, world.id, 'capital'));
                            
                            // Add lightning strike to capital
                            game.divineEffects.push(new LightningStrike(iso.x, iso.y, world.id, false));
                        }
                    }
                }
            });
            
            // Check all villages in this world
            if (world.villages) {
                world.villages.forEach(village => {
                    const distance = Math.abs(village.x - centerX) + Math.abs(village.y - centerY);
                    if (distance <= radius) {
                        // Check if the village's owner is blessed
                        const tile = world.tiles[village.x][village.y];
                        if (tile.owner !== null) {
                            const isBlessed = game.blessedKingdoms[tile.owner] && 
                                            game.blessedKingdoms[tile.owner] > game.currentTick;
                            
                            if (!isBlessed) {
                                // Burn the village
                                const key = village.x + ',' + village.y + ',' + world.id;
                                game.burnedVillages[key] = game.currentTick + burnDuration;
                                
                                // Track hit for request completion
                                hitTargets.push({ type: 'village', kingdomId: tile.owner });
                                
                                // Create burn effect
                                const iso = worldToIsometric(village.x, village.y);
                                game.divineEffects.push(new StructureBurnEffect(iso.x, iso.y, world.id, 'village'));
                                
                                // Add lightning strike to village
                                game.divineEffects.push(new LightningStrike(iso.x, iso.y, world.id, false));
                            }
                        }
                    }
                });
            }
            
            // Check for witch and spire
            if (world.name === 'Terra' && game.terraWitch.active && game.terraWitch.hasHouse) {
                const witchDist = Math.abs(game.terraWitch.x - centerX) + Math.abs(game.terraWitch.y - centerY);
                const spireDist = Math.abs(game.terraWitch.houseX - centerX) + Math.abs(game.terraWitch.houseY - centerY);
                
                if (witchDist <= radius || spireDist <= radius) {
                    // Kill the witch
                    game.terraWitch.active = false;
                    game.terraWitch.deathTime = game.currentTick;
                    game.terraWitch.phase = 'waiting';
                    game.terraWitch.waitTimer = 0;
                    game.terraWitch.hasHouse = false;
                    game.terraWitch.bones = [];
                    game.terraWitch.bonesDuringDarkPeriod = 0;
                    game.terraWitch.hasCreatedPortal = false;
                    
                    // Create death effect at witch position
                    const witchIso = worldToIsometric(game.terraWitch.x, game.terraWitch.y);
                    game.divineEffects.push(new LightningStrike(witchIso.x, witchIso.y, world.id, false));
                    game.divineEffects.push(new BurnedBody(witchIso.x, witchIso.y, world.id, 1, 'witch', false));
                    
                    // Destroy spire/house
                    if (spireDist <= radius) {
                        // Remove from buildings array
                        world.buildings = world.buildings.filter(b => 
                            !(b.type === 'witch_house' && 
                              b.x === Math.floor(game.terraWitch.houseX) && 
                              b.y === Math.floor(game.terraWitch.houseY))
                        );
                        
                        // Clear tile
                        const tileX = Math.floor(game.terraWitch.houseX);
                        const tileY = Math.floor(game.terraWitch.houseY);
                        if (tileX >= 0 && tileX < WORLD_SIZE && tileY >= 0 && tileY < WORLD_SIZE) {
                            world.tiles[tileX][tileY].hasBuilding = false;
                            world.tiles[tileX][tileY].buildingType = null;
                            markTileDirty(world.id, tileX, tileY);
                        }
                        
                        // Create destruction effect at spire
                        const spireIso = worldToIsometric(game.terraWitch.houseX, game.terraWitch.houseY);
                        game.divineEffects.push(new StructureBurnEffect(spireIso.x, spireIso.y, world.id, 'witch_house'));
                    }
                }
            }
            
            // Check for witches in other worlds
            for (const worldId in game.worldWitches) {
                if (world.id === worldId) {
                    const witch = game.worldWitches[worldId];
                    if (witch && witch.active && witch.hasHouse) {
                        const witchDist = Math.abs(witch.x - centerX) + Math.abs(witch.y - centerY);
                        const spireDist = Math.abs(witch.houseX - centerX) + Math.abs(witch.houseY - centerY);
                        
                        if (witchDist <= radius || spireDist <= radius) {
                            // Remove witch from this world
                            delete game.worldWitches[worldId];
                            
                            // Create death effect at witch position
                            const witchIso = worldToIsometric(witch.x, witch.y);
                            game.divineEffects.push(new LightningStrike(witchIso.x, witchIso.y, world.id, false));
                            game.divineEffects.push(new BurnedBody(witchIso.x, witchIso.y, world.id, 1, 'witch', false));
                            
                            // Destroy spire/house
                            if (spireDist <= radius) {
                                // Remove from buildings array
                                world.buildings = world.buildings.filter(b => 
                                    !(b.type === 'witch_house' && 
                                      b.x === Math.floor(witch.houseX) && 
                                      b.y === Math.floor(witch.houseY))
                                );
                                
                                // Clear tile
                                const tileX = Math.floor(witch.houseX);
                                const tileY = Math.floor(witch.houseY);
                                if (tileX >= 0 && tileX < WORLD_SIZE && tileY >= 0 && tileY < WORLD_SIZE) {
                                    world.tiles[tileX][tileY].hasBuilding = false;
                                    world.tiles[tileX][tileY].buildingType = null;
                                    markTileDirty(world.id, tileX, tileY);
                                }
                                
                                // Create destruction effect at spire
                                const spireIso = worldToIsometric(witch.houseX, witch.houseY);
                                game.divineEffects.push(new StructureBurnEffect(spireIso.x, spireIso.y, world.id, 'witch_house'));
                            }
                        }
                    }
                }
            }
            
            // Check all kingdoms' armies in this world
            const allKingdoms = [];
            
            // Add native kingdoms
            world.kingdoms.forEach(k => {
                if (k.alive) allKingdoms.push(k);
            });
            
            // Add foreign kingdoms with armies in this world
            for (let w = 0; w < worlds.length; w++) {
                if (w !== world.id) {
                    worlds[w].kingdoms.forEach(k => {
                        if (k.alive && k.armies.some(a => a.alive && a.worldId === world.id)) {
                            allKingdoms.push(k);
                        }
                    });
                }
            }
            
            // Check each kingdom's armies
            allKingdoms.forEach(kingdom => {
                // Skip if kingdom is blessed
                if (game.blessedKingdoms[kingdom.id] && game.blessedKingdoms[kingdom.id] > game.currentTick) {
                    return;
                }
                
                kingdom.armies.forEach(army => {
                    if (army.alive && army.worldId === world.id) {
                        const pos = army.getPosition();
                        const distance = Math.abs(pos.x - centerX) + Math.abs(pos.y - centerY);
                        
                        if (distance <= radius) {
                            // Smite this army!
                            army.alive = false;
                            army.cleanupOnDeath(world);
                            smitten.push({x: pos.x, y: pos.y});
                            
                            // Track hit for request completion
                            hitTargets.push({ type: 'army', kingdomId: kingdom.id });
                            
                            // Create burned bodies at the army position (7 soldiers in an army)
                            const isoPos = worldToIsometric(pos.x, pos.y);
                            game.divineEffects.push(new BurnedBody(isoPos.x, isoPos.y, world.id, 7, 'army', army.hasBanner));
                            
                            // Clean up army references
                            if (army.targetTileKey) {
                                delete kingdom.targetedTiles[army.targetTileKey];
                            }
                        }
                    }
                });
            });
            
            // Check recruit groups
            if (world.recruits) {
                world.recruits = world.recruits.filter(recruit => {
                    if (recruit.alive) {
                        const pos = recruit.getPosition();
                        const distance = Math.abs(pos.x - centerX) + Math.abs(pos.y - centerY);
                        
                        if (distance <= radius) {
                            // Check if the recruit's kingdom is blessed
                            const isBlessed = game.blessedKingdoms[recruit.kingdom.id] && 
                                            game.blessedKingdoms[recruit.kingdom.id] > game.currentTick;
                            
                            if (!isBlessed) {
                                // Smite this recruit group!
                                recruit.alive = false;
                                smitten.push({x: pos.x, y: pos.y});
                                
                                // Create burned bodies (5 workers in a recruit group)
                                const isoPos = worldToIsometric(pos.x, pos.y);
                                game.divineEffects.push(new BurnedBody(isoPos.x, isoPos.y, world.id, 5, 'recruit', false));
                                
                                return false; // Remove from array
                            }
                        }
                    }
                    return recruit.alive; // Keep in array if alive
                });
            }
            
            // Check for temples within radius
            const templesToDestroy = [];
            game.temples.forEach(temple => {
                if (temple.worldId === world.id) {
                    const distance = Math.abs(temple.x - centerX) + Math.abs(temple.y - centerY);
                    if (distance <= radius) {
                        templesToDestroy.push(temple);
                        smitten.push({x: temple.x, y: temple.y});
                    }
                }
            });
            
            // Destroy temples
            templesToDestroy.forEach(temple => {
                // Remove from game temples
                const index = game.temples.indexOf(temple);
                if (index > -1) {
                    game.temples.splice(index, 1);
                }
                
                // Remove from kingdom temples
                const kingdom = findKingdomById(temple.kingdomId);
                if (kingdom && kingdom.temples) {
                    const kingdomIndex = kingdom.temples.indexOf(temple);
                    if (kingdomIndex > -1) {
                        kingdom.temples.splice(kingdomIndex, 1);
                    }
                }
                
                // Clear the tile's building status
                const tile = world.tiles[temple.x][temple.y];
                if (tile) {
                    tile.hasBuilding = false;
                    tile.buildingType = null;
                }
                
                // Reduce max power
                game.maxPower = Math.max(10, game.maxPower - 10);
                
                // Create destruction effect
                const templeIso = worldToIsometric(temple.x, temple.y);
                for (let i = 0; i < 15; i++) {
                    game.divineEffects.push(new TempleDestructionParticle(
                        templeIso.x + (Math.random() - 0.5) * 30,
                        templeIso.y + (Math.random() - 0.5) * 30,
                        world.id
                    ));
                }
            });
            
            // Create lightning effects for center and each smitten army
            const centerIso = worldToIsometric(centerX, centerY);
            game.divineEffects.push(new LightningStrike(centerIso.x, centerIso.y, world.id, true));
            
            smitten.forEach(pos => {
                const iso = worldToIsometric(pos.x, pos.y);
                game.divineEffects.push(new LightningStrike(iso.x, iso.y, world.id, false));
            });
            
            // Add screen flash effect
            game.divineEffects.push(new ScreenFlash('white', 0.5));
            
            // Update power display if temples were destroyed
            if (templesToDestroy.length > 0) {
                updatePowerDisplay();
            }
            
            // Check for request completion with hit targets
            console.log('Calling checkRequestCompletion with hitTargets:', hitTargets);
            checkRequestCompletion('smite', { x: centerX, y: centerY, hitTargets }, world);
            
            // Deactivate temples of kingdoms that were hit
            const hitKingdomIds = new Set();
            hitTargets.forEach(target => {
                if (target.kingdomId) {
                    hitKingdomIds.add(target.kingdomId);
                }
            });
            
            // Deactivate temples belonging to hit kingdoms
            game.temples.forEach(temple => {
                if (hitKingdomIds.has(temple.kingdomId)) {
                    temple.active = false;
                }
            });
            
            return hitTargets;
        }
        
        function getBlessingCost(kingdomId) {
            // Find the kingdom
            let kingdom = null;
            for (let w = 0; w < worlds.length; w++) {
                kingdom = worlds[w].kingdoms.find(k => k.id === kingdomId && k.alive);
                if (kingdom) break;
            }
            
            if (!kingdom) return 20; // Default cost if kingdom not found
            
            // Cost is number of villages × 5
            const villageCount = kingdom.villages.length;
            return villageCount * 5;
        }
        
        function useBless(kingdomId) {
            // Calculate and deduct power based on kingdom tiles
            const cost = getBlessingCost(kingdomId);
            game.power -= cost;
            updatePowerDisplay();
            
            // Set blessing duration (5 years = 3000 ticks)
            game.blessedKingdoms[kingdomId] = game.currentTick + 3000;
            
            // Find the kingdom
            let kingdom = null;
            for (let w = 0; w < worlds.length; w++) {
                kingdom = worlds[w].kingdoms.find(k => k.id === kingdomId && k.alive);
                if (kingdom) break;
            }
            
            if (kingdom) {
                // Clear lava and normalize extreme elevations in kingdom territory
                worlds.forEach(world => {
                    for (let x = 0; x < WORLD_SIZE; x++) {
                        for (let y = 0; y < WORLD_SIZE; y++) {
                            const tile = world.tiles[x][y];
                            if (tile.owner === kingdomId && tile.active) {
                                // Clear lava
                                if (tile.isLava) {
                                    tile.isLava = false;
                                    markTileDirty(world.id, x, y);
                                }
                                
                                // Normalize extreme elevations
                                const lavaThreshold = 0.15;
                                const peakThreshold = 1.45;
                                if (tile.height <= lavaThreshold || tile.height >= peakThreshold) {
                                    // Move elevation toward normal range
                                    if (tile.height <= lavaThreshold) {
                                        tile.height = 0.4; // Set to low but safe elevation
                                    } else if (tile.height >= peakThreshold) {
                                        tile.height = 1.0; // Set to high but safe elevation
                                    }
                                    
                                    // Update tile's elevation offset
                                    const tileElevationOffset = (tile.height - 0.65) * 240;
                                    tile.renderY = tile.isoY - tileElevationOffset;
                                    markTileDirty(world.id, x, y);
                                }
                            }
                        }
                    }
                });
                
                // Reactivate temples for this kingdom
                game.temples.forEach(temple => {
                    if (temple.kingdomId === kingdomId) {
                        temple.active = true;
                    }
                });
                
                // Create blessing effect at kingdom's capital
                const world = worlds[kingdom.worldId];
                const capitalIso = worldToIsometric(kingdom.capitalX, kingdom.capitalY);
                game.divineEffects.push(new BlessingEffect(capitalIso.x, capitalIso.y, kingdom.worldId));
                
                // Create blessing effects at all controlled capitals
                kingdom.controlledCapitals.forEach(capital => {
                    // Check if this capital is in the kingdom's world
                    if (world.tiles[capital.x] && world.tiles[capital.x][capital.y] && 
                        world.tiles[capital.x][capital.y].owner === kingdom.id) {
                        const capIso = worldToIsometric(capital.x, capital.y);
                        game.divineEffects.push(new BlessingEffect(capIso.x, capIso.y, kingdom.worldId));
                    }
                });
                
                // Add god rays for blessed kingdom's capitals in ANY world
                // Find the Lux world
                let luxWorld = null;
                for (let w = 0; w < worlds.length; w++) {
                    if (worlds[w].name === 'Lux') {
                        luxWorld = worlds[w];
                        break;
                    }
                }
                
                if (luxWorld && luxWorld.effect) {
                    // Store blessed kingdom ID for special beam effects
                    luxWorld.effect.blessedKingdomId = kingdomId;
                    luxWorld.effect.blessingStartTick = game.currentTick;
                    luxWorld.effect.blessedKingdomWorldId = kingdom.worldId; // Remember which world the kingdom is in
                }
                
                // Add a golden glow effect
                game.divineEffects.push(new ScreenFlash('gold', 0.3));
            }
        }
        
        // Particle effect classes
        function LightningStrike(x, y, worldId, isMain) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.duration = isMain ? 60 : 30;
            this.currentTick = 0;
            this.isMain = isMain;
            this.bolts = this.generateBolts();
        }
        
        LightningStrike.prototype.generateBolts = function() {
            const bolts = [];
            const boltCount = this.isMain ? 5 : 3;
            
            for (let i = 0; i < boltCount; i++) {
                const segments = [];
                let currentX = 0;
                let currentY = this.isMain ? -200 : -100;
                
                // Generate lightning path
                while (currentY < 0) {
                    segments.push({x: currentX, y: currentY});
                    currentX += (Math.random() - 0.5) * 30;
                    currentY += 20 + Math.random() * 20;
                }
                segments.push({x: currentX * 0.7, y: 0}); // End at ground
                
                bolts.push({
                    segments: segments,
                    delay: Math.random() * 10
                });
            }
            
            return bolts;
        };
        
        LightningStrike.prototype.update = function() {
            this.currentTick++;
            return this.currentTick < this.duration;
        };
        
        function BlessingEffect(x, y, worldId) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.duration = 90;
            this.currentTick = 0;
            this.particles = this.generateParticles();
        }
        
        BlessingEffect.prototype.generateParticles = function() {
            const particles = [];
            for (let i = 0; i < 20; i++) {
                particles.push({
                    angle: (Math.PI * 2 * i) / 20,
                    radius: 0,
                    speed: 1 + Math.random() * 2,
                    size: 2 + Math.random() * 3,
                    delay: Math.random() * 20
                });
            }
            return particles;
        };
        
        BlessingEffect.prototype.update = function() {
            this.currentTick++;
            this.particles.forEach(p => {
                if (this.currentTick > p.delay) {
                    p.radius += p.speed;
                }
            });
            return this.currentTick < this.duration;
        };
        
        function BurnedBody(x, y, worldId, count, unitType, hasBanner) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.duration = 600; // 20 seconds to fade out
            this.currentTick = 0;
            this.count = count || 1; // Number of bodies to render
            this.unitType = unitType || 'army'; // 'army' or 'recruit'
            this.hasBanner = hasBanner || false; // Whether the army had a banner
            
            // Generate positions based on unit type
            this.bodies = [];
            
            if (this.unitType === 'army') {
                // Army formation: 2 rows, 3-4 soldiers per row
                const spacing = 6;
                let index = 0;
                for (let row = 1; row >= 0; row--) {
                    const soldiersInRow = row === 0 ? 3 : 4;
                    const startX = -(soldiersInRow - 1) * spacing / 2;
                    const rowY = -row * 8;
                    
                    for (let i = 0; i < soldiersInRow && index < this.count; i++) {
                        this.bodies.push({
                            offsetX: startX + i * spacing,
                            offsetY: rowY + (i % 2) * 2,
                            rotation: (Math.random() - 0.5) * 0.5, // Slight rotation
                            scale: 1
                        });
                        index++;
                    }
                }
            } else {
                // Recruit formation: circular pattern
                const positions = [ 
                    {dx: 0, dy: 0}, 
                    {dx: -8, dy: -4}, 
                    {dx: 8, dy: -4}, 
                    {dx: -4, dy: 5}, 
                    {dx: 4, dy: 5} 
                ];
                for (let i = 0; i < this.count && i < positions.length; i++) {
                    this.bodies.push({
                        offsetX: positions[i].dx,
                        offsetY: positions[i].dy,
                        rotation: (Math.random() - 0.5) * 0.5,
                        scale: 1
                    });
                }
            }
        }
        
        BurnedBody.prototype.update = function() {
            this.currentTick++;
            return this.currentTick < this.duration;
        };
        
        function ScreenFlash(color, intensity) {
            this.color = color;
            this.intensity = intensity;
            this.duration = 20;
            this.currentTick = 0;
        }
        
        ScreenFlash.prototype.update = function() {
            this.currentTick++;
            return this.currentTick < this.duration;
        };
        
        function SweatParticle(x, y) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 4; // Increased horizontal velocity
            this.vy = -Math.random() * 3 - 2; // Stronger upward velocity
            this.size = 4 + Math.random() * 4; // Much larger particles
            this.life = 30 + Math.random() * 20; // Longer life
            this.maxLife = this.life;
            this.gravity = 0.4;
            this.wobble = Math.random() * Math.PI * 2; // For wobble effect
        }
        
        SweatParticle.prototype.update = function() {
            // Add wobble effect
            this.wobble += 0.2;
            this.x += this.vx + Math.sin(this.wobble) * 0.5;
            this.y += this.vy;
            this.vy += this.gravity; // Apply gravity
            this.vx *= 0.98; // Slight horizontal drag
            this.life--;
            return this.life > 0;
        };
        
        function ArmyDeathSmoke(x, y, worldId) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.duration = 60;
            this.currentTick = 0;
            this.particles = [];
            
            // Create initial burst of smoke particles
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 / 20) * i + Math.random() * 0.2;
                const speed = 1 + Math.random() * 2;
                this.particles.push({
                    x: 0,
                    y: 0,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,
                    size: 8 + Math.random() * 6,
                    life: 40 + Math.random() * 20,
                    maxLife: 60
                });
            }
        }
        
        ArmyDeathSmoke.prototype.update = function() {
            this.currentTick++;
            
            // Update particles
            this.particles = this.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.vy -= 0.05; // Slight upward drift
                particle.life--;
                return particle.life > 0;
            });
            
            // Add new particles for first 20 ticks
            if (this.currentTick < 20 && this.currentTick % 2 === 0) {
                for (let i = 0; i < 3; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.5 + Math.random();
                    this.particles.push({
                        x: (Math.random() - 0.5) * 10,
                        y: (Math.random() - 0.5) * 10,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 0.5,
                        size: 6 + Math.random() * 4,
                        life: 30 + Math.random() * 10,
                        maxLife: 40
                    });
                }
            }
            
            return this.currentTick < this.duration || this.particles.length > 0;
        };
        
        function StructureBurnEffect(x, y, worldId, structureType) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.structureType = structureType; // 'capital' or 'village'
            this.duration = 90;
            this.currentTick = 0;
            this.flames = this.generateFlames();
        }
        
        function FishParticle(x, y, worldId, fish) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.duration = 60; // 2 seconds
            this.currentTick = 0;
            
            // Create trailing particles behind the fish
            const angle = Math.atan2(fish.y - fish.lastY || 0, fish.x - fish.lastX || 0);
            const spread = (Math.random() - 0.5) * 0.5;
            
            // Particles move away from fish's direction
            this.vx = -Math.cos(angle + spread) * (0.5 + Math.random() * 0.5);
            this.vy = -Math.sin(angle + spread) * (0.5 + Math.random() * 0.5);
            
            this.size = 1 + Math.random() * 2;
            this.maxSize = this.size * 2;
            this.opacity = 0;
            this.rotationSpeed = (Math.random() - 0.5) * 0.1;
            this.rotation = Math.random() * Math.PI * 2;
            this.type = Math.random() < 0.7 ? 'sparkle' : 'ring';
        }
        
        // Witch Dark Power Particle for house building
        function WitchDarkPowerParticle(x, y, worldId, witch) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.duration = 60;
            this.currentTick = 0;
            
            // Particles spiral upward
            this.angle = Math.random() * Math.PI * 2;
            this.radius = 0;
            this.radiusSpeed = 0.5;
            this.angleSpeed = 0.1;
            this.verticalSpeed = -2; // Rise up
            this.height = 0;
            
            this.size = 3 + Math.random() * 2;
            this.opacity = 0;
            this.color = Math.random() < 0.5 ? '#8B00FF' : '#4B0082'; // Purple/indigo
        }
        
        WitchDarkPowerParticle.prototype.update = function() {
            this.currentTick++;
            
            // Spiral outward and upward
            this.angle += this.angleSpeed;
            this.radius += this.radiusSpeed;
            this.height += this.verticalSpeed;
            
            // Fade in and out
            const progress = this.currentTick / this.duration;
            if (progress < 0.2) {
                this.opacity = progress * 5;
            } else if (progress > 0.7) {
                this.opacity = (1 - progress) * 3.33;
            } else {
                this.opacity = 1;
            }
            
            return this.currentTick < this.duration;
        };
        
        // Dark Power Consume Particle for army consumption
        function DarkPowerConsumeParticle(x, y, worldId, angle, speed) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.duration = 45;
            this.currentTick = 0;
            
            // Burst outward
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            
            this.size = 4 + Math.random() * 3;
            this.opacity = 1;
            this.color = '#8B00FF';
            this.flameLike = Math.random() < 0.5;
        }
        
        DarkPowerConsumeParticle.prototype.update = function() {
            this.currentTick++;
            
            // Move outward with decay
            const decay = 0.95;
            this.vx *= decay;
            this.vy *= decay;
            this.x += this.vx;
            this.y += this.vy;
            
            // Shrink and fade
            const progress = this.currentTick / this.duration;
            this.size *= 0.97;
            this.opacity = 1 - progress;
            
            return this.currentTick < this.duration;
        };
        
        // Red God Ray effect for war declaration
        function RedGodRay(x, y, worldId, duration) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.duration = duration;
            this.currentTick = 0;
            this.beamWidth = 80; // Doubled width
            this.particles = [];
            
            // Generate initial particles
            for (let i = 0; i < 10; i++) {
                this.particles.push({
                    offsetX: (Math.random() - 0.5) * this.beamWidth,
                    height: -Math.random() * 400, // Increased height range
                    speed: 1 + Math.random() * 2,
                    size: 3 + Math.random() * 4,
                    opacity: 0.5 + Math.random() * 0.5
                });
            }
        }
        
        RedGodRay.prototype.update = function() {
            this.currentTick++;
            
            // Update particles
            this.particles.forEach(particle => {
                particle.height -= particle.speed;
                if (particle.height < -500) { // Increased height limit
                    particle.height = 0;
                    particle.offsetX = (Math.random() - 0.5) * this.beamWidth;
                    particle.speed = 1 + Math.random() * 2;
                }
            });
            
            // Add new particles occasionally
            if (this.currentTick % 5 === 0) {
                this.particles.push({
                    offsetX: (Math.random() - 0.5) * this.beamWidth,
                    height: 0,
                    speed: 1 + Math.random() * 2,
                    size: 3 + Math.random() * 4,
                    opacity: 0.5 + Math.random() * 0.5
                });
                
                // Remove old particles if too many
                if (this.particles.length > 20) {
                    this.particles.shift();
                }
            }
            
            return this.currentTick < this.duration;
        };
        
        // Golden God Ray effect for peace declaration
        function GoldenGodRay(x, y, worldId, duration) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.duration = duration;
            this.currentTick = 0;
            this.beamWidth = 100; // Doubled width
            this.particles = [];
            
            // Generate initial particles
            for (let i = 0; i < 15; i++) {
                this.particles.push({
                    offsetX: (Math.random() - 0.5) * this.beamWidth,
                    height: -Math.random() * 400, // Increased height range
                    speed: 0.5 + Math.random() * 1.5,
                    size: 4 + Math.random() * 6,
                    opacity: 0.7 + Math.random() * 0.3,
                    shimmer: Math.random() * Math.PI * 2
                });
            }
        }
        
        GoldenGodRay.prototype.update = function() {
            this.currentTick++;
            
            // Update particles
            this.particles.forEach(particle => {
                particle.height -= particle.speed;
                particle.shimmer += 0.1;
                if (particle.height < -500) { // Increased height limit
                    particle.height = 0;
                    particle.offsetX = (Math.random() - 0.5) * this.beamWidth;
                    particle.speed = 0.5 + Math.random() * 1.5;
                    particle.shimmer = Math.random() * Math.PI * 2;
                }
            });
            
            // Add new particles occasionally
            if (this.currentTick % 4 === 0) {
                this.particles.push({
                    offsetX: (Math.random() - 0.5) * this.beamWidth,
                    height: 0,
                    speed: 0.5 + Math.random() * 1.5,
                    size: 4 + Math.random() * 6,
                    opacity: 0.7 + Math.random() * 0.3,
                    shimmer: 0
                });
                
                // Remove old particles if too many
                if (this.particles.length > 25) {
                    this.particles.shift();
                }
            }
            
            return this.currentTick < this.duration;
        };
        
        // Terraform effect
        function TerraformEffect(worldId, x, y) {
            this.worldId = worldId;
            this.x = x;
            this.y = y;
            this.duration = 60; // 1 second
            this.currentTick = 0;
            this.ripples = [];
            
            // Generate ripples
            for (let i = 0; i < 3; i++) {
                this.ripples.push({
                    radius: 0,
                    maxRadius: 30 + i * 15,
                    opacity: 0.8 - i * 0.2,
                    speed: 1 + i * 0.5
                });
            }
        }
        
        TerraformEffect.prototype.update = function() {
            this.currentTick++;
            
            // Update ripples
            this.ripples.forEach(ripple => {
                ripple.radius = Math.min(ripple.radius + ripple.speed, ripple.maxRadius);
                ripple.opacity *= 0.95;
            });
            
            return this.currentTick < this.duration;
        };
        
        function SculptEffect(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.duration = 40; // Shorter than terraform
            this.currentTick = 0;
            this.particles = [];
            
            // Generate particles
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8;
                this.particles.push({
                    x: 0,
                    y: 0,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2 - 1, // Slight upward bias
                    size: 4 + Math.random() * 3,
                    opacity: 1
                });
            }
        }
        
        SculptEffect.prototype.update = function() {
            this.currentTick++;
            
            // Update particles
            this.particles.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.1; // Gravity
                particle.opacity = 1 - (this.currentTick / this.duration);
                particle.size *= 0.98;
            });
            
            return this.currentTick < this.duration;
        };
        
        // Kingdom creation effect
        function KingdomCreationEffect(x, y, worldId, kingdomColor) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.kingdomColor = kingdomColor;
            this.duration = 90; // 1.5 seconds
            this.currentTick = 0;
            this.crownSize = 0;
            this.maxCrownSize = 30;
            this.particles = [];
            
            // Generate crown particles
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                this.particles.push({
                    angle: angle,
                    distance: 0,
                    targetDistance: 20 + Math.random() * 30,
                    y: 0,
                    targetY: -10 - Math.random() * 40,
                    size: 2 + Math.random() * 3,
                    opacity: 1,
                    color: Math.random() > 0.5 ? '#ffd700' : kingdomColor
                });
            }
        }
        
        KingdomCreationEffect.prototype.update = function() {
            this.currentTick++;
            
            // Expand crown
            const progress = Math.min(this.currentTick / 30, 1); // First 0.5 seconds
            this.crownSize = this.maxCrownSize * progress;
            
            // Update particles
            this.particles.forEach(particle => {
                particle.distance += (particle.targetDistance - particle.distance) * 0.1;
                particle.y += (particle.targetY - particle.y) * 0.1;
                particle.opacity = Math.max(0, 1 - (this.currentTick / this.duration));
            });
            
            return this.currentTick < this.duration;
        };
        
        // Portal creation effect
        function PortalCreationEffect(x, y, worldId) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.duration = 60; // 1 second
            this.currentTick = 0;
            this.radius = 0;
            this.maxRadius = 40;
            this.particles = [];
            
            // Generate initial particles
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                this.particles.push({
                    angle: angle,
                    distance: 0,
                    speed: 1 + Math.random() * 2,
                    size: 2 + Math.random() * 3,
                    opacity: 0.8
                });
            }
        }
        
        PortalCreationEffect.prototype.update = function() {
            this.currentTick++;
            
            // Expand radius
            const progress = this.currentTick / this.duration;
            this.radius = this.maxRadius * progress;
            
            // Update particles
            this.particles.forEach(particle => {
                particle.distance += particle.speed;
                particle.opacity = 0.8 * (1 - progress);
                
                // Spiral motion
                particle.angle += 0.1;
            });
            
            return this.currentTick < this.duration;
        };
        
        // Request bubble click effect
        function RequestBubbleClickEffect(x, y, worldId) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.life = 30;
            this.maxLife = 30;
            this.ripples = [];
            
            // Create multiple expanding ripples
            for (let i = 0; i < 3; i++) {
                this.ripples.push({
                    radius: i * 10,
                    maxRadius: 50 + i * 15,
                    delay: i * 5
                });
            }
            
            // Create sparkle particles
            this.sparkles = [];
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                this.sparkles.push({
                    x: Math.cos(angle) * 20,
                    y: Math.sin(angle) * 20,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    size: 3 + Math.random() * 2,
                    life: 20 + Math.random() * 10
                });
            }
        }
        
        RequestBubbleClickEffect.prototype.update = function() {
            this.life--;
            
            // Update ripples
            this.ripples.forEach(ripple => {
                if (ripple.delay > 0) {
                    ripple.delay--;
                } else {
                    ripple.radius += 3;
                }
            });
            
            // Update sparkles
            this.sparkles = this.sparkles.filter(sparkle => {
                sparkle.x += sparkle.vx;
                sparkle.y += sparkle.vy;
                sparkle.vy += 0.2; // gravity
                sparkle.life--;
                sparkle.size *= 0.95;
                return sparkle.life > 0;
            });
            
            return this.life > 0;
        };
        
        FishParticle.prototype.update = function() {
            this.currentTick++;
            
            // Move particle with slight drift
            this.x += this.vx * 0.3;
            this.y += this.vy * 0.3;
            
            // Add slight upward drift for magical effect
            this.vy -= 0.01;
            
            // Slow down over time
            this.vx *= 0.98;
            this.vy *= 0.98;
            
            // Update rotation
            this.rotation += this.rotationSpeed;
            
            // Fade in then out
            const progress = this.currentTick / this.duration;
            if (progress < 0.2) {
                this.opacity = progress * 5 * 0.4; // Fade in to 0.4
            } else {
                this.opacity = 0.4 * (1 - (progress - 0.2) / 0.8); // Fade out
            }
            
            // Pulse size
            this.currentSize = this.size + Math.sin(this.currentTick * 0.1) * 0.5;
            
            return this.currentTick < this.duration;
        };
        
        function KingdomDefeatEffect(x, y, worldId, kingdomColor, kingdomName) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.kingdomColor = kingdomColor;
            this.kingdomName = kingdomName;
            this.duration = 120; // 4 seconds
            this.currentTick = 0;
            this.debris = this.generateDebris();
            this.flagFallProgress = 0;
            this.towerCollapseProgress = 0;
        }
        
        KingdomDefeatEffect.prototype.generateDebris = function() {
            const debris = [];
            for (let i = 0; i < 15; i++) {
                debris.push({
                    x: (Math.random() - 0.5) * 40,
                    y: -20 - Math.random() * 30,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -Math.random() * 3 - 2,
                    size: 3 + Math.random() * 5,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    color: Math.random() > 0.5 ? '#9C8A7A' : '#6B5537'
                });
            }
            return debris;
        };
        
        KingdomDefeatEffect.prototype.update = function() {
            this.currentTick++;
            
            // Update flag fall progress
            if (this.currentTick > 10) {
                this.flagFallProgress = Math.min(1, (this.currentTick - 10) / 40);
            }
            
            // Update tower collapse progress
            if (this.currentTick > 30) {
                this.towerCollapseProgress = Math.min(1, (this.currentTick - 30) / 60);
            }
            
            // Update debris physics
            this.debris.forEach(d => {
                d.x += d.vx;
                d.y += d.vy;
                d.vy += 0.3; // Gravity
                d.rotation += d.rotationSpeed;
            });
            
            return this.currentTick < this.duration;
        };
        
        function VictoryEffect(x, y, worldId, kingdomColor, kingdomName) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.kingdomColor = kingdomColor;
            this.kingdomName = kingdomName;
            this.duration = 90; // 3 seconds
            this.currentTick = 0;
            this.particles = this.generateParticles();
            this.bannerRaiseProgress = 0;
        }
        
        VictoryEffect.prototype.generateParticles = function() {
            const particles = [];
            // Create confetti-like celebration particles
            for (let i = 0; i < 30; i++) {
                particles.push({
                    x: (Math.random() - 0.5) * 60,
                    y: -40 - Math.random() * 20,
                    vx: (Math.random() - 0.5) * 1.5,
                    vy: -Math.random() * 2 - 1,
                    size: 2 + Math.random() * 3,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.3,
                    color: Math.random() > 0.5 ? this.kingdomColor : '#FFD700',
                    delay: Math.random() * 30
                });
            }
            return particles;
        };
        
        VictoryEffect.prototype.update = function() {
            this.currentTick++;
            
            // Update banner raise progress
            this.bannerRaiseProgress = Math.min(1, this.currentTick / 45);
            
            // Update particle physics
            this.particles.forEach(p => {
                if (this.currentTick > p.delay) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.15; // Gentle gravity
                    p.rotation += p.rotationSpeed;
                    p.vx *= 0.98; // Air resistance
                }
            });
            
            return this.currentTick < this.duration;
        };
        
        StructureBurnEffect.prototype.generateFlames = function() {
            const flames = [];
            const count = this.structureType === 'capital' ? 8 : 5;
            
            for (let i = 0; i < count; i++) {
                flames.push({
                    offsetX: (Math.random() - 0.5) * 30,
                    offsetY: (Math.random() - 0.5) * 20 - 10,
                    size: 5 + Math.random() * 10,
                    speed: 0.5 + Math.random() * 0.5,
                    phase: Math.random() * Math.PI * 2
                });
            }
            return flames;
        };
        
        StructureBurnEffect.prototype.update = function() {
            this.currentTick++;
            return this.currentTick < this.duration;
        };
        
        // World Effect Classes - Unique atmospheric effects for each world
        function WorldEffect(worldId) {
            this.worldId = worldId;
            this.centerX = WORLD_SIZE / 2; // Center of the world in tile coordinates
            this.centerY = WORLD_SIZE / 2;
            this.radius = WORLD_SIZE * 0.8; // Large radius covering most of the world
        }
        
        // Ignis (Fire) - Floating ember particles
        function IgnisEffect(worldId) {
            WorldEffect.call(this, worldId);
            this.embers = [];
            for (let i = 0; i < 80; i++) {  // More embers for larger coverage
                this.embers.push({
                    x: (Math.random() - 0.5) * this.radius * 128,  // Doubled from 64 to 128
                    y: (Math.random() - 0.5) * this.radius * 128,  // Doubled from 64 to 128
                    z: Math.random() * 300,  // Higher flight
                    speed: 0.5 + Math.random() * 0.8,
                    size: 4 + Math.random() * 8,  // Bigger embers
                    phase: Math.random() * Math.PI * 2,
                    brightness: 0.5 + Math.random() * 0.5
                });
            }
            
            // Shadow armies that repeat fallen armies' routes
            this.shadowArmies = [];
            this.maxShadowArmies = 5;
            this.armyDeathCount = 0;
            this.pendingRoutes = []; // Routes waiting to spawn shadows
        }
        
        // Add shadow update method for Ignis
        IgnisEffect.prototype.updateShadows = function(world, currentTick) {
            // Spawn new shadow armies from pending routes (10 seconds after death)
            if (this.pendingRoutes.length > 0 && this.shadowArmies.length < this.maxShadowArmies) {
                const readyRoutes = this.pendingRoutes.filter(r => currentTick - r.deathTick >= 300); // 10 seconds
                
                if (readyRoutes.length > 0) {
                    const routeData = readyRoutes[0];
                    const route = routeData.route;
                    
                    if (route.length > 0) {
                        // Calculate middle 50% of route
                        const routeStart = Math.floor(route.length * 0.25);
                        const routeEnd = Math.floor(route.length * 0.75);
                        const middleRoute = route.slice(routeStart, routeEnd);
                        
                        if (middleRoute.length >= 2) { // Only process if route is long enough
                            // Create a shadow army with 7 shadow soldiers
                            const shadowArmy = {
                                route: middleRoute,
                                routeIndex: 0,
                                moveProgress: 0,
                                speed: 0.04, // Increased to match visual speed of armies
                                lifetime: Math.ceil(middleRoute.length * 70 / 3) + 120, // Adjusted for 3x speed, time to complete route + fade
                                currentLife: 0,
                                fadeIn: 0
                            };
                            
                            this.shadowArmies.push(shadowArmy);
                            
                            // Remove this route from pending
                            this.pendingRoutes = this.pendingRoutes.filter(r => r !== routeData);
                        }
                    }
                }
            }
            
            // Update existing shadow armies
            this.shadowArmies = this.shadowArmies.filter(army => {
                army.currentLife++;
                
                // Fade in/out
                if (army.currentLife < 30) {
                    army.fadeIn = army.currentLife / 30;
                } else if (army.currentLife > army.lifetime - 60) {
                    army.fadeIn = (army.lifetime - army.currentLife) / 60;
                } else {
                    army.fadeIn = 1;
                }
                
                // Move along route
                if (army.routeIndex < army.route.length - 1) {
                    army.moveProgress += army.speed;
                    
                    if (army.moveProgress >= 1) {
                        army.moveProgress = 0;
                        army.routeIndex++;
                        
                        // Check if reached end of route
                        if (army.routeIndex >= army.route.length - 1) {
                            // Start fading out
                            army.lifetime = army.currentLife + 60;
                        }
                    }
                }
                
                return army.currentLife < army.lifetime;
            });
        };
        
        // Aqua (Water) - Rippling water waves
        function AquaEffect(worldId) {
            WorldEffect.call(this, worldId);
            this.ripples = [];
            // Add some splash points for more dynamic water
            for (let i = 0; i < 10; i++) {
                this.ripples.push({
                    x: (Math.random() - 0.5) * this.radius * 50,
                    y: (Math.random() - 0.5) * this.radius * 50,
                    phase: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random() * 0.5
                });
            }
            
            // Rain drops
            this.rainDrops = [];
            for (let i = 0; i < 150; i++) {
                this.rainDrops.push({
                    x: (Math.random() - 0.5) * this.radius * 100,
                    y: (Math.random() - 0.5) * this.radius * 60 - 400 - Math.random() * 200,
                    speed: 3 + Math.random() * 2,
                    length: 10 + Math.random() * 15,
                    opacity: 0.3 + Math.random() * 0.4
                });
            }
            
            // Pretty bubbles
            this.bubbles = [];
            for (let i = 0; i < 30; i++) {
                this.bubbles.push({
                    x: (Math.random() - 0.5) * this.radius * 80,
                    y: (Math.random() - 0.5) * this.radius * 60 + Math.random() * 100,
                    baseY: (Math.random() - 0.5) * this.radius * 60,
                    size: 5 + Math.random() * 15,
                    wobblePhase: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random() * 0.5,
                    shimmerPhase: Math.random() * Math.PI * 2
                });
            }
        }
        
        // Aether (Air/Sky) - Swirling wind currents
        function AetherEffect(worldId) {
            WorldEffect.call(this, worldId);
            this.windParticles = [];
            for (let i = 0; i < 50; i++) {  // More wind particles
                this.windParticles.push({
                    angle: Math.random() * Math.PI * 2,
                    radius: Math.random() * this.radius * 32,  // Scale to world size
                    speed: 0.5 + Math.random() * 0.8,
                    size: 3 + Math.random() * 6,  // Bigger wind streaks
                    opacity: 0.1 + Math.random() * 0.2
                });
            }
            
            // Floating air particles
            this.airParticles = [];
            for (let i = 0; i < 200; i++) {  // Many small particles
                this.airParticles.push({
                    x: (Math.random() - 0.5) * this.radius * 100,
                    y: (Math.random() - 0.5) * this.radius * 80,
                    z: Math.random() * 200,  // Height variation
                    vx: (Math.random() - 0.5) * 0.5,  // Horizontal drift
                    vy: -0.2 - Math.random() * 0.3,  // Upward movement
                    size: 1 + Math.random() * 3,
                    opacity: 0.2 + Math.random() * 0.4,
                    twinkle: Math.random() * Math.PI * 2
                });
            }
        }
        
        // Terra (Earth) - Floating crystal shards
        function TerraEffect(worldId) {
            WorldEffect.call(this, worldId);
            this.crystals = [];
            for (let i = 0; i < 15; i++) {  // More crystals
                const angle = (i / 15) * Math.PI * 2;
                this.crystals.push({
                    baseAngle: angle,
                    orbitRadius: 1000 + Math.random() * 500,  // Very far out, 1000-1500 pixels
                    height: 50 + Math.random() * 100,  // Higher floating
                    size: 30 + Math.random() * 40,  // Bigger crystals
                    color: Math.random() > 0.5 ? '#00FF00' : '#50FF50', // Bright shiny greens
                    shinePhase: Math.random() * Math.PI * 2
                });
            }
            
            // Global particle trail array
            this.crystalParticles = [];
            
            // Earth particles removed
        }
        
        // Lux (Light) - Vertical god rays from above
        function LuxEffect(worldId) {
            WorldEffect.call(this, worldId);
            this.beams = [];
            this.beamCooldown = 0; // Cooldown between beam appearances
            this.maxActiveBeams = 7; // Maximum active beams at once
            this.capitalTargets = []; // Will be populated with capital positions
            this.beamAngleOffsetX = 17; // Reduced left offset (was 25)
            this.beamAngleOffsetY = 10; // Less offset in Y direction
            
            // Initialize with no beams - they'll appear over capitals dynamically
            // Start with cooldown so first beam appears after a moment
            this.beamCooldown = 60; // 1 second delay before first beam
            
            // Start with empty particle array - particles will be spawned inside beams
            this.dustParticles = [];
            this.maxParticles = 200; // Maximum particles allowed
            
            // Light sprites for blessing effect
            this.lightSprites = [];
            this.spritesPerBeam = 1; // Exactly 1 sprite per god ray
        }
        
        // Add update method for Lux effect
        LuxEffect.prototype.updateBeams = function(world, currentTick) {
            // Update cooldown
            if (this.beamCooldown > 0) {
                this.beamCooldown--;
            }
            
            // Check if we need to create blessing beams
            if (this.blessedKingdomId && game.blessedKingdoms[this.blessedKingdomId] > currentTick) {
                // Find the blessed kingdom
                let blessedKingdom = null;
                for (let w = 0; w < worlds.length; w++) {
                    blessedKingdom = worlds[w].kingdoms.find(k => k.id === this.blessedKingdomId);
                    if (blessedKingdom) break;
                }
                
                if (blessedKingdom) {
                    // Get the world where the blessed kingdom is located
                    const blessedWorld = worlds[this.blessedKingdomWorldId || blessedKingdom.worldId];
                    
                    if (blessedWorld) {
                        // Create beams for all capitals if they don't exist
                        const capitalPositions = [];
                        
                        // Main capital
                        capitalPositions.push({
                            x: blessedKingdom.capitalX,
                            y: blessedKingdom.capitalY
                        });
                        
                        // Controlled capitals
                        blessedKingdom.controlledCapitals.forEach(capital => {
                            capitalPositions.push({
                                x: capital.x,
                                y: capital.y
                            });
                        });
                        
                        // Create beams for capitals that don't have one
                        capitalPositions.forEach(capitalPos => {
                            // Check if beam already exists for this capital
                            const beamExists = this.beams.some(beam => 
                                beam.tileX === capitalPos.x && beam.tileY === capitalPos.y && 
                                beam.isBlessing && beam.blessedWorldId === blessedWorld.id
                            );
                            
                            if (!beamExists && this.beams.length < this.maxActiveBeams + capitalPositions.length) {
                                // Use the blessed kingdom's world for tile data
                                const tile = blessedWorld.tiles[capitalPos.x][capitalPos.y];
                                const iso = worldToIsometric(capitalPos.x, capitalPos.y);
                                const elevationOffset = (tile.height - 0.65) * 240;
                                
                                const newBeam = {
                                    x: iso.x,
                                    targetX: iso.x,
                                    targetY: iso.y - elevationOffset,
                                    tileX: capitalPos.x,
                                    tileY: capitalPos.y,
                                    tileHeight: tile.height,
                                    width: 180, // Wider for blessing
                                    targetOpacity: 0.12, // Brighter for blessing
                                    currentOpacity: 0,
                                    phase: 0,
                                    swayAmount: 0,
                                    swaySpeed: 0,
                                    fadingIn: true,
                                    fadingOut: false,
                                    activeTime: 0,
                                    isBlessing: true, // Mark as blessing beam
                                    blessedWorldId: blessedWorld.id // Track which world this beam is for
                                };
                                this.beams.push(newBeam);
                                
                                // Spawn light sprites for this blessing beam (only in Lux world)
                                if (world.name === 'Lux') {
                                    const spritesToSpawn = 1; // Exactly 1 sprite per beam
                                    for (let i = 0; i < spritesToSpawn; i++) {
                                        const angle = (Math.PI * 2 / spritesToSpawn) * i;
                                        const distance = 150 + Math.random() * 100; // Random distance from capital
                                        
                                        this.lightSprites.push({
                                            beam: newBeam,
                                            capitalX: iso.x,
                                            capitalY: iso.y - elevationOffset,
                                            targetX: iso.x + Math.cos(angle) * distance,
                                            targetY: iso.y - elevationOffset + Math.sin(angle) * distance * 0.5, // Less Y movement for isometric
                                            currentX: iso.x + Math.cos(angle) * (distance + 200), // Start farther away
                                            currentY: iso.y - elevationOffset + Math.sin(angle) * (distance + 200) * 0.5,
                                            opacity: 0,
                                            scale: 0.8 + Math.random() * 0.4,
                                            fadeIn: true,
                                            fadeOut: false,
                                            armAngle: 0, // Will animate to raised position
                                            targetArmAngle: Math.PI * 0.3 + Math.random() * Math.PI * 0.2, // Varying arm angles
                                            moveProgress: 0,
                                            atTarget: false,
                                            worldId: world.id // Use Lux world's ID, not the blessed world's ID
                                        });
                                    }
                                }
                            }
                        });
                    }
                }
            } else {
                // Clear blessed kingdom ID if blessing expired
                this.blessedKingdomId = null;
            }
            
            // Spawn particles inside active beams
            if (this.beams.length > 0 && this.dustParticles.length < this.maxParticles) {
                // Spawn 2-4 particles per frame when beams are active
                const particlesToSpawn = 2 + Math.floor(Math.random() * 3);
                
                for (let i = 0; i < particlesToSpawn && this.dustParticles.length < this.maxParticles; i++) {
                    // Pick a random active beam
                    const beam = this.beams[Math.floor(Math.random() * this.beams.length)];
                    
                    // Generate random height
                    const heightRatio = Math.random(); // 0 = bottom, 1 = top
                    const z = heightRatio * 400;
                    
                    // Calculate beam position at this height using tile-based angle
                    const topTileX = beam.tileX - this.beamAngleOffsetX;
                    const topTileY = beam.tileY - this.beamAngleOffsetY;
                    const tileLerpX = beam.tileX + (topTileX - beam.tileX) * heightRatio;
                    const tileLerpY = beam.tileY + (topTileY - beam.tileY) * heightRatio;
                    
                    // Convert to isometric
                    const lerpIso = worldToIsometric(tileLerpX, tileLerpY);
                    const beamXAtHeight = lerpIso.x;
                    
                    // Uniform beam width
                    const beamWidth = beam.width;
                    
                    // Random position within beam width
                    const xOffset = (Math.random() - 0.5) * beamWidth * 0.8; // 0.8 to keep away from edges
                    
                    // Calculate Y position based on height
                    const yPosition = beam.targetY - (heightRatio * 1000); // Spread along beam height
                    
                    this.dustParticles.push({
                        x: beamXAtHeight + xOffset,
                        y: yPosition,
                        z: z,
                        vx: (Math.random() - 0.5) * 0.2, // Gentle drift
                        vy: (Math.random() - 0.5) * 0.2,
                        vz: -0.5 - Math.random() * 0.5, // Falling speed
                        size: 1 + Math.random() * 2,
                        brightness: 0.5 + Math.random() * 0.5,
                        twinkle: Math.random() * Math.PI * 2,
                        inBeam: true,
                        sourceBeam: beam // Track which beam spawned this particle
                    });
                }
            }
            
            // Update existing beams
            for (let i = this.beams.length - 1; i >= 0; i--) {
                const beam = this.beams[i];
                
                // Update fade animation (5x slower)
                if (beam.fadingIn) {
                    beam.currentOpacity = Math.min(beam.currentOpacity + 0.002, beam.targetOpacity); // Was 0.01
                    if (beam.currentOpacity >= beam.targetOpacity) {
                        beam.fadingIn = false;
                        beam.activeTime = 0;
                    }
                } else if (beam.fadingOut) {
                    beam.currentOpacity = Math.max(beam.currentOpacity - 0.001, 0); // Was 0.005
                    if (beam.currentOpacity <= 0) {
                        this.beams.splice(i, 1);
                        continue;
                    }
                } else {
                    // Active beam
                    beam.activeTime++;
                    
                    // Blessing beams last as long as the blessing
                    if (beam.isBlessing) {
                        // Check if blessing is still active
                        if (!this.blessedKingdomId || !game.blessedKingdoms[this.blessedKingdomId] || 
                            game.blessedKingdoms[this.blessedKingdomId] <= currentTick) {
                            beam.fadingOut = true;
                        }
                    } else if (beam.activeTime > 300) { // Regular beams: 5 seconds at 60fps
                        beam.fadingOut = true;
                    }
                }
            }
            
            // Update light sprites
            for (let i = this.lightSprites.length - 1; i >= 0; i--) {
                const sprite = this.lightSprites[i];
                
                // Check if the associated beam still exists
                if (!this.beams.includes(sprite.beam)) {
                    // Beam is gone, start fading out
                    sprite.fadeOut = true;
                    sprite.fadeIn = false;
                }
                
                // Update movement
                if (!sprite.atTarget && !sprite.fadeOut) {
                    sprite.moveProgress = Math.min(sprite.moveProgress + 0.02, 1);
                    sprite.currentX = sprite.currentX + (sprite.targetX - sprite.currentX) * 0.05;
                    sprite.currentY = sprite.currentY + (sprite.targetY - sprite.currentY) * 0.05;
                    
                    const distToTarget = Math.sqrt(
                        Math.pow(sprite.currentX - sprite.targetX, 2) + 
                        Math.pow(sprite.currentY - sprite.targetY, 2)
                    );
                    
                    if (distToTarget < 5) {
                        sprite.atTarget = true;
                    }
                }
                
                // Update arm angle when at target
                if (sprite.atTarget && sprite.armAngle < sprite.targetArmAngle) {
                    sprite.armAngle = Math.min(sprite.armAngle + 0.05, sprite.targetArmAngle);
                }
                
                // Back away when fading out
                if (sprite.fadeOut) {
                    const awayAngle = Math.atan2(
                        sprite.currentY - sprite.capitalY,
                        sprite.currentX - sprite.capitalX
                    );
                    sprite.currentX += Math.cos(awayAngle) * 2;
                    sprite.currentY += Math.sin(awayAngle) * 1;
                }
                
                // Update opacity
                if (sprite.fadeIn && !sprite.fadeOut) {
                    sprite.opacity = Math.min(sprite.opacity + 0.02, 0.8);
                } else if (sprite.fadeOut) {
                    sprite.opacity = Math.max(sprite.opacity - 0.01, 0);
                    if (sprite.opacity <= 0) {
                        this.lightSprites.splice(i, 1);
                    }
                }
            }
            
            // Spawn new beam if cooldown is done and we have room (don't count blessing beams)
            const regularBeamCount = this.beams.filter(b => !b.isBlessing).length;
            if (this.beamCooldown <= 0 && regularBeamCount < this.maxActiveBeams) {
                // Get all capitals with their world positions
                const allCapitals = [];
                world.capitals.forEach(capital => {
                    const tile = world.tiles[capital.x][capital.y];
                    const iso = worldToIsometric(capital.x, capital.y);
                    const elevationOffset = (tile.height - 0.65) * 240;
                    allCapitals.push({
                        x: capital.x,
                        y: capital.y,
                        isoX: iso.x,
                        isoY: iso.y - elevationOffset, // Account for terrain height
                        tileHeight: tile.height
                    });
                });
                
                // Also check kingdoms for their capitals
                world.kingdoms.forEach(kingdom => {
                    if (kingdom.alive && kingdom.capitalX !== undefined) {
                        const tile = world.tiles[kingdom.capitalX][kingdom.capitalY];
                        const iso = worldToIsometric(kingdom.capitalX, kingdom.capitalY);
                        const elevationOffset = (tile.height - 0.65) * 240;
                        // Avoid duplicates
                        if (!allCapitals.some(c => c.x === kingdom.capitalX && c.y === kingdom.capitalY)) {
                            allCapitals.push({
                                x: kingdom.capitalX,
                                y: kingdom.capitalY,
                                isoX: iso.x,
                                isoY: iso.y - elevationOffset, // Account for terrain height
                                tileHeight: tile.height
                            });
                        }
                    }
                });
                
                if (allCapitals.length > 0) {
                    // Pick a random capital that doesn't have a beam
                    const availableCapitals = allCapitals.filter(capital => {
                        return !this.beams.some(beam => 
                            Math.abs(beam.targetX - capital.isoX) < 50 && 
                            Math.abs(beam.targetY - capital.isoY) < 50
                        );
                    });
                    
                    if (availableCapitals.length > 0) {
                        const target = availableCapitals[Math.floor(Math.random() * availableCapitals.length)];
                        
                        const newBeam = {
                            x: target.isoX,
                            targetX: target.isoX,
                            targetY: target.isoY,
                            tileX: target.x, // Store tile coordinates
                            tileY: target.y, // Store tile coordinates
                            tileHeight: target.tileHeight, // Store terrain height
                            width: 112 + Math.random() * 150, // 112-262 units wide (25% smaller)
                            targetOpacity: 0.075 + Math.random() * 0.045, // 0.075-0.12 (25% brighter minimum)
                            currentOpacity: 0,
                            phase: 0, // No phase offset
                            swayAmount: 0, // No swaying
                            swaySpeed: 0, // No swaying
                            fadingIn: true,
                            fadingOut: false,
                            activeTime: 0
                        };
                        this.beams.push(newBeam);
                        
                        // Spawn light sprites for this beam (only in Lux world)
                        if (world.name === 'Lux') {
                            const spritesToSpawn = 1; // Exactly 1 sprite per beam
                            for (let i = 0; i < spritesToSpawn; i++) {
                                const angle = (Math.PI * 2 / spritesToSpawn) * i;
                                const distance = 150 + Math.random() * 100; // Random distance from capital
                                
                                this.lightSprites.push({
                                    beam: newBeam,
                                    capitalX: target.isoX,
                                    capitalY: target.isoY,
                                    targetX: target.isoX + Math.cos(angle) * distance,
                                    targetY: target.isoY + Math.sin(angle) * distance * 0.5, // Less Y movement for isometric
                                    currentX: target.isoX + Math.cos(angle) * (distance + 200), // Start farther away
                                    currentY: target.isoY + Math.sin(angle) * (distance + 200) * 0.5,
                                    opacity: 0,
                                    scale: 0.8 + Math.random() * 0.4,
                                    fadeIn: true,
                                    fadeOut: false,
                                    armAngle: 0, // Will animate to raised position
                                    targetArmAngle: Math.PI * 0.3 + Math.random() * Math.PI * 0.2, // Varying arm angles
                                    moveProgress: 0,
                                    atTarget: false,
                                    worldId: world.id // Use the current Lux world's ID
                                });
                            }
                        }
                        
                        // Set cooldown (0.5-1.5 seconds) - faster spawn rate for more beams
                        this.beamCooldown = 30 + Math.floor(Math.random() * 60);
                    }
                }
            }
        };
        
        // Umbra (Shadow) - Drifting shadow wisps
        function UmbraEffect(worldId) {
            WorldEffect.call(this, worldId);
            
            // Irregularly positioned dark wisps within world radius
            this.wisps = [];
            const wispCount = 50; // Total number of wisps (was 64 in 8x8 grid)
            const maxRadius = this.radius * 30; // Maximum distance from center in pixels
            
            for (let i = 0; i < wispCount; i++) {
                // Use polar coordinates for random distribution within circle
                const angle = Math.random() * Math.PI * 2;
                // Square root for uniform distribution in circle (prevents clustering at center)
                const distance = Math.sqrt(Math.random()) * maxRadius;
                
                this.wisps.push({
                    baseX: Math.cos(angle) * distance,
                    baseY: Math.sin(angle) * distance,
                    x: 0,
                    y: 0,
                    driftPhase: Math.random() * Math.PI * 2,
                    size: 60 + Math.random() * 40,  // Larger centered wisps
                    phase: Math.random() * Math.PI * 2,
                    opacity: 0.2 + Math.random() * 0.2  // Stronger opacity
                });
            }
            
            // Ghosts that haunt the land
            this.ghosts = [];
            this.maxGhosts = 5;
            this.ghostSpawnCooldown = 0;
            
            // Orbiting purple clouds
            this.clouds = [];
            for (let i = 0; i < 8; i++) {
                this.clouds.push({
                    angle: (i / 8) * Math.PI * 2,
                    radius: this.radius * 50 + Math.random() * 200, // Far out at edges
                    size: 150 + Math.random() * 100,
                    speed: 0.02 + Math.random() * 0.02,
                    opacity: 0.3 + Math.random() * 0.2,
                    heightOffset: -200 - Math.random() * 100
                });
            }
        }
        
        // Add ghost update method
        UmbraEffect.prototype.updateGhosts = function(world, currentTick) {
            // Spawn new ghosts
            if (this.ghostSpawnCooldown <= 0 && this.ghosts.length < this.maxGhosts) {
                // Random spawn position within world bounds
                const spawnX = (Math.random() - 0.5) * WORLD_SIZE * 0.8;
                const spawnY = (Math.random() - 0.5) * WORLD_SIZE * 0.8;
                
                this.ghosts.push({
                    x: spawnX,
                    y: spawnY,
                    vx: 0,
                    vy: 0,
                    targetUnit: null,
                    lifetime: 300 + Math.random() * 300, // 10-20 seconds
                    currentLife: 0,
                    fadeIn: 0,
                    size: 15 + Math.random() * 10,
                    floatPhase: Math.random() * Math.PI * 2
                });
                
                this.ghostSpawnCooldown = 60 + Math.random() * 120; // 2-6 seconds between spawns
            } else {
                this.ghostSpawnCooldown--;
            }
            
            // Update existing ghosts
            this.ghosts = this.ghosts.filter(ghost => {
                ghost.currentLife++;
                
                // Fade in/out
                if (ghost.currentLife < 30) {
                    ghost.fadeIn = ghost.currentLife / 30;
                } else if (ghost.currentLife > ghost.lifetime - 30) {
                    ghost.fadeIn = (ghost.lifetime - ghost.currentLife) / 30;
                } else {
                    ghost.fadeIn = 1;
                }
                
                // Find nearby units to haunt
                let nearestUnit = null;
                let minDistance = 15; // Detection range in tiles
                
                // Use spatial indexing to find nearby entities efficiently
                const nearbyArmies = getNearbyEntities(ghost.x, ghost.y, 15, world.id, 'Army');
                const nearbyRecruits = getNearbyEntities(ghost.x, ghost.y, 15, world.id, 'RecruitGroup');
                
                // Check nearby armies
                nearbyArmies.forEach(army => {
                    if (army.alive) {
                        const pos = army.getPosition();
                        const dist = Math.sqrt(
                            Math.pow(pos.x - ghost.x, 2) + 
                            Math.pow(pos.y - ghost.y, 2)
                        );
                        if (dist < minDistance) {
                            minDistance = dist;
                            nearestUnit = { x: pos.x, y: pos.y, type: 'army' };
                        }
                    }
                });
                
                // Check nearby recruits
                nearbyRecruits.forEach(recruit => {
                    if (recruit.alive) {
                        const pos = recruit.getPosition();
                        const dist = Math.sqrt(
                            Math.pow(pos.x - ghost.x, 2) + 
                            Math.pow(pos.y - ghost.y, 2)
                        );
                        if (dist < minDistance) {
                            minDistance = dist;
                            nearestUnit = { x: pos.x, y: pos.y, type: 'recruit' };
                        }
                    }
                });
                
                ghost.targetUnit = nearestUnit;
                
                // Movement
                const ghostSpeed = 0.024; // 3x faster (was 0.008), slower than recruits (0.03)
                if (ghost.targetUnit) {
                    // Follow the unit
                    const dx = ghost.targetUnit.x - ghost.x;
                    const dy = ghost.targetUnit.y - ghost.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0.5) { // Don't overlap exactly
                        ghost.vx = (dx / distance) * ghostSpeed;
                        ghost.vy = (dy / distance) * ghostSpeed;
                    } else {
                        ghost.vx *= 0.9; // Slow down when close
                        ghost.vy *= 0.9;
                    }
                } else {
                    // Wander randomly
                    ghost.vx += (Math.random() - 0.5) * 0.001;
                    ghost.vy += (Math.random() - 0.5) * 0.001;
                    
                    // Limit speed
                    const speed = Math.sqrt(ghost.vx * ghost.vx + ghost.vy * ghost.vy);
                    if (speed > ghostSpeed) {
                        ghost.vx = (ghost.vx / speed) * ghostSpeed;
                        ghost.vy = (ghost.vy / speed) * ghostSpeed;
                    }
                }
                
                // Apply movement
                ghost.x += ghost.vx;
                ghost.y += ghost.vy;
                
                // Keep within world bounds
                const maxRange = WORLD_SIZE * 0.4;
                if (Math.abs(ghost.x) > maxRange) ghost.vx *= -1;
                if (Math.abs(ghost.y) > maxRange) ghost.vy *= -1;
                
                return ghost.currentLife < ghost.lifetime;
            });
        }
        
        // Vita (Life) - Tree of Life Emanation
        function VitaEffect(worldId, worldShape) {
            WorldEffect.call(this, worldId);
            this.worldShape = worldShape;
            
            // Central world tree projection
            this.worldTree = {
                scale: 1.0, // Start fully grown
                targetScale: 1.0,
                branches: [],
                maxBranches: 15 + Math.floor(Math.random() * 11), // Random 15-25 branches
                pulsePhase: 0,
                glowIntensity: 0.5
            };
            
            // Initialize main branches with improved natural distribution
            const spiralOffset = Math.random() * Math.PI; // Random starting angle for spiral
            const clusterCenters = [0.65, 0.75, 0.85]; // Natural clustering heights
            
            for (let i = 0; i < this.worldTree.maxBranches; i++) {
                // Spiral arrangement with some randomness
                const spiralAngle = spiralOffset + (i * 2.4) + (Math.random() - 0.5) * 0.8;
                const angle = spiralAngle % (Math.PI * 2);
                
                // Height with tendency to cluster at certain points
                const clusterIndex = Math.floor(Math.random() * clusterCenters.length);
                const clusterHeight = clusterCenters[clusterIndex];
                const heightVariance = (Math.random() - 0.5) * 0.15;
                const finalHeight = Math.min(0.95, Math.max(0.5, clusterHeight + heightVariance));
                
                // Length and thickness correlation
                const baseLengthFactor = 1.4 - finalHeight * 0.7;
                const randomLengthFactor = 0.8 + Math.random() * 0.4;
                const lengthVar = baseLengthFactor * randomLengthFactor;
                
                // Thickness proportional to length
                const baseThickness = lengthVar * 10;
                
                const branch = {
                    angle: angle,
                    subBranches: [],
                    leaves: [],
                    heightPosition: finalHeight,
                    lengthVariation: lengthVar,
                    angleVariation: (Math.random() - 0.5) * 0.4,
                    swayOffset: Math.random() * Math.PI * 2,
                    thickness: baseThickness + (Math.random() - 0.5) * 3,
                    curveVariation: (Math.random() - 0.5) * 15,
                    // More horizontal at bottom, more upward at top
                    branchAngle: -Math.PI/5 + finalHeight * Math.PI/6 + (Math.random() - 0.5) * Math.PI/16
                };
                
                // Add small branches along the main branch
                const smallBranchCount = 6 + Math.floor(Math.random() * 4 + lengthVar * 3); // 6-15 small branches
                const minDistance = 0.05; // Minimum 5% of branch length between small branches
                
                // Generate positions for small branches
                const positions = [];
                for (let sb = 0; sb < smallBranchCount; sb++) {
                    let validPosition = false;
                    let attempts = 0;
                    let position;
                    
                    while (!validPosition && attempts < 20) {
                        position = 0.2 + Math.random() * 0.7; // Keep small branches away from base and tip
                        validPosition = true;
                        
                        // Check minimum distance from other positions
                        for (const existingPos of positions) {
                            if (Math.abs(position - existingPos) < minDistance) {
                                validPosition = false;
                                break;
                            }
                        }
                        attempts++;
                    }
                    
                    if (validPosition) {
                        positions.push(position);
                    }
                }
                
                // Sort positions and create small branches
                positions.sort((a, b) => a - b);
                
                for (const position of positions) {
                    // Skip 50% of branches near the trunk
                    if (position < 0.4 && Math.random() < 0.5) {
                        continue; // Skip this branch
                    }
                    // More natural branching pattern
                    const baseAngle = Math.PI * 0.15; // Base angle from main branch
                    const angleVariation = Math.random() * Math.PI * 0.3; // Up to 54 degrees variation
                    
                    // Branches tend to grow more upward/outward, with some randomness
                    const upwardBias = -0.2 + position * 0.3; // More upward near tip
                    const side = Math.random() < 0.5 ? 1 : -1; // Random side instead of alternating
                    
                    // Vary angle based on position - wider angles near base, narrower near tip
                    const positionFactor = 1 - position * 0.5;
                    const smallBranchAngle = (baseAngle + angleVariation) * side * positionFactor + upwardBias;
                    
                    // Length varies with position - longer near base
                    const baseLengthFactor = 0.4 + (1 - position) * 0.3; // 40-70% at base, less at tip
                    const randomLength = 0.7 + Math.random() * 0.3; // 70-100% variation
                    const smallBranchLength = baseLengthFactor * randomLength;
                    
                    // Thickness also varies with position
                    const baseThickness = 6 - position * 3; // Thicker near base
                    
                    const smallBranch = {
                        position: position,
                        angle: smallBranchAngle,
                        length: smallBranchLength * lengthVar * 60, // Half of 120
                        thickness: baseThickness + Math.random() * 2 - 1, // Add variation
                        curvature: Math.random() * 0.3 - 0.15, // Slight random curve
                        leaves: []
                    };
                    
                    // Add leaves to small branch - always 1 leaf
                    const leafCount = 1; // Always 1 leaf per branch
                    
                    // Position leaves along branch - closer to tip for branches near trunk
                    for (let l = 0; l < leafCount; l++) {
                        // Branches near trunk have leaves further out
                        const minPosition = position < 0.5 ? 0.7 : 0.5;
                        const leafPosition = minPosition + Math.random() * (1 - minPosition);
                        
                        // Natural phyllotaxy (spiral arrangement)
                        const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~137.5 degrees
                        const leafIndex = l + position * 10; // Offset based on branch position
                        const spiralAngle = leafIndex * goldenAngle;
                        
                        // Add some randomness to the spiral
                        const angleOffset = (Math.random() - 0.5) * 0.5;
                        const leafAngle = spiralAngle + angleOffset;
                        
                        // Vary leaf size along branch - smaller near base, larger in middle, smaller at tip
                        const sizePosition = Math.sin(leafPosition * Math.PI) * 0.7 + 0.3;
                        const leafSize = 25 + sizePosition * 30 + Math.random() * 15; // Increased from 15-45 to 25-70
                        
                        // Natural color variations
                        const season = Math.sin(this.worldTree.pulsePhase * 0.1) * 0.5 + 0.5;
                        const baseGreen = 120 + season * 50;
                        const colorVariation = Math.random() * 0.3 - 0.15;
                        
                        smallBranch.leaves.push({
                            position: leafPosition,
                            angle: leafAngle,
                            distance: 0,
                            size: leafSize,
                            swayOffset: Math.random() * Math.PI * 2,
                            opacity: (0.6 + Math.random() * 0.3 - position * 0.2) * 0.75, // 25% more transparent
                            color: {
                                r: 152 + Math.random() * 40 - 20, // Base from #98D8C8
                                g: 216 + Math.random() * 30 - 15 + colorVariation * 20, // Base from #98D8C8
                                b: 200 + Math.random() * 40 - 20
                            }
                        });
                    }
                    
                    branch.subBranches.push(smallBranch);
                }
                
                // Add a small branch at the tip of the main branch
                const tipBranch = {
                    position: 0.95, // Near the very end
                    angle: (Math.random() - 0.5) * 0.8, // Slight variation from main branch direction
                    length: lengthVar * 40, // Half of 80
                    thickness: 4 + Math.random() * 2,
                    curvature: Math.random() * 0.2 - 0.1,
                    leaves: []
                };
                
                // Add leaves to tip branch
                const tipLeafCount = 1; // Always 1 leaf
                for (let l = 0; l < tipLeafCount; l++) {
                    const leafPosition = 0.4 + Math.random() * 0.6;
                    const goldenAngle = Math.PI * (3 - Math.sqrt(5));
                    const spiralAngle = l * goldenAngle + Math.random() * 0.5;
                    
                    tipBranch.leaves.push({
                        position: leafPosition,
                        angle: spiralAngle,
                        distance: 0,
                        size: 35 + Math.random() * 20, // Increased from 20-30 to 35-55
                        swayOffset: Math.random() * Math.PI * 2,
                        opacity: (0.7 + Math.random() * 0.2) * 0.75, // 25% more transparent
                        color: {
                            r: 152 + Math.random() * 40 - 20, // Base from #98D8C8
                            g: 216 + Math.random() * 30 - 15, // Base from #98D8C8
                            b: 200 + Math.random() * 40 - 20
                        }
                    });
                }
                
                branch.subBranches.push(tipBranch);
                
                this.worldTree.branches.push(branch);
            }
            
            // Branch fractals system
            this.fractalDepth = 3;
            this.fractalGrowthSpeed = 0.005;
            
            // Emanation rings
            this.emanationRings = [];
            this.ringSpawnTimer = 0;
            
            // Leaf particle system
            this.leafParticles = [];
            this.leafSpawnTimer = 0;
            this.windDirection = 0; // Wind angle in radians
            this.windStrength = 2; // Base wind strength
            this.windPhase = 0; // For wind variation
            
            // Glow particles around tree
            this.glowParticles = [];
            this.glowParticleSpawnTimer = 0;
            this.maxGlowParticles = 30;
            
            // Walking leaves system
            this.walkingLeaves = [];
            this.walkingLeafSpawnTimer = 0;
            this.nextLeafSpawnDelay = 60; // Initial delay before first leaf
            this.useTickSystemForLeaves = true; // Default to tick system
            
            // Initialize some glow particles
            for (let i = 0; i < 15; i++) {
                this.glowParticles.push({
                    x: (Math.random() - 0.5) * 800,
                    y: -200 - Math.random() * 600,
                    z: Math.random() * 200 - 100, // depth for 3D effect
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -Math.random() * 0.3 - 0.1,
                    size: Math.random() * 4 + 2,
                    opacity: Math.random() * 0.5 + 0.3,
                    hue: Math.random() * 60 + 90, // green to yellow range
                    pulsePhase: Math.random() * Math.PI * 2,
                    pulseSpeed: Math.random() * 0.05 + 0.02
                });
            }
        };
        
        VitaEffect.prototype.updateVita = function(currentTick) {
            const animTime = currentTick * 0.01;
            
            // Update tree scale smoothly
            if (this.worldTree.scale < this.worldTree.targetScale) {
                this.worldTree.scale += 0.01;
                if (this.worldTree.scale > this.worldTree.targetScale) {
                    this.worldTree.scale = this.worldTree.targetScale;
                }
            }
            
            this.worldTree.pulsePhase += 0.02;
            this.worldTree.glowIntensity = 0.7; // Fixed intensity, no pulsing
            
            // Update wind
            this.windPhase += 0.015;
            this.windDirection = Math.sin(this.windPhase * 0.25) * 0.3; // Moderate swaying
            this.windStrength = 1.0 + Math.sin(this.windPhase * 0.4) * 0.5; // Vary between 0.5 and 1.5
            
            // Update glow particles
            this.glowParticles = this.glowParticles.filter(particle => {
                // Update position
                particle.x += particle.vx + Math.sin(animTime + particle.pulsePhase) * 0.2;
                particle.y += particle.vy;
                particle.pulsePhase += particle.pulseSpeed;
                
                // Update opacity based on height
                particle.opacity = 0.6 * (1 - (particle.y + 800) / 1000);
                
                // Gentle spiral motion
                particle.vx += Math.cos(animTime * 0.5 + particle.pulsePhase) * 0.01;
                
                // Remove if too high or too low opacity
                return particle.y > -800 && particle.opacity > 0;
            });
            
            // Spawn new glow particles
            this.glowParticleSpawnTimer++;
            if (this.glowParticleSpawnTimer > 10 && this.glowParticles.length < this.maxGlowParticles) {
                this.glowParticles.push({
                    x: (Math.random() - 0.5) * 600,
                    y: 100,
                    z: Math.random() * 200 - 100,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -Math.random() * 0.5 - 0.2,
                    size: Math.random() * 4 + 2,
                    opacity: 0,
                    hue: Math.random() * 60 + 90,
                    pulsePhase: Math.random() * Math.PI * 2,
                    pulseSpeed: Math.random() * 0.05 + 0.02
                });
                this.glowParticleSpawnTimer = 0;
            }
            
            // Update emanation rings
            this.emanationRings = this.emanationRings.filter(ring => {
                ring.radius += ring.speed;
                ring.opacity -= 0.02;
                return ring.opacity > 0 && ring.radius < ring.maxRadius;
            });
            
            // Spawn periodic emanation from tree base
            this.ringSpawnTimer++;
            if (this.ringSpawnTimer > 120) {
                this.emanationRings.push({
                    x: 0,
                    y: 0,
                    radius: 0,
                    maxRadius: 200,
                    opacity: 0.5,
                    speed: 1
                });
                this.ringSpawnTimer = 0;
            }
            
            // Update leaf particles
            this.leafParticles = this.leafParticles.filter(particle => {
                // Apply wind force
                particle.vx += Math.cos(this.windDirection) * this.windStrength * 0.08;
                particle.vy += Math.sin(this.windDirection) * this.windStrength * 0.04;
                
                // Apply light gravity for floating effect
                particle.vy += 0.05;
                
                // Apply moderate air resistance
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                
                // Add slight upward drift occasionally
                if (Math.random() < 0.05) {
                    particle.vy -= 0.1;
                }
                
                // Update position
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // Update rotation
                particle.rotation += particle.rotationSpeed;
                
                // Fade out slowly
                particle.opacity -= 0.0015;
                
                // Only remove if completely faded out (opacity <= 0)
                // Keep particles even if they drift far away, as long as they're still visible
                return particle.opacity > 0;
            });
            
            // Spawn new leaf particles from actual leaves
            this.leafSpawnTimer++;
            if (this.leafSpawnTimer > 80) { // Spawn 75% less leaves (was 20)
                // Filter branches to those in the upper portion of the tree (above 0.6)
                // This will catch branches from the upper clusters while maintaining a large area
                const topBranches = this.worldTree.branches.filter(branch => branch.heightPosition >= 0.6);
                
                if (topBranches.length > 0) {
                    const branch = topBranches[Math.floor(Math.random() * topBranches.length)];
                    
                    // Pick a sub-branch with leaves, preferring those further out on the branch
                    if (branch.subBranches && branch.subBranches.length > 0) {
                        // Use all sub-branches for maximum coverage
                        const subBranch = branch.subBranches[Math.floor(Math.random() * branch.subBranches.length)];
                        
                        // Pick a random leaf from this sub-branch
                        if (subBranch.leaves && subBranch.leaves.length > 0) {
                            const leaf = subBranch.leaves[Math.floor(Math.random() * subBranch.leaves.length)];
                            
                            // Calculate the actual world position of this leaf
                            // Match the rendering calculation for branch position
                            const trunkHeight = 450; // From the rendering code
                            const branchHeight = -trunkHeight * branch.heightPosition; // Negative because tree grows upward
                            
                            // Calculate branch endpoint
                            const endPoint = this.calculateBranchEndpoint(branch, branch.lengthVariation);
                            const swayAmplitude = 8 + branch.heightPosition * 12;
                            const branchSway = Math.sin(this.worldTree.pulsePhase * 0.3 + branch.swayOffset) * swayAmplitude;
                            
                            // Position along main branch where sub-branch starts
                            const t = subBranch.position;
                            const mainBranchX = endPoint.x * t + branchSway * t;
                            const tipDroop = 30 + branch.lengthVariation * 25;
                            const mainBranchY = branchHeight + endPoint.y * t + tipDroop * t;
                            
                            // Add sub-branch offset
                            const subBranchAngle = branch.angle + subBranch.angle;
                            const leafPosAlongSubBranch = leaf.position;
                            const subBranchX = Math.cos(subBranchAngle) * subBranch.length * leafPosAlongSubBranch;
                            const subBranchY = Math.sin(subBranchAngle) * subBranch.length * leafPosAlongSubBranch * 0.5;
                            
                            // Final emission position
                            const emitX = mainBranchX + subBranchX;
                            // Move emission area up to trunk top level (negative Y is up)
                            const trunkTopOffset = -100; // Move up to trunk top area
                            const emitY = mainBranchY + subBranchY + trunkTopOffset;
                            
                            // Create leaf particle with moderate initial velocity
                            this.leafParticles.push({
                                x: emitX,
                                y: emitY,
                                vx: (Math.random() - 0.5) * 1.5, // Moderate horizontal movement
                                vy: -Math.random() * 0.5, // Slight upward initial movement
                                size: 20 + Math.random() * 25, // Slightly smaller than tree leaves (20-45 vs 25-70)
                                rotation: Math.random() * Math.PI * 2,
                                rotationSpeed: (Math.random() - 0.5) * 0.08, // Moderate rotation
                                opacity: 0.7 + Math.random() * 0.2, // Start less transparent
                                color: {
                                    r: leaf.color.r + Math.floor(Math.random() * 20 - 10),
                                    g: leaf.color.g + Math.floor(Math.random() * 20 - 10),
                                    b: leaf.color.b + Math.floor(Math.random() * 20 - 10)
                                }
                            });
                        }
                    }
                }
                this.leafSpawnTimer = 0;
            }
            
            // Update walking leaves - moved to separate method
            if (this.useTickSystemForLeaves) {
                this.updateWalkingLeaves();
            }
        };
        
        // Update walking leaves separately
        VitaEffect.prototype.updateWalkingLeaves = function() {
            this.walkingLeafSpawnTimer++;
            if (this.walkingLeafSpawnTimer >= this.nextLeafSpawnDelay && this.walkingLeaves.length === 0) {
                // Spawn a new walking leaf
                const trunkX = 0;
                const trunkY = 0; // Base of trunk position
                
                // Convert world position to tile position
                const trunkTile = isometricToTile(trunkX, trunkY);
                
                // Create a falling leaf that will land near the trunk
                const landingOffset = 50 + Math.random() * 100; // 50-150 pixels from trunk
                const landingAngle = Math.random() * Math.PI * 2;
                const landingX = trunkX + Math.cos(landingAngle) * landingOffset;
                const landingY = trunkY + Math.sin(landingAngle) * landingOffset * 0.5; // Adjust for isometric
                
                this.walkingLeaves.push({
                    // Falling properties
                    fallingX: trunkX,
                    fallingY: trunkY - 400, // Start high up in the tree
                    targetX: landingX,
                    targetY: landingY,
                    state: 'falling', // 'falling', 'standing', 'walking', 'dying'
                    age: 0, // In ticks
                    maxAge: 6000, // 10 years (600 ticks per year)
                    size: 25 + Math.random() * 45, // Random size 25-70 like tree leaves
                    rotation: 0,
                    opacity: 0.7 + Math.random() * 0.2, // Same as falling leaf particles
                    color: {
                        r: 152 + Math.random() * 40 - 20, // Opalescent color from #98D8C8
                        g: 216 + Math.random() * 30 - 15,
                        b: 200 + Math.random() * 40 - 20
                    },
                    // Movement properties (like Army/Recruit)
                    currentX: trunkTile.x,
                    currentY: trunkTile.y,
                    path: [],
                    pathIndex: 0,
                    moveProgress: 0,
                    speed: 0.01, // Same as before (5x faster than previous adjusted value)
                    // Circular movement properties
                    circleRadius: 3 + Math.floor(Math.random() * 3), // 3-5 tiles from trunk
                    circleAngle: Math.random() * Math.PI * 2,
                    nextTargetTimer: 0,
                    trunkTileX: trunkTile.x,
                    trunkTileY: trunkTile.y
                });
                
                this.walkingLeafSpawnTimer = 0;
                this.nextLeafSpawnDelay = 300 + Math.random() * 300; // Wait 0.5-1 years before next leaf
            }
            
            // Update existing walking leaves
            this.walkingLeaves = this.walkingLeaves.filter(leaf => {
                leaf.age++;
                
                if (leaf.state === 'falling') {
                    // Fall towards landing position
                    const dx = leaf.targetX - leaf.fallingX;
                    const dy = leaf.targetY - leaf.fallingY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 5 && leaf.age < 300) { // Max 300 ticks (5 seconds) of falling
                        // Continue falling with swaying motion
                        const swayAmount = Math.max(0, 2 - dist * 0.1); // Reduce sway as we get closer
                        leaf.fallingX += dx * 0.02 + Math.sin(leaf.age * 0.1) * swayAmount;
                        leaf.fallingY += dy * 0.02 + 0.5; // Gravity
                        leaf.rotation += 0.1;
                    } else {
                        // Landed, transition to standing
                        leaf.state = 'standing';
                        leaf.standingTimer = 0;
                        
                        // Set tile position where we landed
                        const landedTile = isometricToTile(leaf.targetX, leaf.targetY);
                        leaf.currentX = landedTile.x;
                        leaf.currentY = landedTile.y;
                    }
                } else if (leaf.state === 'standing') {
                    // Stand up animation - slower
                    leaf.standingTimer = (leaf.standingTimer || 0) + 1;
                    
                    if (leaf.standingTimer > 90) { // 5x faster - back to original 90 ticks
                        // Start walking
                        leaf.state = 'walking';
                        leaf.nextTargetTimer = 0;
                    }
                } else if (leaf.state === 'walking') {
                    // Check if we need a new target
                    if (!leaf.path || leaf.pathIndex >= leaf.path.length) {
                        // Calculate next position on circle around tree
                        leaf.circleAngle += 0.2 + Math.random() * 0.4; // Move 0.2-0.6 radians
                        
                        // Add some wobble to the radius
                        const currentRadius = leaf.circleRadius + (Math.random() - 0.5) * 2;
                        const targetX = Math.round(leaf.trunkTileX + Math.cos(leaf.circleAngle) * currentRadius);
                        const targetY = Math.round(leaf.trunkTileY + Math.sin(leaf.circleAngle) * currentRadius);
                        
                        // Calculate path
                        leaf.targetX = targetX;
                        leaf.targetY = targetY;
                        leaf.path = this.calculateLeafPath(leaf.currentX, leaf.currentY, targetX, targetY);
                        leaf.pathIndex = 0;
                        leaf.moveProgress = 0;
                    }
                    
                    // Move along path exactly like armies do
                    if (leaf.pathIndex < leaf.path.length) {
                        leaf.moveProgress += leaf.speed;
                        
                        if (leaf.moveProgress >= 1) {
                            leaf.moveProgress = 0;
                            leaf.currentX = leaf.path[leaf.pathIndex].x;
                            leaf.currentY = leaf.path[leaf.pathIndex].y;
                            leaf.pathIndex++;
                        }
                    }
                    
                    // Check if nearing end of life
                    if (leaf.age >= leaf.maxAge - 300) { // Last 0.5 years
                        leaf.state = 'dying';
                        leaf.dyingDirection = Math.random() < 0.5 ? -1 : 1; // Random left or right
                    }
                } else if (leaf.state === 'dying') {
                    // Fade out without shrinking
                    leaf.opacity *= 0.98;
                    
                    if (leaf.opacity < 0.01) {
                        return false; // Remove this leaf
                    }
                }
                
                return true; // Keep this leaf
            });
        };
        
        // Simple pathfinding for leaves - just move in straight lines tile by tile
        VitaEffect.prototype.calculateLeafPath = function(fromX, fromY, toX, toY) {
            const path = [];
            let currentX = fromX;
            let currentY = fromY;
            
            while (currentX !== toX || currentY !== toY) {
                // Move one tile at a time towards target
                if (currentX < toX) currentX++;
                else if (currentX > toX) currentX--;
                
                if (currentY < toY) currentY++;
                else if (currentY > toY) currentY--;
                
                path.push({x: currentX, y: currentY});
                
                // Safety check to prevent infinite loops
                if (path.length > 20) break;
            }
            
            return path;
        };
        
        // Get current position for walking leaf (same as Army.prototype.getPosition)
        VitaEffect.prototype.getLeafPosition = function(leaf) {
            if (leaf.state === 'falling') {
                return {x: leaf.fallingX, y: leaf.fallingY};
            }
            
            if (!leaf.path || leaf.pathIndex >= leaf.path.length) {
                return worldToIsometric(leaf.currentX, leaf.currentY);
            }
            
            const from = leaf.pathIndex === 0 ? {x: leaf.currentX, y: leaf.currentY} : leaf.path[leaf.pathIndex - 1];
            const to = leaf.path[leaf.pathIndex];
            
            const x = from.x + (to.x - from.x) * leaf.moveProgress;
            const y = from.y + (to.y - from.y) * leaf.moveProgress;
            
            return worldToIsometric(x, y);
        };
        
        VitaEffect.prototype.calculateBranchEndpoint = function(branch, position = 1) {
            const length = 225 * position; // Half of 450
            const x = Math.cos(branch.angle) * length;
            const y = Math.sin(branch.angle) * length * 0.5 - 150; // Adjusted proportionally
            return { x, y };
        };
        
        // Kingdom class
        function Kingdom(id, name, color, capitalX, capitalY, worldId) {
            this.id = worldId * 1000 + id; // Make ID globally unique across worlds
            this.localId = id; // Keep local ID for world-specific operations
            this.name = name;
            this.color = color;
            this.worldId = worldId;
            this.capitalX = capitalX; // The original capital
            this.capitalY = capitalY;
            this.troops = 20;
            this.territory = 0;
            this.alive = true;
            this.hasTemple = false;
            this.templeLevel = 0;
            
            // Military
            this.armies = [];
            this.targetedTiles = {};
            this.armyCreationCounter = 0; // Track armies created for banner assignment
            this.targetKingdom = null; // Target kingdom ID during war
            
            this.controlledCapitals = [{ x: this.capitalX, y: this.capitalY }];
            this.villages = [];
            this.originalCapital = { x: capitalX, y: capitalY }; // Store original capital for war effects 
            
            // AI State
            this.state = KingdomState.EXPANDING;
            this.aiCooldown = 0;
            this.lastStateChange = 0;
            
            // Expansion
            this.expansionCooldown = 0;
            this.expansionDelay = 10; // 3x faster expansion (was 30)
            
            // Relationships
            this.truces = {};
            this.enemies = {};
            this.warTarget = null;
            
            // War Weariness
            this.warWeariness = 0;
            
            // Temple Requests
            this.templeRequests = [];
            this.temples = [];
            this.lastRequestCompletedTick = 0;
            
            this.worldConqueror = false;
            
            // Portal invasion tracking
            this.recentlyCreatedPortal = null;
            this.invasionCooldown = 0;
            
            // Performance optimization
            this._cachedTroopCap = null;
            this._troopCapCacheTick = -1;
            
            // Dirty flag for statistics
            this._statsCache = null;
            this._statsDirty = true;
            
            // Performance: incremental territory tracking
            this.territoryCount = 0;
            
            // Performance: extended border cache (30+ ticks)
            this.borderTilesCache = null;
            this.borderCacheTime = -1;
            this.borderCacheDuration = 30; // Extended from 10 to 30 ticks
            
            // NEW: Incremental border tracking
            this.borderTiles = new Set(); // Set of "x,y" strings for all border tiles
            this.borderTilesDirty = false; // Flag to indicate if borders need full recalculation
            
            // Performance: track foreign invaders
            this.foreignInvaders = new Set(); // Track foreign armies in our territory
            
            // Banner design
            this.bannerDesign = this.generateBannerDesign();
        }

        Kingdom.prototype.calculateTroopCap = function() {
            // Cache troop cap calculation for performance
            if (this._troopCapCacheTick === game.currentTick) {
                return this._cachedTroopCap;
            }
            
            const troopCapPerStructure = 5;
            let totalStructures = this.controlledCapitals.length;
            
            // Count valid villages (those still on kingdom territory)
            let validVillages = 0;
            for (const village of this.villages) {
                // Find which world this village is in by checking all worlds
                for (let w = 0; w < worlds.length; w++) {
                    if (worlds[w].tiles[village.x] && worlds[w].tiles[village.x][village.y]) {
                        if (worlds[w].tiles[village.x][village.y].owner === this.id) {
                            validVillages++;
                            break;
                        }
                    }
                }
            }
            
            this._cachedTroopCap = (validVillages + totalStructures) * troopCapPerStructure;
            this._troopCapCacheTick = game.currentTick;
            return this._cachedTroopCap;
        };
        
        Kingdom.prototype.update = function(world, tick) {
            if (!this.alive) return;
            
            // Check for mega-empire collapse conditions (only for very large, war-weary empires)
            if (this.state === KingdomState.RECOVERING && 
                this.warWeariness > 95 &&  // Increased from 90 to 95
                this.controlledCapitals.length > 3 &&  // Only collapse if controlling 4+ capitals
                tick - this.lastStateChange > 600) {  // Increased from 300 to 600 ticks
                
                // Mega-empire collapses into multi-capital kingdoms
                const secondaryCapitals = this.controlledCapitals.filter(c => 
                    c.x !== this.capitalX || c.y !== this.capitalY
                );
                
                // Group capitals into new kingdoms (2-3 capitals each)
                const capitalsPerNewKingdom = Math.min(3, Math.max(2, Math.floor(secondaryCapitals.length / 3)));
                const newKingdomGroups = [];
                
                for (let i = 0; i < secondaryCapitals.length; i += capitalsPerNewKingdom) {
                    const group = secondaryCapitals.slice(i, i + capitalsPerNewKingdom);
                    if (group.length > 0) {
                        newKingdomGroups.push(group);
                    }
                }
                
                // Create new multi-capital kingdoms
                const createdKingdoms = [];
                for (const capitalGroup of newKingdomGroups) {
                    const primaryCapital = capitalGroup[0]; // First capital becomes the primary
                    const newKingdomId = world.kingdoms.length + createdKingdoms.length;
                    const newName = generateKingdomName();
                    const newKingdom = new Kingdom(
                        newKingdomId, 
                        newName, 
                        generateKingdomColor(), 
                        primaryCapital.x, 
                        primaryCapital.y, 
                        world.id
                    );
                    
                    // Give the new kingdom all capitals in its group
                    newKingdom.controlledCapitals = [...capitalGroup];
                    newKingdom.troops = 15 + Math.floor(Math.random() * 10); // More troops for larger kingdoms
                    newKingdom.warWeariness = this.warWeariness * 0.3; // Less war weariness
                    newKingdom.state = KingdomState.RECOVERING;
                    
                    createdKingdoms.push(newKingdom);
                    world.kingdoms.push(newKingdom);
                    
                    // Add truces between all fragments
                    this.truces[newKingdom.id] = tick + 600; // Longer truces
                    newKingdom.truces[this.id] = tick + 600;
                    
                    // Add truces between new kingdoms
                    for (const otherNew of createdKingdoms) {
                        if (otherNew.id !== newKingdom.id) {
                            newKingdom.truces[otherNew.id] = tick + 400;
                            otherNew.truces[newKingdom.id] = tick + 400;
                        }
                    }
                }
                
                // Remove secondary capitals from this kingdom
                this.controlledCapitals = [{ x: this.capitalX, y: this.capitalY }];
                
                // Redistribute territory based on closest capital (checking all capitals of new kingdoms)
                for (let y = 0; y < WORLD_SIZE; y++) {
                    for (let x = 0; x < WORLD_SIZE; x++) {
                        if (world.tiles[x][y].owner === this.id) {
                            // Find closest capital among all kingdoms
                            let minDist = Math.abs(x - this.capitalX) + Math.abs(y - this.capitalY);
                            let newOwner = this;
                            
                            // Check distance to all capitals of newly created kingdoms
                            for (const newK of createdKingdoms) {
                                for (const capital of newK.controlledCapitals) {
                                    const dist = Math.abs(x - capital.x) + Math.abs(y - capital.y);
                                    if (dist < minDist) {
                                        minDist = dist;
                                        newOwner = newK;
                                    }
                                }
                            }
                            
                            if (newOwner !== this) {
                                world.tiles[x][y].owner = newOwner.id;
                                markTileDirty(world.id, x, y);
                                this.territory--;
                                newOwner.territory++;
                            }
                        }
                    }
                }
                
                // Redistribute villages based on new tile ownership
                const villagesToRedistribute = [...this.villages];
                this.villages = [];
                
                for (const village of villagesToRedistribute) {
                    const newOwnerId = world.tiles[village.x][village.y].owner;
                    if (newOwnerId !== null) {
                        const newOwnerKingdom = world.kingdoms.find(k => k.id === newOwnerId && k.alive);
                        if (newOwnerKingdom) {
                            newOwnerKingdom.villages.push({ x: village.x, y: village.y });
                        }
                    }
                }
                
                // Reset war weariness after collapse
                this.warWeariness = 10; // Reduced from 20 since it's a more dramatic collapse
                this.worldConqueror = false;
                this.state = KingdomState.EXPANDING;
                this.lastStateChange = tick;
            }
            
            if (this.aiCooldown > 0) this.aiCooldown--;
            
            for (var id in this.truces) {
                if (this.truces[id] < tick) {
                    delete this.truces[id];
                }
            }
            
            if (this.state === KingdomState.AT_WAR || this.state === KingdomState.INVADING) {
                this.warWeariness = Math.min(100, this.warWeariness + 0.05);
            } else {
                this.warWeariness = Math.max(0, this.warWeariness - 0.02);
            }
            
            if (tick % 150 === 0 && this.state !== KingdomState.AT_WAR) {
                 this.tryPlaceVillage(world);
            }

            if (tick % 10 === 0) {
                // Clean up villages that are no longer on kingdom territory
                // Check villages across all worlds since kingdoms can have cross-world territories
                this.villages = this.villages.filter(village => {
                    // Find which world this village is in
                    for (let w = 0; w < worlds.length; w++) {
                        if (worlds[w].tiles[village.x] && 
                            worlds[w].tiles[village.x][village.y]) {
                            // Check if this kingdom owns the tile in that world
                            if (worlds[w].tiles[village.x][village.y].owner === this.id) {
                                return true; // Keep the village
                            }
                        }
                    }
                    return false; // Village not found or not owned
                });
            }

            // Automatic expansion with cooldown
            if (this.expansionCooldown > 0) {
                this.expansionCooldown--;
            } else {
                // Try to expand to empty adjacent land
                var expansionTiles = this.getExpansionTiles(world);
                if (expansionTiles.length > 0) {
                    var tile = expansionTiles[Math.floor(Math.random() * expansionTiles.length)];
                    const oldOwner = world.tiles[tile.x][tile.y].owner;
                    world.tiles[tile.x][tile.y].owner = this.id;
                    markTileDirty(world.id, tile.x, tile.y);
                    this.territory++;
                    this.territoryCount++;
                    // NEW: Update borders incrementally
                    updateBordersAroundTile(world, tile.x, tile.y, oldOwner, this.id);
                    
                    // Dynamic expansion delay based on territory size (3x faster)
                    // Smaller kingdoms expand faster, larger ones slower
                    this.expansionDelay = Math.min(20, 7 + Math.floor(this.territory / 30));
                    this.expansionCooldown = this.expansionDelay;
                }
            }
            
            if (this.aiCooldown === 0) {
                this.updateAIState(world, tick);
                this.executeAIAction(world, tick);
                
                switch(this.state) {
                    case KingdomState.EXPANDING: this.aiCooldown = 25 + Math.floor(Math.random() * 10); break;
                    case KingdomState.PREPARING_WAR: this.aiCooldown = 20 + Math.floor(Math.random() * 10); break;
                    case KingdomState.AT_WAR: this.aiCooldown = 15 + Math.floor(Math.random() * 10); break;
                    case KingdomState.INVADING: this.aiCooldown = 5 + Math.floor(Math.random() * 5); break;
                    case KingdomState.DEFENDING: this.aiCooldown = 10 + Math.floor(Math.random() * 10); break;
                    case KingdomState.RECOVERING: this.aiCooldown = 20 + Math.floor(Math.random() * 20); break;
                }
            }
            
            // Army updates moved to main game tick for consistent movement
            
            this.templeRequests = this.templeRequests.filter(req => req.update());
            
            // Generate requests from capitals without temples
            if (Math.random() < 0.01 && this.templeRequests.length === 0) { // Temporarily increased from 0.001 to 0.01 for testing
                // Debug log controlled capitals
                if (this.controlledCapitals.length > 1) {
                    console.log(`Kingdom ${this.name} has ${this.controlledCapitals.length} controlled capitals:`, this.controlledCapitals);
                }
                
                // Check each controlled capital for temple requests
                for (const capital of this.controlledCapitals) {
                    // Check if this capital is in the current world
                    const capitalTile = world.tiles[capital.x] && world.tiles[capital.x][capital.y];
                    if (!capitalTile) {
                        // This capital is in a different world, skip it for this world's update
                        continue;
                    }
                    
                    // Verify this capital is still owned by this kingdom in this world
                    if (capitalTile.owner !== this.id) {
                        console.log(`Capital at (${capital.x}, ${capital.y}) is no longer owned by ${this.name} in world ${world.name}`);
                        continue;
                    }
                    
                    // Check if this capital has a temple nearby (within 3 tiles)
                    const searchRadius = 3;
                    let hasTempleNearby = false;
                    
                    if (this.temples) {
                        for (const temple of this.temples) {
                            const distance = Math.abs(temple.x - capital.x) + Math.abs(temple.y - capital.y);
                            if (distance <= searchRadius) {
                                hasTempleNearby = true;
                                break;
                            }
                        }
                    }
                    
                    if (!hasTempleNearby) {
                        // Generate request from this capital
                        const isOriginal = capital.x === this.capitalX && capital.y === this.capitalY;
                        console.log(`Generating temple request from ${isOriginal ? 'original' : 'captured'} capital at (${capital.x}, ${capital.y}) for kingdom ${this.name}`);
                        this.generateTempleRequest(world, capital);
                        break; // Only one request at a time
                    }
                }
            }
        };
        
        Kingdom.prototype.updateAIState = function(world, tick) {
            var neighbors = this.getNeighbors(world);
            var aliveKingdoms = world.kingdoms.filter(k => k.alive).length;
            
            // Check for foreign invaders first
            var foreignInvaders = this.detectForeignInvaders(world);
            var threats = this.getThreats(neighbors); // This now includes foreign invaders
            var opportunities = this.getOpportunities(neighbors, aliveKingdoms);
            
            // Immediate response to foreign invasion (only if they border us)
            if (foreignInvaders.length > 0 && this.state !== KingdomState.AT_WAR && this.state !== KingdomState.DEFENDING) {
                // Filter to only invaders that border us
                let borderingInvaders = [];
                
                for (const invader of foreignInvaders) {
                    // Check if this invader borders our territory
                    let sharesBorder = false;
                    
                    for (let y = 0; y < WORLD_SIZE && !sharesBorder; y++) {
                        for (let x = 0; x < WORLD_SIZE && !sharesBorder; x++) {
                            if (world.tiles[x][y].owner === invader.id) {
                                // Check if this invader tile is adjacent to any of our tiles
                                const neighbors = [
                                    {x: x + 1, y: y}, {x: x - 1, y: y}, 
                                    {x: x, y: y + 1}, {x: x, y: y - 1}
                                ];
                                
                                for (const neighbor of neighbors) {
                                    if (neighbor.x >= 0 && neighbor.x < WORLD_SIZE && 
                                        neighbor.y >= 0 && neighbor.y < WORLD_SIZE &&
                                        world.tiles[neighbor.x][neighbor.y].owner === this.id) {
                                        sharesBorder = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    if (sharesBorder) {
                        borderingInvaders.push(invader);
                    }
                }
                
                // Only respond to bordering invaders
                if (borderingInvaders.length > 0) {
                    // Find the most threatening bordering invader
                    let primaryThreat = borderingInvaders[0];
                    for (const invader of borderingInvaders) {
                        // Count invader's territory in our world
                        let invaderTerritory = 0;
                        for (let y = 0; y < WORLD_SIZE; y++) {
                            for (let x = 0; x < WORLD_SIZE; x++) {
                                if (world.tiles[x][y].active && world.tiles[x][y].owner === invader.id) {
                                    invaderTerritory++;
                                }
                            }
                        }
                        // Prioritize invaders with more territory
                        if (invaderTerritory > 5) {
                            primaryThreat = invader;
                            break;
                        }
                    }
                    
                    // React based on our strength
                    if (this.troops >= primaryThreat.troops * 0.7) {
                        this.state = KingdomState.AT_WAR;
                        this.warTarget = primaryThreat;
                        this.enemies[primaryThreat.id] = true;
                        primaryThreat.enemies[this.id] = true;
                    } else {
                        this.state = KingdomState.DEFENDING;
                    }
                    return;
                }
            }
            
            // Check for immediate capital threats
            const capitalThreatDistance = 3; // Tiles away from capital to trigger defense
            for (const capital of this.controlledCapitals) {
                // Check if this capital is in the current world
                if (world.tiles[capital.x] && world.tiles[capital.x][capital.y] && 
                    world.tiles[capital.x][capital.y].owner === this.id) {
                    
                    // Check for enemy tiles near this capital
                    let threatFound = false;
                    let nearestThreat = null;
                    let minDistance = capitalThreatDistance + 1;
                    
                    for (let dy = -capitalThreatDistance; dy <= capitalThreatDistance; dy++) {
                        for (let dx = -capitalThreatDistance; dx <= capitalThreatDistance; dx++) {
                            const checkX = capital.x + dx;
                            const checkY = capital.y + dy;
                            
                            if (checkX >= 0 && checkX < WORLD_SIZE && checkY >= 0 && checkY < WORLD_SIZE) {
                                const tile = world.tiles[checkX][checkY];
                                if (tile.owner !== null && tile.owner !== this.id && !this.truces[tile.owner]) {
                                    const distance = Math.abs(dx) + Math.abs(dy);
                                    if (distance < minDistance) {
                                        minDistance = distance;
                                        threatFound = true;
                                        // Find the threat kingdom
                                        for (const enemy of [...threats, ...world.kingdoms.filter(k => k.id === tile.owner && k.alive)]) {
                                            if (enemy.id === tile.owner) {
                                                nearestThreat = enemy;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    if (threatFound && nearestThreat && minDistance <= 2) {
                        // Immediate threat to capital - defend!
                        this.state = KingdomState.DEFENDING;
                        this.warTarget = nearestThreat;
                        this.enemies[nearestThreat.id] = true;
                        return;
                    }
                }
            }
            
            // Native kingdoms should cooperate against foreign invaders
            if (this.worldId === world.id && Math.random() < 0.1) {
                // Check for bordering foreign invaders
                let borderingInvaders = [];
                
                for (const invader of foreignInvaders) {
                    // Check if this invader borders our territory
                    let sharesBorder = false;
                    
                    for (let y = 0; y < WORLD_SIZE && !sharesBorder; y++) {
                        for (let x = 0; x < WORLD_SIZE && !sharesBorder; x++) {
                            if (world.tiles[x][y].owner === invader.id) {
                                // Check if this invader tile is adjacent to any of our tiles
                                const neighbors = [
                                    {x: x + 1, y: y}, {x: x - 1, y: y}, 
                                    {x: x, y: y + 1}, {x: x, y: y - 1}
                                ];
                                
                                for (const neighbor of neighbors) {
                                    if (neighbor.x >= 0 && neighbor.x < WORLD_SIZE && 
                                        neighbor.y >= 0 && neighbor.y < WORLD_SIZE &&
                                        world.tiles[neighbor.x][neighbor.y].owner === this.id) {
                                        sharesBorder = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    if (sharesBorder) {
                        borderingInvaders.push(invader);
                    }
                }
                
                if (borderingInvaders.length > 0) {
                    // Native kingdom detecting foreign invasion at their borders
                    // Consider making temporary truces with other native kingdoms
                    for (const nativeKingdom of world.kingdoms) {
                        if (nativeKingdom.alive && nativeKingdom.id !== this.id && 
                            !this.truces[nativeKingdom.id] && this.enemies[nativeKingdom.id]) {
                            // Check if this native kingdom is also threatened by invaders
                            const sharesEnemyInvader = borderingInvaders.some(inv => nativeKingdom.enemies[inv.id]);
                            if (sharesEnemyInvader && Math.random() < 0.5) {
                                // Make a temporary alliance against invaders
                                this.makeTruce(nativeKingdom, tick);
                                this.warWeariness = Math.max(0, this.warWeariness - 10);
                            }
                        }
                    }
                }
            }
            
            // Check for portal attack opportunities
            if (this.state !== KingdomState.INVADING && this.canCreatePortal(world)) {
                // Look for invasion opportunities
                const invasionTarget = this.findInvasionTarget(world);
                // World conquerors are more aggressive about invading
                const invasionChance = this.worldConqueror ? 0.6 : 0.3;
                if (invasionTarget && Math.random() < invasionChance) {
                    this.targetWorldForInvasion = invasionTarget;
                    this.state = KingdomState.INVADING;
                    return;
                }
            }
            
            // Check for existing portal usage opportunities (regardless of state)
            if ((this.state === KingdomState.EXPANDING || this.state === KingdomState.AT_WAR) && 
                this.troops > 0 && Math.random() < 0.2) {
                const controlledPortals = this.getControlledPortals(world);
                
                // Check for expiring portals that need urgent use
                const expiringPortals = controlledPortals.filter(p => 
                    p.expiresTick - game.currentTick < 300 // Less than 10 seconds left
                );
                
                if (expiringPortals.length > 0 && this.troops >= 5) {
                    // Urgently use expiring portals
                    for (const portal of expiringPortals) {
                        if (this.troops <= 0 || this.armies.length >= 12) break;
                        this.sendInvasionForce(world, portal);
                    }
                } else if (controlledPortals.length > 0 && this.troops >= 10) {
                    // Opportunistically use portals when we have excess troops
                    const portal = controlledPortals[Math.floor(Math.random() * controlledPortals.length)];
                    this.sendInvasionForce(world, portal);
                }
            }
            
            if (this.warWeariness > 70 && this.state === KingdomState.AT_WAR) {
                if (Math.random() < 0.5) {
                    this.makeTruce(this.warTarget, tick);
                    this.state = KingdomState.RECOVERING;
                    return;
                }
            }
            
            // Check for world domination - Fixed to check all kingdoms
            if (!this.worldConqueror) {
                let controlsAllTiles = true;
                for (let y = 0; y < WORLD_SIZE; y++) {
                    for (let x = 0; x < WORLD_SIZE; x++) {
                        if (world.tiles[x][y].active && world.tiles[x][y].owner !== this.id) {
                            controlsAllTiles = false;
                            break;
                        }
                    }
                    if (!controlsAllTiles) break;
                }
                
                if (controlsAllTiles) {
                    this.worldConqueror = true;
                    
                    // Remove conqueror status from others who might have lost all tiles
                    for (let w = 0; w < worlds.length; w++) {
                        for (const k of worlds[w].kingdoms) {
                            if (k.id !== this.id && k.worldConqueror) {
                                // Check if they still control all tiles in any world
                                let stillConqueror = false;
                                for (let wCheck = 0; wCheck < worlds.length; wCheck++) {
                                    let controlsWorld = true;
                                    for (let y = 0; y < WORLD_SIZE; y++) {
                                        for (let x = 0; x < WORLD_SIZE; x++) {
                                            if (worlds[wCheck].tiles[x][y].owner !== k.id) {
                                                controlsWorld = false;
                                                break;
                                            }
                                        }
                                        if (!controlsWorld) break;
                                    }
                                    if (controlsWorld) {
                                        stillConqueror = true;
                                        break;
                                    }
                                }
                                if (!stillConqueror) {
                                    k.worldConqueror = false;
                                }
                            }
                        }
                    }
                }
            }
            
            switch(this.state) {
                case KingdomState.EXPANDING:
                    if (threats.length > 0 && this.troops < threats[0].troops * 0.8) this.state = KingdomState.DEFENDING;
                    else if (this.worldId === world.id) {
                        // Native kingdom should focus on defense when invaders present at borders
                        // Check for bordering foreign invaders
                        let borderingInvaders = [];
                        
                        for (const invader of foreignInvaders) {
                            // Check if this invader borders our territory
                            let sharesBorder = false;
                            
                            for (let y = 0; y < WORLD_SIZE && !sharesBorder; y++) {
                                for (let x = 0; x < WORLD_SIZE && !sharesBorder; x++) {
                                    if (world.tiles[x][y].owner === invader.id) {
                                        // Check if this invader tile is adjacent to any of our tiles
                                        const neighbors = [
                                            {x: x + 1, y: y}, {x: x - 1, y: y}, 
                                            {x: x, y: y + 1}, {x: x, y: y - 1}
                                        ];
                                        
                                        for (const neighbor of neighbors) {
                                            if (neighbor.x >= 0 && neighbor.x < WORLD_SIZE && 
                                                neighbor.y >= 0 && neighbor.y < WORLD_SIZE &&
                                                world.tiles[neighbor.x][neighbor.y].owner === this.id) {
                                                sharesBorder = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            
                            if (sharesBorder) {
                                borderingInvaders.push(invader);
                            }
                        }
                        
                        if (borderingInvaders.length > 0) {
                            if (this.troops >= 15) {
                                // Find the weakest bordering invader to target
                                let weakestInvader = borderingInvaders[0];
                                let minTroops = borderingInvaders[0].troops;
                                for (const invader of borderingInvaders) {
                                    if (invader.troops < minTroops) {
                                        minTroops = invader.troops;
                                        weakestInvader = invader;
                                    }
                                }
                                this.state = KingdomState.PREPARING_WAR;
                                this.warTarget = weakestInvader;
                            } else {
                                this.state = KingdomState.DEFENDING;
                            }
                        } else if (opportunities.length > 0 && this.warWeariness < 20 && !this.targetKingdom) {
                            // Only start wars with natives if no foreign threats at borders and no divine war
                            this.state = KingdomState.PREPARING_WAR;
                            this.warTarget = opportunities[0];
                        }
                    } else if (opportunities.length > 0 && this.warWeariness < 20 && foreignInvaders.length === 0 && !this.targetKingdom) {
                        // Only start wars with natives if no foreign threats and no divine war
                        this.state = KingdomState.PREPARING_WAR;
                        this.warTarget = opportunities[0];
                    } else if (this.getExpansionTiles(world).length === 0) this.state = KingdomState.RECOVERING;
                    break;
                    
                case KingdomState.PREPARING_WAR:
                    // Check if we have a divine war target that should take priority
                    if (this.targetKingdom) {
                        const divineTarget = findKingdomById(this.targetKingdom);
                        if (divineTarget && divineTarget.alive) {
                            this.warTarget = divineTarget;
                            this.state = KingdomState.AT_WAR;
                            this.enemies[divineTarget.id] = true;
                            divineTarget.enemies[this.id] = true;
                            break;
                        }
                    }
                    
                    if (!this.warTarget || !this.warTarget.alive || this.truces[this.warTarget.id]) {
                        this.state = KingdomState.EXPANDING; this.warTarget = null;
                    } else if (this.troops > this.warTarget.troops) {
                        this.state = KingdomState.AT_WAR;
                        this.enemies[this.warTarget.id] = true;
                        this.warTarget.enemies[this.id] = true;
                    }
                    break;
                    
                case KingdomState.AT_WAR:
                    // Check if we have a divine war target
                    if (this.targetKingdom) {
                        const divineTarget = findKingdomById(this.targetKingdom);
                        if (divineTarget && divineTarget.alive) {
                            this.warTarget = divineTarget; // Ensure warTarget matches divine target
                        }
                    }
                    
                    if (!this.warTarget || !this.warTarget.alive) { this.state = KingdomState.EXPANDING; this.warTarget = null; } 
                    else if (this.troops < 5) this.state = KingdomState.DEFENDING;
                    else if (this.warWeariness > 50 && Math.random() < 0.3 && !this.targetKingdom) {
                        // Only make truce if not in divine war
                        this.makeTruce(this.warTarget, tick);
                        this.state = KingdomState.RECOVERING;
                    }
                    break;
                case KingdomState.INVADING:
                    // Check if we still have valid portals or can create them
                    const controlledPortals = this.getControlledPortals(world);
                    
                    if (controlledPortals.length === 0 && !this.canCreatePortal(world)) {
                        // No portals and can't create new ones
                        this.state = KingdomState.RECOVERING;
                    } else if (controlledPortals.length > 0 && this.troops === 0) {
                        // Have portals but no troops
                        this.state = KingdomState.RECOVERING;
                    } else if (this.invasionCooldown <= 0 && controlledPortals.length === 0) {
                        // Cooldown expired and no active portals
                        this.state = KingdomState.EXPANDING;
                    }
                    // Otherwise stay in INVADING state to keep sending troops
                    break;
                case KingdomState.DEFENDING:
                     if (threats.length === 0 || this.troops > threats[0].troops) this.state = KingdomState.RECOVERING;
                    break;
                case KingdomState.RECOVERING:
                    const troopCap = this.calculateTroopCap();
                    if (this.troops >= troopCap * 0.95) {
                        // At troop cap - stop recovering
                        if (this.warTarget && this.warTarget.alive) {
                            // Still have a war target - go back to war with massive attack
                            this.state = KingdomState.AT_WAR;
                        } else {
                            // No war target - expand
                            this.state = KingdomState.EXPANDING;
                        }
                    } else if (tick - this.lastStateChange > 60 && this.warWeariness < 10) {
                        this.state = KingdomState.EXPANDING;
                    }
                    break;
            }
            
            if (this.state !== this.previousState) {
                this.lastStateChange = tick;
                this.previousState = this.state;
            }
        };
        
        Kingdom.prototype.executeAIAction = function(world, tick) {
            switch(this.state) {
                case KingdomState.EXPANDING: break; // Expansion is now automatic
                case KingdomState.PREPARING_WAR: break; // No expansion during war preparation
                    
                case KingdomState.AT_WAR:
                    // Check for divine war target first
                    let actualWarTarget = this.warTarget;
                    if (this.targetKingdom) {
                        const divineTarget = findKingdomById(this.targetKingdom);
                        if (divineTarget && divineTarget.alive) {
                            actualWarTarget = divineTarget;
                        }
                    }
                    
                    if (actualWarTarget && actualWarTarget.alive && this.troops > 0) {
                        // Check if at troop cap for massive attack
                        const troopCap = this.calculateTroopCap();
                        const isAtTroopCap = this.troops >= troopCap * 0.95;
                        
                        let potentialTargets = this.findAllEnemyBorderTiles(world, actualWarTarget);
                        if (potentialTargets.length === 0) break;
                        
                        // Find all valid capitals that can spawn armies
                        const validCapitals = [];
                        for (const capital of this.controlledCapitals) {
                            // Check if this capital is in the current world
                            if (world.tiles[capital.x] && world.tiles[capital.x][capital.y] && 
                                world.tiles[capital.x][capital.y].owner === this.id) {
                                
                                // Check if capital is burned
                                const capitalKey = capital.x + ',' + capital.y + ',' + world.id;
                                if (!game.burnedCapitals[capitalKey]) {
                                    validCapitals.push(capital);
                                }
                            }
                        }
                        
                        // If no valid capitals, check main capital
                        if (validCapitals.length === 0) {
                            const mainCapitalKey = this.capitalX + ',' + this.capitalY + ',' + world.id;
                            if (!game.burnedCapitals[mainCapitalKey]) {
                                validCapitals.push({ x: this.capitalX, y: this.capitalY });
                            } else {
                                break; // All capitals are burned
                            }
                        }
                        
                        // Find the 3 capitals closest to enemy borders
                        const capitalsWithDistance = [];
                        for (const capital of validCapitals) {
                            // Check distance to closest enemy tile
                            let closestDist = Infinity;
                            for (const target of potentialTargets) {
                                const dist = Math.abs(target.x - capital.x) + Math.abs(target.y - capital.y);
                                if (dist < closestDist) closestDist = dist;
                            }
                            capitalsWithDistance.push({ capital, distance: closestDist });
                        }
                        
                        // Sort by distance and take the 3 closest
                        capitalsWithDistance.sort((a, b) => a.distance - b.distance);
                        const borderingCapitals = capitalsWithDistance.slice(0, 3);
                        
                        // Calculate total armies to spawn based on kingdom size and readiness
                        let totalArmiesToSpawn;
                        if (isAtTroopCap) {
                            // At cap: launch massive attack using up to 50% of troops
                            totalArmiesToSpawn = Math.min(this.troops, Math.floor(troopCap * 0.5));
                        } else {
                            // Normal attack: scale with available troops
                            const attackRatio = Math.min(0.3, this.troops / troopCap); // Up to 30% of troops
                            totalArmiesToSpawn = Math.floor(this.troops * attackRatio);
                        }
                        
                        // Calculate armies per capital, ensuring minimum of 2 per capital
                        const baseArmiesPerCapital = Math.max(2, Math.floor(totalArmiesToSpawn / borderingCapitals.length));
                        let remainingArmies = totalArmiesToSpawn;
                        
                        // Each capital spawns armies independently
                        for (let capIndex = 0; capIndex < borderingCapitals.length; capIndex++) {
                            const { capital, distance } = borderingCapitals[capIndex];
                            
                            // Skip if we're out of troops or at army limit
                            if (this.troops <= 0 || this.armies.length >= 12) break;
                            
                            // Calculate how many armies this capital should spawn
                            let armiesToSpawnFromCapital;
                            if (capIndex === borderingCapitals.length - 1) {
                                // Last capital gets remaining armies
                                armiesToSpawnFromCapital = Math.min(remainingArmies, this.troops, 12 - this.armies.length);
                            } else {
                                armiesToSpawnFromCapital = Math.min(baseArmiesPerCapital, this.troops, 12 - this.armies.length);
                            }
                            
                            // Find available targets for this capital
                            const availableTargetsForCapital = potentialTargets.filter(target => {
                                const tileKey = target.x + ',' + target.y + ',' + world.id;
                                return !this.targetedTiles[tileKey];
                            });
                            
                            // Sort by distance from this specific capital
                            availableTargetsForCapital.sort((a, b) => {
                                const distA = Math.abs(a.x - capital.x) + Math.abs(a.y - capital.y);
                                const distB = Math.abs(b.x - capital.x) + Math.abs(b.y - capital.y);
                                return distA - distB;
                            });
                            
                            // Spawn armies from this capital
                            let armiesSpawnedFromCapital = 0;
                            for (let i = 0; i < availableTargetsForCapital.length && armiesSpawnedFromCapital < armiesToSpawnFromCapital; i++) {
                                if (this.troops <= 0 || this.armies.length >= 12) break;
                                
                                const target = availableTargetsForCapital[i];
                                const tileKey = target.x + ',' + target.y + ',' + world.id;
                                
                                // Check if army can reach the target (avoid lava)
                                if (!Army.canReachTarget(world, capital.x, capital.y, target.x, target.y)) {
                                    console.log(`Army cannot reach target from (${capital.x}, ${capital.y}) to (${target.x}, ${target.y}) - path blocked by lava`);
                                    continue; // Skip this target
                                }
                                
                                // Spawn army
                                var army = new Army(this, 1, capital.x, capital.y, target.x, target.y, world.id);
                                army.task = 'attack';
                                army.originalTarget = {x: target.x, y: target.y};
                                army.targetTileKey = tileKey;
                                this.targetedTiles[tileKey] = army;
                                
                                // Every 3rd army gets a banner
                                this.armyCreationCounter++;
                                if (this.armyCreationCounter % 3 === 0) {
                                    army.hasBanner = true;
                                }
                                
                                this.armies.push(army);
                                this.troops--;
                                remainingArmies--;
                                armiesSpawnedFromCapital++;
                            }
                            
                            // Add spawn effect if armies were spawned
                            if (armiesSpawnedFromCapital > 0) {
                                game.armySpawns.push(new ArmySpawn(capital.x, capital.y, this, world.id));
                            }
                        }
                    }
                    break;
                
                case KingdomState.INVADING:
                    // Create new portal if we're targeting a specific world
                    if (this.targetWorldForInvasion) {
                        const portal = this.createPortalTo(world, this.targetWorldForInvasion);
                        if (portal) {
                            this.recentlyCreatedPortal = portal;
                            this.targetWorldForInvasion = null;
                            this.invasionCooldown = 10; // Stay in invasion mode to send troops
                        }
                    }
                    
                    // Send invasion forces through portals
                    if (this.invasionCooldown > 0) {
                        this.invasionCooldown--;
                    }
                    
                    const controlledPortals = this.getControlledPortals(world);
                    if (controlledPortals.length > 0 && this.troops > 0) {
                        // Send up to 5 armies per tick through portals
                        let armiesSent = 0;
                        for (const portal of controlledPortals) {
                            if (this.troops <= 0 || armiesSent >= 5 || this.armies.length >= 12) break;
                            
                            // Prioritize recently created portal
                            if (this.recentlyCreatedPortal && portal.id !== this.recentlyCreatedPortal.id) continue;
                            
                            if (this.sendInvasionForce(world, portal)) {
                                armiesSent++;
                            }
                        }
                        
                        // If we sent forces, stay in invasion mode a bit longer
                        if (armiesSent > 0) {
                            this.invasionCooldown = Math.max(this.invasionCooldown, 5);
                        }
                    }
                    
                    // Exit invasion state if no portals or no troops left
                    if (controlledPortals.length === 0 || this.troops === 0) {
                        if (this.invasionCooldown <= 0) {
                            this.state = KingdomState.EXPANDING;
                            this.recentlyCreatedPortal = null;
                        }
                    }
                    break;
                    
                case KingdomState.DEFENDING: 
                    // Actively defend against threats
                    // Recalculate threats for defensive action
                    const neighbors = this.getNeighbors(world);
                    const threats = this.getThreats(neighbors);
                    
                    if (threats.length > 0 && this.troops > 0) {
                        // Focus on the biggest threat
                        const primaryThreat = threats[0];
                        const defensiveTargets = this.findAllEnemyBorderTiles(world, primaryThreat);
                        
                        if (defensiveTargets.length > 0) {
                            // Filter out already targeted tiles
                            const availableDefensiveTargets = defensiveTargets.filter(tile => {
                                const tileKey = tile.x + ',' + tile.y + ',' + world.id;
                                return !this.targetedTiles[tileKey];
                            });
                            
                            const targetsToDefend = availableDefensiveTargets.length > 0 ? availableDefensiveTargets : defensiveTargets;
                            
                            // Find our best capital to launch defense from
                            let bestCapital = null;
                            let bestCapitalScore = Infinity;
                            
                            for (const capital of this.controlledCapitals) {
                                // Check if this capital is in the current world
                                if (world.tiles[capital.x] && world.tiles[capital.x][capital.y] && 
                                    world.tiles[capital.x][capital.y].owner === this.id) {
                                    
                                    // Check if capital is burned
                                    const capitalKey = capital.x + ',' + capital.y + ',' + world.id;
                                    if (game.burnedCapitals[capitalKey]) {
                                        continue; // Skip burned capitals
                                    }
                                    
                                    // Calculate average distance from this capital to all threat tiles
                                    let totalDistance = 0;
                                    for (const threatTile of targetsToDefend) {
                                        totalDistance += Math.abs(capital.x - threatTile.x) + Math.abs(capital.y - threatTile.y);
                                    }
                                    const avgDistance = totalDistance / targetsToDefend.length;
                                    
                                    if (avgDistance < bestCapitalScore) {
                                        bestCapitalScore = avgDistance;
                                        bestCapital = capital;
                                    }
                                }
                            }
                            
                            // If no valid capital found, use the main capital
                            if (!bestCapital) {
                                bestCapital = { x: this.capitalX, y: this.capitalY };
                                // But check if main capital is burned too
                                const mainCapitalKey = this.capitalX + ',' + this.capitalY + ',' + world.id;
                                if (game.burnedCapitals[mainCapitalKey]) {
                                    // Cannot spawn from any capital - all are burned
                                    break;
                                }
                            }
                            
                            // Sort targets by distance from our best capital
                            targetsToDefend.sort((a, b) => {
                                const distA = Math.abs(a.x - bestCapital.x) + Math.abs(a.y - bestCapital.y);
                                const distB = Math.abs(b.x - bestCapital.x) + Math.abs(b.y - bestCapital.y);
                                return distA - distB;
                            });
                            
                            // Send up to 3 defensive armies
                            const maxDefenders = Math.min(3, this.troops, targetsToDefend.length);
                            
                            for (let i = 0; i < maxDefenders && i < targetsToDefend.length; i++) {
                                if (this.armies.length >= 12 || this.troops <= 0) break;
                                
                                const target = targetsToDefend[i];
                                const tileKey = target.x + ',' + target.y + ',' + world.id;
                                
                                // Double-check tile isn't targeted
                                if (this.targetedTiles[tileKey]) continue;
                                
                                // Final check that spawn capital isn't burned
                                const spawnCapitalKey = bestCapital.x + ',' + bestCapital.y + ',' + world.id;
                                if (game.burnedCapitals[spawnCapitalKey]) continue;
                                
                                // Check if army can reach the target (avoid lava)
                                if (!Army.canReachTarget(world, bestCapital.x, bestCapital.y, target.x, target.y)) {
                                    console.log(`Defense army cannot reach target from (${bestCapital.x}, ${bestCapital.y}) to (${target.x}, ${target.y}) - path blocked by lava`);
                                    continue; // Skip this target
                                }
                                
                                const army = new Army(this, 1, bestCapital.x, bestCapital.y, target.x, target.y, world.id);
                                army.task = 'defend';
                                army.originalTarget = {x: target.x, y: target.y};
                                army.targetTileKey = tileKey;
                                this.targetedTiles[tileKey] = army;
                                
                                // Every 3rd army gets a banner
                                this.armyCreationCounter++;
                                if (this.armyCreationCounter % 3 === 0) {
                                    army.hasBanner = true;
                                }
                                
                                this.armies.push(army);
                                this.troops--;
                            }
                        }
                    }
                    break;
                case KingdomState.RECOVERING: if (Math.random() < 0.2) this.tryExpand(world); break;
            }
        };

        Kingdom.prototype.tryExpand = function(world) {
            var tiles = this.getExpansionTiles(world);
            if (tiles.length === 0) return;
            
            var tile = tiles[Math.floor(Math.random() * tiles.length)];
            const oldOwner = world.tiles[tile.x][tile.y].owner;
            world.tiles[tile.x][tile.y].owner = this.id;
            markTileDirty(world.id, tile.x, tile.y);
            this.territory++;
            this.territoryCount++;
            // Notify armies that this tile was captured
            notifyArmiesOfTileCapture(world, tile.x, tile.y, this.id);
            // NEW: Update borders incrementally
            updateBordersAroundTile(world, tile.x, tile.y, oldOwner, this.id);
        };

        Kingdom.prototype.tryPlaceVillage = function(world) {
            let ownedTiles = [];
            for (let x = 0; x < WORLD_SIZE; x++) {
                for (let y = 0; y < WORLD_SIZE; y++) {
                    if (world.tiles[x][y].active && world.tiles[x][y].owner === this.id) {
                        ownedTiles.push({x, y});
                    }
                }
            }
            if (ownedTiles.length < 10) return;

            const tile = ownedTiles[Math.floor(Math.random() * ownedTiles.length)];

            if (this.canPlaceVillage(tile.x, tile.y, world)) {
                const village = {x: tile.x, y: tile.y, originalOwnerId: this.id};
                this.villages.push(village);
                world.villages.push(village);
            }
        };

        Kingdom.prototype.canPlaceVillage = function(x, y, world) {
            if (world.capitals.some(c => c.x === x && c.y === y)) {
                return false;
            }
            
            const minDistanceToCapital = 3;
            const minDistanceToVillage = 5;
            const minDistanceToWitchSpire = 8;
            
            // Check distance to ALL capitals (not just controlled ones)
            for (const capital of world.capitals) {
                const distance = Math.abs(x - capital.x) + Math.abs(y - capital.y);
                if (distance < minDistanceToCapital) return false;
            }
            
            // Check distance to ALL villages from the world array
            if (world.villages) {
                for (const village of world.villages) {
                    const distance = Math.abs(x - village.x) + Math.abs(y - village.y);
                    if (distance < minDistanceToVillage) {
                        return false;
                    }
                }
            }
            
            // Check distance to witch spire in Terra
            if (world.name === 'Terra' && game.terraWitch.hasHouse) {
                const witchDist = Math.abs(x - Math.floor(game.terraWitch.houseX)) + 
                                  Math.abs(y - Math.floor(game.terraWitch.houseY));
                if (witchDist < minDistanceToWitchSpire) {
                    return false;
                }
            }
            
            return true;
        };
        
        Kingdom.prototype.getExpansionTiles = function(world) {
            var tiles = [];
            var checked = {};
            
            // NEW: Use cached border tiles instead of scanning entire world
            if (this.borderTiles.size === 0 && this.territory > 0) {
                // Border tiles not initialized - do a one-time full calculation
                this.recalculateBorders(world);
            }
            
            // Convert border tile keys back to coordinates
            for (const tileKey of this.borderTiles) {
                const [x, y] = tileKey.split(',').map(Number);
                var neighbors = getNeighborsWithCache(x, y, world.id);
                
                for (var j = 0; j < neighbors.length; j++) {
                    var n = neighbors[j];
                    var key = n.x + ',' + n.y;
                    if (!checked[key]) {
                        checked[key] = true;
                        if (world.tiles[n.x][n.y].owner === null && world.tiles[n.x][n.y].active) {
                            tiles.push({ x: n.x, y: n.y });
                        }
                    }
                }
            }
            
            return tiles;
        };
        
        // NEW: Full border recalculation (only used for initialization or recovery)
        Kingdom.prototype.recalculateBorders = function(world) {
            this.borderTiles.clear();
            
            for (var y = 0; y < WORLD_SIZE; y++) {
                for (var x = 0; x < WORLD_SIZE; x++) {
                    if (world.tiles[x][y].owner === this.id) {
                        var neighbors = getNeighborsWithCache(x, y, world.id);
                        for (var i = 0; i < neighbors.length; i++) {
                            var n = neighbors[i];
                            if (world.tiles[n.x][n.y].owner !== this.id) {
                                this.borderTiles.add(x + ',' + y);
                                break;
                            }
                        }
                    }
                }
            }
        };
        
        Kingdom.prototype.isAdjacentToKingdom = function(world, x, y) {
            var neighbors = [ {x: x+1, y: y}, {x: x-1, y: y}, {x: x, y: y+1}, {x: x, y: y-1} ];
            for (var i = 0; i < neighbors.length; i++) {
                var n = neighbors[i];
                if (n.x >= 0 && n.x < WORLD_SIZE && n.y >= 0 && n.y < WORLD_SIZE) {
                    if (world.tiles[n.x][n.y].owner === this.id) {
                        return true;
                    }
                }
            }
            return false;
        };
        
        Kingdom.prototype.generateBannerDesign = function() {
            // Use kingdom ID as seed for consistent banner generation
            const seed = this.id;
            const random = (max) => {
                const x = Math.sin(seed + max) * 10000;
                return x - Math.floor(x);
            };
            
            // Extended symbols
            const symbols = [
                'crown', 'sword', 'shield', 'star', 'dragon', 'lion', 'eagle', 'tree', 
                'sun', 'moon', 'none', 'crossed_swords', 'hammer', 'anchor', 'key',
                'rose', 'fleur_de_lis', 'heart', 'diamond', 'castle', 'star_of_david'
            ];
            const symbol = symbols[Math.floor(random(21) * symbols.length)];
            
            // Symbol color (gold, silver, or contrasting)
            const symbolColors = ['#FFD700', '#C0C0C0', '#FFFFFF', '#000000', '#8B0000', '#00008B'];
            const symbolColor = symbolColors[Math.floor(random(25) * symbolColors.length)];
            
            return {
                pattern: 'solid',
                primaryColor: this.color,
                symbol: symbol,
                symbolColor: symbolColor,
                hasBorder: random(27) > 0.6,
                borderColor: random(28) > 0.5 ? '#000000' : symbolColor
            };
        };
        
        Kingdom.prototype.generateSecondaryColor = function(primaryColor, random) {
            // Convert hex to RGB
            const hex = primaryColor.substring(1);
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            // Convert to HSL to manipulate
            const hsl = this.rgbToHsl(r, g, b);
            
            // Modify hue and lightness for contrast
            const hueShift = random(40) > 0.5 ? 180 : (random(41) > 0.5 ? 60 : -60);
            hsl.h = (hsl.h + hueShift + 360) % 360;
            hsl.l = hsl.l > 0.5 ? hsl.l - 0.2 : hsl.l + 0.2;
            
            // Convert back to RGB
            const rgb = this.hslToRgb(hsl.h, hsl.s, hsl.l);
            
            // Return as hex color
            const toHex = (n) => Math.floor(n).toString(16).padStart(2, '0');
            return '#' + toHex(rgb.r) + toHex(rgb.g) + toHex(rgb.b);
        };
        
        Kingdom.prototype.rgbToHsl = function(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            
            return { h: h * 360, s: s, l: l };
        };
        
        Kingdom.prototype.hslToRgb = function(h, s, l) {
            h /= 360;
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return { r: r * 255, g: g * 255, b: b * 255 };
        };
        
        Kingdom.prototype.getNeighbors = function(world) {
            var neighbors = {};
            
            // Use spatial index for border tiles if available
            const borderTiles = spatialIndex.kingdomBorders.get(this.id);
            if (borderTiles && borderTiles.size > 0) {
                // Fast path using spatial index
                for (const tileKey of borderTiles) {
                    const [x, y] = tileKey.split(',').map(Number);
                    const adjacent = getTileNeighbors(x, y);
                    
                    for (const a of adjacent) {
                        const tile = world.tiles[a.x][a.y];
                        if (tile.owner !== null && tile.owner !== this.id) {
                            neighbors[tile.owner] = true;
                        }
                    }
                }
            } else {
                // Fallback to full scan
                for (var y = 0; y < WORLD_SIZE; y++) {
                    for (var x = 0; x < WORLD_SIZE; x++) {
                        if (world.tiles[x][y].owner === this.id) {
                            var adjacent = getTileNeighbors(x, y);
                            for (var i = 0; i < adjacent.length; i++) {
                                var a = adjacent[i];
                                var tile = world.tiles[a.x][a.y];
                                if (tile.owner !== null && tile.owner !== this.id) {
                                    neighbors[tile.owner] = true;
                                }
                            }
                        }
                    }
                }
            }
            
            var result = [];
            for (var id in neighbors) {
                var k = world.kingdoms.find(k => k.id == id);
                if (k && k.alive) {
                    result.push(k);
                }
            }
            return result;
        };
        
        Kingdom.prototype.detectForeignInvaders = function(world) {
            // Use the event-driven foreignInvaders set
            const foreignInvaders = [];
            
            for (const invaderId of this.foreignInvaders) {
                // Find the actual kingdom
                for (let w = 0; w < worlds.length; w++) {
                    if (w !== world.id) {
                        const invader = worlds[w].kingdoms.find(k => k.id === invaderId && k.alive);
                        if (invader) {
                            foreignInvaders.push(invader);
                            break;
                        }
                    }
                }
            }
            
            return foreignInvaders;
        };
        
        Kingdom.prototype.getThreats = function(neighbors) {
            var threats = [];
            
            // Add traditional neighbor threats
            for (var i = 0; i < neighbors.length; i++) {
                var n = neighbors[i];
                if (this.enemies[n.id] && !this.truces[n.id]) {
                    threats.push(n);
                }
            }
            
            // Add foreign invaders as threats (only if they border us)
            const world = worlds[this.worldId];
            const foreignInvaders = this.detectForeignInvaders(world);
            
            for (const invader of foreignInvaders) {
                if (!this.truces[invader.id]) {
                    // Check if this foreign invader actually borders our kingdom
                    let sharesBorder = false;
                    
                    // Check all tiles to see if any invader tile is adjacent to our territory
                    for (let y = 0; y < WORLD_SIZE && !sharesBorder; y++) {
                        for (let x = 0; x < WORLD_SIZE && !sharesBorder; x++) {
                            if (world.tiles[x][y].owner === invader.id) {
                                // Check if this invader tile is adjacent to any of our tiles
                                const neighbors = [
                                    {x: x + 1, y: y}, {x: x - 1, y: y}, 
                                    {x: x, y: y + 1}, {x: x, y: y - 1}
                                ];
                                
                                for (const neighbor of neighbors) {
                                    if (neighbor.x >= 0 && neighbor.x < WORLD_SIZE && 
                                        neighbor.y >= 0 && neighbor.y < WORLD_SIZE &&
                                        world.tiles[neighbor.x][neighbor.y].owner === this.id) {
                                        sharesBorder = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Only add as threat if they actually border us
                    if (sharesBorder) {
                        threats.push(invader);
                        // Automatically mark foreign invaders as enemies
                        if (!this.enemies[invader.id]) {
                            this.enemies[invader.id] = true;
                            invader.enemies[this.id] = true;
                        }
                    }
                }
            }
            
            threats.sort((a, b) => b.troops - a.troops);
            return threats;
        };
        
        Kingdom.prototype.getOpportunities = function(neighbors, aliveKingdoms) {
            var opportunities = [];
            var requiredAdvantage = (aliveKingdoms <= 2) ? 1.05 : 1.3;

            for (var i = 0; i < neighbors.length; i++) {
                var n = neighbors[i];
                if (!this.truces[n.id] && this.troops > n.troops * requiredAdvantage) {
                    opportunities.push(n);
                }
            }
            opportunities.sort((a, b) => a.troops - b.troops);
            return opportunities;
        };
        
        Kingdom.prototype.makeTruce = function(otherKingdom, tick) {
            var truceDuration = 150 + Math.floor(Math.random() * 50); 
            this.truces[otherKingdom.id] = tick + truceDuration;
            otherKingdom.truces[this.id] = tick + truceDuration;
            delete this.enemies[otherKingdom.id];
            delete otherKingdom.enemies[this.id];
        };
        
        Kingdom.prototype.findAllEnemyBorderTiles = function(world, enemyKingdom) {
            const borderTiles = [];
            for (let x = 0; x < WORLD_SIZE; x++) {
                for (let y = 0; y < WORLD_SIZE; y++) {
                    // NEW: Check if tile is active before considering it as a target
                    if (world.tiles[x][y].active && world.tiles[x][y].owner === enemyKingdom.id) {
                        if (this.isAdjacentToKingdom(world, x, y)) {
                            borderTiles.push({ x: x, y: y });
                        }
                    }
                }
            }
            
            // Also check if we can attack through portals
            const controlledPortals = this.getControlledPortals(world);
            for (const portal of controlledPortals) {
                const portalTile = portal.worldA === world.id ? portal.tileA : portal.tileB;
                // Check if portal tile provides access to enemy territory
                if (world.tiles[portalTile.x] && world.tiles[portalTile.x][portalTile.y]) {
                    // Check adjacent tiles to the portal
                    const adjacent = [
                        {x: portalTile.x + 1, y: portalTile.y},
                        {x: portalTile.x - 1, y: portalTile.y},
                        {x: portalTile.x, y: portalTile.y + 1},
                        {x: portalTile.x, y: portalTile.y - 1}
                    ];
                    
                    for (const adj of adjacent) {
                        if (adj.x >= 0 && adj.x < WORLD_SIZE && adj.y >= 0 && adj.y < WORLD_SIZE) {
                            // NEW: Check if adjacent tile is active
                            if (world.tiles[adj.x][adj.y].active && world.tiles[adj.x][adj.y].owner === enemyKingdom.id) {
                                // This enemy tile is adjacent to our portal
                                if (!borderTiles.some(t => t.x === adj.x && t.y === adj.y)) {
                                    borderTiles.push({ x: adj.x, y: adj.y });
                                }
                            }
                        }
                    }
                }
            }
            
            return borderTiles;
        };

        // Portal and Invasion Helper Methods
        Kingdom.prototype.canCreatePortal = function(world) {
            // Must control at least one full world (all tiles)
            let controlsAnyFullWorld = false;
            
            for (let w = 0; w < worlds.length; w++) {
                let controlsThisWorld = true;
                for (let y = 0; y < WORLD_SIZE; y++) {
                    for (let x = 0; x < WORLD_SIZE; x++) {
                        if (worlds[w].tiles[x][y].active && worlds[w].tiles[x][y].owner !== this.id) {
                            controlsThisWorld = false;
                            break;
                        }
                    }
                    if (!controlsThisWorld) break;
                }
                if (controlsThisWorld) {
                    controlsAnyFullWorld = true;
                    break;
                }
            }
            
            if (!controlsAnyFullWorld) return false;
            
            // Must have enough troops
            if (this.troops < 100) return false;
            
            // Must have suitable territory for portal placement
            const portalLocation = this.findPortalLocation(world);
            return portalLocation !== null;
        };
        
        Kingdom.prototype.findPortalLocation = function(world) {
            // Find edge tiles that we own (edges of the jagged shape)
            const edgeTiles = [];
            
            // Check all tiles for edge positions
            for (let x = 0; x < WORLD_SIZE; x++) {
                for (let y = 0; y < WORLD_SIZE; y++) {
                    if (world.tiles[x][y].active && world.tiles[x][y].owner === this.id) {
                        // Check if this is an edge tile (adjacent to void or enemy)
                        let isEdge = false;
                        let edgeDir = '';
                        
                        // Check all four directions
                        if (x > 0 && !world.tiles[x - 1][y].active) {
                            isEdge = true;
                            edgeDir = 'west';
                        } else if (x < WORLD_SIZE - 1 && !world.tiles[x + 1][y].active) {
                            isEdge = true;
                            edgeDir = 'east';
                        } else if (y > 0 && !world.tiles[x][y - 1].active) {
                            isEdge = true;
                            edgeDir = 'north';
                        } else if (y < WORLD_SIZE - 1 && !world.tiles[x][y + 1].active) {
                            isEdge = true;
                            edgeDir = 'south';
                        }
                        
                        if (isEdge) {
                            edgeTiles.push({ x: x, y: y, edge: edgeDir });
                        }
                    }
                }
            }
            
            // Return a random owned edge tile, or null if none
            return edgeTiles.length > 0 ? edgeTiles[Math.floor(Math.random() * edgeTiles.length)] : null;
        };
        
        Kingdom.prototype.createPortalTo = function(world, targetWorld) {
            const sourceLocation = this.findPortalLocation(world);
            if (!sourceLocation) return null;
            
            // Calculate initial target location based on relative positions
            let targetLocation;
            const dx = targetWorld.x - world.x;
            const dy = targetWorld.y - world.y;
            const midX = Math.floor(WORLD_SIZE / 2);
            const midY = Math.floor(WORLD_SIZE / 2);
            
            // Place target portal on opposite edge
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0) { // Target is East
                    targetLocation = { x: 1, y: midY };
                } else { // Target is West
                    targetLocation = { x: WORLD_SIZE - 2, y: midY };
                }
            } else {
                if (dy > 0) { // Target is South
                    targetLocation = { x: midX, y: 1 };
                } else { // Target is North
                    targetLocation = { x: midX, y: WORLD_SIZE - 2 };
                }
            }
            
            // Ensure target location is on an active tile
            if (!targetWorld.tiles[targetLocation.x][targetLocation.y].active) {
                // Find nearest active tile, preferably owned by us
                let bestTile = null;
                let minDistance = Infinity;
                
                // Search in expanding circles from the initial target
                for (let radius = 1; radius < WORLD_SIZE && !bestTile; radius++) {
                    let candidates = [];
                    
                    for (let dx = -radius; dx <= radius; dx++) {
                        for (let dy = -radius; dy <= radius; dy++) {
                            // Only check tiles on the perimeter of the search radius
                            if (Math.abs(dx) === radius || Math.abs(dy) === radius) {
                                const checkX = targetLocation.x + dx;
                                const checkY = targetLocation.y + dy;
                                
                                if (checkX >= 0 && checkX < WORLD_SIZE && 
                                    checkY >= 0 && checkY < WORLD_SIZE &&
                                    targetWorld.tiles[checkX][checkY].active) {
                                    
                                    const distance = Math.abs(dx) + Math.abs(dy);
                                    candidates.push({
                                        x: checkX,
                                        y: checkY,
                                        distance: distance,
                                        isOurs: targetWorld.tiles[checkX][checkY].owner === this.id
                                    });
                                }
                            }
                        }
                    }
                    
                    // Prefer our tiles, then neutral, then enemy
                    candidates.sort((a, b) => {
                        if (a.isOurs && !b.isOurs) return -1;
                        if (!a.isOurs && b.isOurs) return 1;
                        return a.distance - b.distance;
                    });
                    
                    if (candidates.length > 0) {
                        bestTile = candidates[0];
                        targetLocation = { x: bestTile.x, y: bestTile.y };
                    }
                }
                
                // If still no valid tile found, portal creation fails
                if (!bestTile) {
                    return null;
                }
            }
            
            // Create the portal
            const portal = {
                id: game.portals.length,
                worldA: world.id,
                worldB: targetWorld.id,
                tileA: { x: sourceLocation.x, y: sourceLocation.y },
                tileB: targetLocation,
                ownerId: this.id,
                expiresTick: game.currentTick + 6000
            };
            
            game.portals.push(portal);
            this.troops -= 100;
            return portal;
        };
        
        Kingdom.prototype.findInvasionTarget = function(world) {
            // Find worlds we don't have portals to yet
            const potentialTargets = worlds.filter(w => {
                if (w.id === world.id) return false;
                
                // Check if portal already exists
                const portalExists = game.portals.some(p => 
                    (p.worldA === world.id && p.worldB === w.id) || 
                    (p.worldB === world.id && p.worldA === w.id)
                );
                
                return !portalExists;
            });
            
            // Return random target or null
            return potentialTargets.length > 0 ? 
                potentialTargets[Math.floor(Math.random() * potentialTargets.length)] : null;
        };
        
        Kingdom.prototype.getControlledPortals = function(world) {
            return game.portals.filter(p => {
                // Check if we own the portal
                if (p.ownerId === this.id) return true;
                
                // Check if we control the entrance tile or an ally does
                const entrance = p.worldA === world.id ? p.tileA : 
                               (p.worldB === world.id ? p.tileB : null);
                               
                if (!entrance) return false;
                
                const entranceOwner = world.tiles[entrance.x][entrance.y].owner;
                const isOwnTerritory = entranceOwner === this.id;
                const isAllyTerritory = entranceOwner !== null && 
                                       this.truces[entranceOwner] && 
                                       this.truces[entranceOwner] > game.currentTick;
                
                return isOwnTerritory || isAllyTerritory;
            });
        };
        
        Kingdom.prototype.sendInvasionForce = function(world, portal) {
            if (this.troops <= 0) return false;
            
            // Check if portal is about to expire (less than 5 seconds / 150 ticks)
            const remainingTicks = portal.expiresTick - game.currentTick;
            if (remainingTicks < 150) {
                // Portal closing soon, don't send troops
                return false;
            }
            
            const portalEntry = portal.worldA === world.id ? portal.tileA : portal.tileB;
            
            // Check if we control the portal entrance or if an ally does
            const entranceOwner = world.tiles[portalEntry.x][portalEntry.y].owner;
            const isOwnTerritory = entranceOwner === this.id;
            const isAllyTerritory = entranceOwner !== null && this.truces[entranceOwner] && this.truces[entranceOwner] > game.currentTick;
            
            if (!isOwnTerritory && !isAllyTerritory) {
                // Cannot use portal - not in own or ally territory
                return false;
            }
            
            const origin = this.findClosestStagingPoint(portalEntry.x, portalEntry.y, world.id);
            
            if (!origin) return false;
            
            // Double-check the origin capital isn't burned
            const originKey = origin.x + ',' + origin.y + ',' + world.id;
            if (game.burnedCapitals[originKey]) return false;
            
            // Check if army can reach the portal (avoid lava)
            if (!Army.canReachTarget(world, origin.x, origin.y, portalEntry.x, portalEntry.y)) {
                console.log(`Invasion army cannot reach portal from (${origin.x}, ${origin.y}) to (${portalEntry.x}, ${portalEntry.y}) - path blocked by lava`);
                return false; // Cannot spawn army
            }
            
            const army = new Army(this, 1, origin.x, origin.y, portalEntry.x, portalEntry.y, world.id);
            army.isInvading = true;
            army.portalId = portal.id;
            army.task = 'invade';
            
            // Every 3rd army gets a banner
            this.armyCreationCounter++;
            if (this.armyCreationCounter % 3 === 0) {
                army.hasBanner = true;
            }
            
            // Don't mark portal tiles as targeted since they're transitional
            this.armies.push(army);
            this.troops--;
            
            // Spawn visual effect
            game.armySpawns.push(new ArmySpawn(origin.x, origin.y, this, world.id));
            
            return true;
        };
        Kingdom.prototype.findClosestStagingPoint = function(targetX, targetY, worldId) {
            let validCapitals = this.controlledCapitals;
            
            // If worldId is specified, only consider capitals in that world
            if (worldId !== undefined) {
                validCapitals = this.controlledCapitals.filter(capital => {
                    // Check if this capital exists in the specified world
                    const world = worlds[worldId];
                    if (!world) return false;
                    
                    // Check if capital is burned
                    const capitalKey = capital.x + ',' + capital.y + ',' + worldId;
                    if (game.burnedCapitals[capitalKey]) {
                        return false; // Exclude burned capitals
                    }
                    
                    // Verify the capital tile is owned by this kingdom in that world
                    return world.tiles[capital.x] && 
                           world.tiles[capital.x][capital.y] && 
                           world.tiles[capital.x][capital.y].owner === this.id;
                });
            }
            
            // If no valid capitals in the specified world, return null
            if (validCapitals.length === 0) return null;
            
            let bestPoint = validCapitals[0];
            let minDistance = Infinity;

            for (const capital of validCapitals) {
                const distance = Math.abs(capital.x - targetX) + Math.abs(capital.y - targetY);
                if (distance < minDistance) {
                    minDistance = distance;
                    bestPoint = capital;
                }
            }
            return bestPoint;
        };
        
        Kingdom.prototype.resolveArmyArrival = function(world, army) {
            // Handle armies returning to capital
            if (army.task === 'return') {
                this.troops++;
                army.alive = false;
                army.cleanupOnDeath(world);
                return;
            }
            
            // Handle portal transit for invading armies
            if (army.isInvading && army.task === 'invade') {
                const portal = game.portals.find(p => p.id === army.portalId);
                if (!portal) {
                    army.alive = false;
                    army.cleanupOnDeath(world);
                    return;
                }
                
                // Check if we still control the portal entrance or an ally does
                const portalEntry = army.worldId === portal.worldA ? portal.tileA : portal.tileB;
                const entranceOwner = world.tiles[portalEntry.x][portalEntry.y].owner;
                const isOwnTerritory = entranceOwner === this.id;
                const isAllyTerritory = entranceOwner !== null && 
                                       this.truces[entranceOwner] && 
                                       this.truces[entranceOwner] > game.currentTick;
                
                if (!isOwnTerritory && !isAllyTerritory) {
                    // Lost control of portal entrance - army returns to troops
                    this.troops++;
                    army.alive = false;
                    army.cleanupOnDeath(world);
                    return;
                }
                
                // Transit through portal
                const exitInfo = army.worldId === portal.worldA ? 
                    { worldId: portal.worldB, tile: portal.tileB } : 
                    { worldId: portal.worldA, tile: portal.tileA };
                    
                army.worldId = exitInfo.worldId;
                army.currentX = exitInfo.tile.x;
                army.currentY = exitInfo.tile.y;
                army.targetX = exitInfo.tile.x;
                army.targetY = exitInfo.tile.y;
                army.isInvading = false;
                army.hasCrossedPortal = true;
                army.task = 'establishBeachhead';
                army.path = army.calculatePath();
                army.pathIndex = 0;
                army.moveProgress = 0;
                return;
            }

            // Handle beachhead establishment
            if (army.task === 'establishBeachhead') {
                const tile = world.tiles[army.targetX][army.targetY];
                const previousOwner = tile.owner;
                
                // Capture the portal tile
                tile.owner = this.id;
                this.territory++;
                this.territoryCount++;
                // Notify armies that this tile was captured
                notifyArmiesOfTileCapture(world, army.targetX, army.targetY, this.id);
                // NEW: Update borders incrementally
                updateBordersAroundTile(world, army.targetX, army.targetY, previousOwner, this.id);
                
                // Check if this is a capital position
                if (world.capitals.some(c => c.x === army.targetX && c.y === army.targetY)) {
                    if (!this.controlledCapitals.some(c => c.x === army.targetX && c.y === army.targetY)) {
                        this.controlledCapitals.push({ x: army.targetX, y: army.targetY });
                    }
                }
                
                // Mark this as a beachhead for strategic importance
                army.beachheadX = army.targetX;
                army.beachheadY = army.targetY;
                
                // Find nearest enemy to attack
                let nearestEnemy = null;
                let minDistance = Infinity;
                
                // Check all kingdoms with territory in this world
                const enemiesInWorld = new Set();
                
                for (let y = 0; y < WORLD_SIZE; y++) {
                    for (let x = 0; x < WORLD_SIZE; x++) {
                        const ownerId = world.tiles[x][y].owner;
                        if (ownerId !== null && ownerId !== this.id) {
                            enemiesInWorld.add(ownerId);
                        }
                    }
                }
                
                // Find the closest enemy territory
                let closestEnemyTile = null;
                for (let y = 0; y < WORLD_SIZE; y++) {
                    for (let x = 0; x < WORLD_SIZE; x++) {
                        if (enemiesInWorld.has(world.tiles[x][y].owner)) {
                            const dist = Math.abs(x - army.targetX) + Math.abs(y - army.targetY);
                            if (dist < minDistance) {
                                minDistance = dist;
                                closestEnemyTile = { x, y };
                                nearestEnemy = world.tiles[x][y].owner;
                            }
                        }
                    }
                }
                
                // Attack nearest enemy
                if (closestEnemyTile && nearestEnemy) {
                    // Find the actual kingdom object
                    let targetKingdom = world.kingdoms.find(k => k.id === nearestEnemy && k.alive);
                    if (!targetKingdom) {
                        // Search in other worlds
                        for (let w = 0; w < worlds.length; w++) {
                            targetKingdom = worlds[w].kingdoms.find(k => k.id === nearestEnemy && k.alive);
                            if (targetKingdom) break;
                        }
                    }
                    
                    if (targetKingdom) {
                        const borderTiles = this.findAllEnemyBorderTiles(world, targetKingdom);
                        if (borderTiles.length > 0) {
                            // Attack closest border tile
                            borderTiles.sort((a, b) => {
                                const distA = Math.abs(a.x - army.beachheadX) + Math.abs(a.y - army.beachheadY);
                                const distB = Math.abs(b.x - army.beachheadX) + Math.abs(b.y - army.beachheadY);
                                return distA - distB;
                            });
                            
                            const target = borderTiles[0];
                            const targetKey = target.x + ',' + target.y + ',' + world.id;
                            army.targetX = target.x;
                            army.targetY = target.y;
                            army.originalTarget = { x: target.x, y: target.y };
                            army.targetTileKey = targetKey;
                            this.targetedTiles[targetKey] = army;
                            army.path = army.calculatePath();
                            army.pathIndex = 0;
                            army.moveProgress = 0;
                            army.task = 'attack';
                            return;
                        }
                    }
                }
                
                // No enemies found, convert back to troops
                this.troops++;
                army.alive = false;
                army.cleanupOnDeath(world);
                return;
            }

            // Standard arrival handling
            var tile = world.tiles[army.targetX][army.targetY];
            if (tile.owner === this.id) {
                // Already own this tile, might need to retarget
                if (army.task === 'attack' || army.task === 'defend') {
                    // Find new target using improved retargeting logic
                    const enemies = world.kingdoms.filter(k => k.alive && k.id !== this.id && !this.truces[k.id]);
                    if (enemies.length > 0) {
                        let allTargets = [];
                        enemies.forEach(enemy => {
                            allTargets.push(...this.findAllEnemyBorderTiles(world, enemy));
                        });
                        
                        if (allTargets.length > 0) {
                            allTargets.sort((a, b) => {
                                const distA = Math.abs(a.x - army.currentX) + Math.abs(a.y - army.currentY);
                                const distB = Math.abs(b.x - army.currentX) + Math.abs(b.y - army.currentY);
                                return distA - distB;
                            });
                            
                            const newTarget = allTargets[0];
                            army.targetX = newTarget.x;
                            army.targetY = newTarget.y;
                            army.path = army.calculatePath();
                            army.pathIndex = 0;
                            army.moveProgress = 0;
                            return;
                        }
                    }
                }
                
                // No valid targets, return to troop pool
                this.troops++;
                army.alive = false;
                army.cleanupOnDeath(world);
                return;
            }

            // Battle resolution
            game.battles.push(new Battle(army.targetX, army.targetY, world.id));
            var oldOwnerId = tile.owner;
            var defender = oldOwnerId !== null ? world.kingdoms.find(k => k.id === oldOwnerId) : null;
            
            // If defender not found in current world, check other worlds (foreign kingdom)
            if (!defender && oldOwnerId !== null) {
                for (let w = 0; w < worlds.length; w++) {
                    defender = worlds[w].kingdoms.find(k => k.id === oldOwnerId && k.alive);
                    if (defender) break;
                }
            }

            if (defender) {
                defender.territory--;
                
                // Check if this tile has a burned capital or village - transfer burn state
                const tileKey = army.targetX + ',' + army.targetY + ',' + world.id;
                if (game.burnedCapitals[tileKey]) {
                    // This is a burned capital being captured - keep it burned
                    // The burn timer continues unchanged
                }
                if (game.burnedVillages[tileKey]) {
                    // This is a burned village being captured - keep it burned
                    // The burn timer continues unchanged
                }
                
                // Transfer village ownership in kingdom arrays
                const capturedVillage = defender.villages.find(v => v.x === army.targetX && v.y === army.targetY);
                if (capturedVillage) {
                    defender.villages = defender.villages.filter(v => v.x !== army.targetX || v.y !== army.targetY);
                    this.villages.push({ x: army.targetX, y: army.targetY });
                }
                
                // Check if this is a capital position (either controlled by defender or in world capitals)
                let isCapitalPosition = false;
                let isDefenderOriginalCapital = false;
                
                // Check defender's controlled capitals
                const capturedCapital = defender.controlledCapitals.find(c => c.x === army.targetX && c.y === army.targetY);
                if (capturedCapital) {
                    isCapitalPosition = true;
                    isDefenderOriginalCapital = (defender.capitalX === army.targetX && defender.capitalY === army.targetY);
                }
                
                // Also check if this position is in the world's capital list (cross-world conquest)
                if (!isCapitalPosition && world.capitals.some(c => c.x === army.targetX && c.y === army.targetY)) {
                    isCapitalPosition = true;
                }
                
                if (isCapitalPosition) {
                    if (isDefenderOriginalCapital) {
                        this.shatterKingdom(world, defender);
                    } else { 
                        // Remove from defender if they had it
                        if (capturedCapital) {
                            defender.controlledCapitals = defender.controlledCapitals.filter(c => c.x !== army.targetX || c.y !== army.targetY);
                        }
                        // Add to attacker's controlled capitals
                        if (!this.controlledCapitals.some(c => c.x === army.targetX && c.y === army.targetY)) {
                            this.controlledCapitals.push({ x: army.targetX, y: army.targetY });
                            console.log(`Kingdom ${this.name} captured capital at (${army.targetX}, ${army.targetY}). Now has ${this.controlledCapitals.length} capitals.`);
                        }
                    }
                }
            } else {
                // No defender, but check if this is a capital position
                if (world.capitals.some(c => c.x === army.targetX && c.y === army.targetY)) {
                    // Add to attacker's controlled capitals
                    if (!this.controlledCapitals.some(c => c.x === army.targetX && c.y === army.targetY)) {
                        this.controlledCapitals.push({ x: army.targetX, y: army.targetY });
                    }
                }
            }
            
            const oldOwner = tile.owner;
            tile.owner = this.id;
            this.territory++;
            this.territoryCount++;
            // Notify armies that this tile was captured
            notifyArmiesOfTileCapture(world, army.targetX, army.targetY, this.id);
            // NEW: Update borders incrementally
            updateBordersAroundTile(world, army.targetX, army.targetY, oldOwner, this.id);
            army.alive = false;
            army.cleanupOnDeath(world);
        };

        Kingdom.prototype.shatterKingdom = function(world, defender) {
            const attacker = this;
            
            attacker.controlledCapitals.push({ x: defender.capitalX, y: defender.capitalY });
            console.log(`Kingdom ${attacker.name} conquered ${defender.name}. Attacker now has ${attacker.controlledCapitals.length} capitals.`);
            
            defender.alive = false;
            defender.deathTick = game.currentTick; // Track death time for cleanup
            
            // Immediately clear tile ownership for conquered kingdom
            for (let x = 0; x < WORLD_SIZE; x++) {
                for (let y = 0; y < WORLD_SIZE; y++) {
                    if (world.tiles[x][y].owner === defender.id) {
                        world.tiles[x][y].owner = null;
                        markTileDirty(world.id, x, y);
                    }
                }
            }
            
            // Create defeat animation at defender's capital
            const defeatIso = worldToIsometric(defender.capitalX, defender.capitalY);
            game.divineEffects.push(new KingdomDefeatEffect(
                defeatIso.x, 
                defeatIso.y, 
                world.id, 
                defender.color, 
                defender.name
            ));
            
            // Create victory animation at attacker's closest capital
            const attackerCapitalInWorld = attacker.controlledCapitals.find(c => 
                world.tiles[c.x] && world.tiles[c.x][c.y] && 
                world.tiles[c.x][c.y].owner === attacker.id
            ) || { x: attacker.capitalX, y: attacker.capitalY };
            
            const victoryIso = worldToIsometric(attackerCapitalInWorld.x, attackerCapitalInWorld.y);
            game.divineEffects.push(new VictoryEffect(
                victoryIso.x, 
                victoryIso.y, 
                world.id, 
                attacker.color, 
                attacker.name
            ));

            const successorCapitals = defender.controlledCapitals.filter(c => c.x !== defender.capitalX || c.y !== defender.capitalY);
            const newKingdoms = [];

            for (const capital of successorCapitals) {
                const newKingdomId = world.kingdoms.length;
                const newName = "Rebels of " + defender.name;
                const newKingdom = new Kingdom(newKingdomId, newName, generateKingdomColor(), capital.x, capital.y, world.id);
                newKingdom.troops = 10;
                // Ensure the new kingdom has its capital in controlledCapitals
                newKingdom.controlledCapitals = [{ x: capital.x, y: capital.y }];
                world.kingdoms.push(newKingdom);
                newKingdoms.push(newKingdom);
            }

            const deadKingdomTiles = [];
            for (let y = 0; y < WORLD_SIZE; y++) {
                for (let x = 0; x < WORLD_SIZE; x++) {
                    if (world.tiles[x][y].owner === defender.id) {
                        deadKingdomTiles.push(world.tiles[x][y]);
                    }
                }
            }

            const potentialHeirs = [...newKingdoms, attacker];
            for (const tile of deadKingdomTiles) {
                let minDistance = Infinity;
                let newOwner = null;
                
                for (const kingdom of potentialHeirs) {
                    for (const capital of kingdom.controlledCapitals) {
                        const distance = Math.abs(tile.x - capital.x) + Math.abs(tile.y - capital.y);
                        if (distance < minDistance) {
                            minDistance = distance;
                            newOwner = kingdom;
                        }
                    }
                }
                
                if (newOwner) {
                    const oldOwner = world.tiles[tile.x][tile.y].owner;
                    world.tiles[tile.x][tile.y].owner = newOwner.id;
                    newOwner.territory++;
                    newOwner.territoryCount++;
                    // NEW: Update borders incrementally
                    updateBordersAroundTile(world, tile.x, tile.y, oldOwner, newOwner.id);
                } else {
                    const oldOwner = world.tiles[tile.x][tile.y].owner;
                    world.tiles[tile.x][tile.y].owner = null;
                    markTileDirty(world.id, tile.x, tile.y);
                    // NEW: Update borders incrementally
                    updateBordersAroundTile(world, tile.x, tile.y, oldOwner, null);
                }
            }

            defender.territory = 0;
            defender.territoryCount = 0;
            defender.troops = 0;
            
            // Redistribute villages to new owners based on tile ownership
            if (defender.villages && defender.villages.length > 0) {
                defender.villages.forEach(village => {
                    const newOwner = world.tiles[village.x][village.y].owner;
                    if (newOwner !== null && newOwner !== defender.id) {
                        // Find the kingdom that now owns this tile
                        let newOwnerKingdom = world.kingdoms.find(k => k.id === newOwner && k.alive);
                        if (!newOwnerKingdom) {
                            // Check other worlds if it's a foreign kingdom
                            for (let w = 0; w < worlds.length; w++) {
                                newOwnerKingdom = worlds[w].kingdoms.find(k => k.id === newOwner && k.alive);
                                if (newOwnerKingdom) break;
                            }
                        }
                        
                        if (newOwnerKingdom && !newOwnerKingdom.villages.some(v => v.x === village.x && v.y === village.y)) {
                            newOwnerKingdom.villages.push({ x: village.x, y: village.y });
                        }
                    }
                });
                // Clear defender's villages
                defender.villages = [];
            }
            
            // Check if attacker now controls the entire world
            let controlsAllTiles = true;
            for (let y = 0; y < WORLD_SIZE; y++) {
                for (let x = 0; x < WORLD_SIZE; x++) {
                    if (world.tiles[x][y].owner !== attacker.id) {
                        controlsAllTiles = false;
                        break;
                    }
                }
                if (!controlsAllTiles) break;
            }
            
            if (controlsAllTiles) {
                attacker.worldConqueror = true;
            }
        };
        

        
        Kingdom.prototype.generateTempleRequest = function(world, fromCapital) {
            var neighbors = this.getNeighbors(world);
            var threats = this.getThreats(neighbors);
            
            // Use provided capital or default to original capital
            const requestCapital = fromCapital || { x: this.capitalX, y: this.capitalY };
            
            var type, target, location;
            const rand = Math.random();
            
            // Build list of available request types based on unlocked abilities
            const availableTypes = [];
            
            // Always available (smite is always unlocked)
            availableTypes.push('attack');
            
            // Check unlocked abilities
            if (game.abilities.bless && game.abilities.bless.unlocked) {
                availableTypes.push('blessing');
            }
            if (game.abilities.peace && game.abilities.peace.unlocked) {
                availableTypes.push('peace');
            }
            if (game.abilities.portal && game.abilities.portal.unlocked) {
                availableTypes.push('portal');
            }
            
            // Check various conditions for request types
            const hasLowElevationTiles = this.checkForLowElevationTiles(world);
            const needsPortal = this.checkNeedForPortal(world);
            const underThreat = threats.length > 0;
            const atWar = this.isAtWar();
            
            // Determine request based on conditions and available abilities
            if (underThreat && rand < 0.4) {
                // Under threat - request attack
                type = 'attack';
                target = threats[0];
            } else if (atWar && rand < 0.5 && availableTypes.includes('peace')) {
                // At war - might request peace (if unlocked)
                type = 'peace';
                target = this.getWarOpponent(world);
            } else if (needsPortal && rand < 0.7 && availableTypes.includes('portal')) {
                // Disconnected territory - request portal (if unlocked)
                type = 'portal';
                location = this.findDisconnectedTerritory(world);
                target = null;
            } else if (neighbors.length > 0 && rand < 0.8) {
                // Has neighbors - might request alliance or attack
                const friendlyNeighbor = neighbors.find(n => !this.isAtWarWith(n.id));
                const hostileNeighbor = neighbors.find(n => this.isAtWarWith(n.id));
                
                if (hostileNeighbor && Math.random() < 0.6) {
                    // If we have hostile neighbors, prioritize attacking them
                    type = 'attack';
                    target = hostileNeighbor;
                } else if (friendlyNeighbor && Math.random() < 0.3 && availableTypes.includes('peace')) {
                    type = 'peace';  // Request alliance (if unlocked)
                    target = friendlyNeighbor;
                } else if (availableTypes.includes('blessing')) {
                    type = 'blessing';
                    target = null;
                } else if (hostileNeighbor) {
                    // Fall back to attack request against hostile neighbor
                    type = 'attack';
                    target = hostileNeighbor;
                } else {
                    // Only target random neighbor for attack if no other options
                    type = 'attack';
                    // Find the strongest neighbor to attack
                    const strongestNeighbor = neighbors.reduce((strongest, neighbor) => {
                        if (!strongest) return neighbor;
                        return neighbor.territories > strongest.territories ? neighbor : strongest;
                    }, null);
                    target = strongestNeighbor || neighbors[Math.floor(Math.random() * neighbors.length)];
                }
            } else if (availableTypes.includes('blessing')) {
                // Default blessing request (if unlocked)
                type = 'blessing';
                target = null;
            } else {
                // Fall back to attack requests if nothing else available
                if (neighbors.length > 0) {
                    // Look for hostile neighbors first
                    const hostileNeighbor = neighbors.find(n => this.isAtWarWith(n.id));
                    if (hostileNeighbor) {
                        type = 'attack';
                        target = hostileNeighbor;
                    } else {
                        // No hostile neighbors, target the strongest
                        type = 'attack';
                        const strongestNeighbor = neighbors.reduce((strongest, neighbor) => {
                            if (!strongest) return neighbor;
                            return neighbor.territories > strongest.territories ? neighbor : strongest;
                        }, null);
                        target = strongestNeighbor || neighbors[Math.floor(Math.random() * neighbors.length)];
                    }
                } else {
                    // No neighbors, just request blessing if available
                    type = availableTypes.includes('blessing') ? 'blessing' : null;
                    target = null;
                    
                    // If no blessing available and no neighbors, don't create a request
                    if (!type) {
                        return;
                    }
                }
            }
            
            const request = new TempleRequest(this, type, target, requestCapital);
            if (location) request.location = location;
            this.templeRequests.push(request);
        };
        
        // Helper functions for request generation
        Kingdom.prototype.checkForLowElevationTiles = function(world) {
            for (let x = 0; x < WORLD_SIZE; x++) {
                for (let y = 0; y < WORLD_SIZE; y++) {
                    const tile = world.tiles[x][y];
                    if (tile && tile.active && tile.owner === this.id && tile.elevation < 2) {
                        return true;
                    }
                }
            }
            return false;
        };
        
        Kingdom.prototype.findLowElevationTile = function(world) {
            const lowTiles = [];
            for (let x = 0; x < WORLD_SIZE; x++) {
                for (let y = 0; y < WORLD_SIZE; y++) {
                    const tile = world.tiles[x][y];
                    if (tile && tile.active && tile.owner === this.id && tile.elevation < 2) {
                        lowTiles.push({x, y});
                    }
                }
            }
            return lowTiles.length > 0 ? lowTiles[Math.floor(Math.random() * lowTiles.length)] : null;
        };
        
        Kingdom.prototype.checkNeedForPortal = function(world) {
            // Check if kingdom has disconnected territories
            const visited = new Set();
            const queue = [{x: this.capitalX, y: this.capitalY}];
            visited.add(this.capitalX + ',' + this.capitalY);
            
            while (queue.length > 0) {
                const pos = queue.shift();
                const neighbors = getNeighborsWithCache(pos.x, pos.y, world.id);
                for (const neighbor of neighbors) {
                    const key = neighbor.x + ',' + neighbor.y;
                    const tile = world.tiles[neighbor.x][neighbor.y];
                    if (tile && tile.owner === this.id && !visited.has(key)) {
                        visited.add(key);
                        queue.push(neighbor);
                    }
                }
            }
            
            // Count total owned tiles
            let totalOwned = 0;
            for (let x = 0; x < WORLD_SIZE; x++) {
                for (let y = 0; y < WORLD_SIZE; y++) {
                    if (world.tiles[x][y] && world.tiles[x][y].owner === this.id) {
                        totalOwned++;
                    }
                }
            }
            
            return visited.size < totalOwned * 0.9; // Has disconnected territory
        };
        
        Kingdom.prototype.findDisconnectedTerritory = function(world) {
            // Find a tile that's owned but not connected to capital
            const connected = new Set();
            const queue = [{x: this.capitalX, y: this.capitalY}];
            connected.add(this.capitalX + ',' + this.capitalY);
            
            while (queue.length > 0) {
                const pos = queue.shift();
                const neighbors = getNeighborsWithCache(pos.x, pos.y, world.id);
                for (const neighbor of neighbors) {
                    const key = neighbor.x + ',' + neighbor.y;
                    const tile = world.tiles[neighbor.x][neighbor.y];
                    if (tile && tile.owner === this.id && !connected.has(key)) {
                        connected.add(key);
                        queue.push(neighbor);
                    }
                }
            }
            
            // Find disconnected tiles
            for (let x = 0; x < WORLD_SIZE; x++) {
                for (let y = 0; y < WORLD_SIZE; y++) {
                    const tile = world.tiles[x][y];
                    const key = x + ',' + y;
                    if (tile && tile.owner === this.id && !connected.has(key)) {
                        return {x, y};
                    }
                }
            }
            return {x: this.capitalX + 10, y: this.capitalY}; // Default far location
        };
        
        Kingdom.prototype.isAtWar = function() {
            // Check if this kingdom is involved in any active wars
            for (const warPair of game.activeWars) {
                if (warPair.attacker === this.id || warPair.defender === this.id) {
                    return true;
                }
            }
            return false;
        };
        
        Kingdom.prototype.isAtWarWith = function(kingdomId) {
            // Check if this kingdom is at war with a specific kingdom
            // First check natural enemies
            if (this.enemies && this.enemies[kingdomId]) {
                return true;
            }
            
            // Also check divine wars
            for (const warPair of game.activeWars) {
                if ((warPair.attacker === this.id && warPair.defender === kingdomId) ||
                    (warPair.defender === this.id && warPair.attacker === kingdomId)) {
                    return true;
                }
            }
            return false;
        };
        
        Kingdom.prototype.getWarOpponent = function(world) {
            // Get kingdom we're at war with
            for (const warPair of game.activeWars) {
                if (warPair.attacker === this.id) {
                    return world.kingdoms.find(k => k.id === warPair.defender);
                } else if (warPair.defender === this.id) {
                    return world.kingdoms.find(k => k.id === warPair.attacker);
                }
            }
            return null;
        };
        
        // Static method to check if a valid path exists before creating an army
        Army.canReachTarget = function(world, fromX, fromY, targetX, targetY) {
            // Early exit for same position
            if (Math.floor(fromX) === targetX && Math.floor(fromY) === targetY) {
                return true;
            }
            
            // Use simplified A* to check if path exists
            const openSet = [];
            const closedSet = new Set();
            const startKey = `${Math.floor(fromX)},${Math.floor(fromY)}`;
            const goalKey = `${targetX},${targetY}`;
            
            openSet.push(startKey);
            
            while (openSet.length > 0) {
                const current = openSet.shift();
                
                if (current === goalKey) {
                    return true; // Path exists
                }
                
                closedSet.add(current);
                
                const [cx, cy] = current.split(',').map(Number);
                const neighbors = [
                    {x: cx + 1, y: cy},
                    {x: cx - 1, y: cy},
                    {x: cx, y: cy + 1},
                    {x: cx, y: cy - 1}
                ];
                
                for (const neighbor of neighbors) {
                    if (neighbor.x < 0 || neighbor.x >= WORLD_SIZE || 
                        neighbor.y < 0 || neighbor.y >= WORLD_SIZE) {
                        continue;
                    }
                    
                    const neighborTile = world.tiles[neighbor.x][neighbor.y];
                    if (!neighborTile.active || neighborTile.isLava) {
                        continue; // Skip inactive/air tiles and lava tiles
                    }
                    
                    const neighborKey = `${neighbor.x},${neighbor.y}`;
                    if (!closedSet.has(neighborKey) && !openSet.includes(neighborKey)) {
                        openSet.push(neighborKey);
                    }
                }
                
                // Safety check
                if (closedSet.size > WORLD_SIZE * WORLD_SIZE / 4) {
                    return false; // Too many iterations, probably no path
                }
            }
            
            return false; // No path found
        };
        
        function Army(kingdom, size, fromX, fromY, targetX, targetY, worldId) {
            this.kingdom = kingdom;
            this.worldId = worldId;
            this.size = size;
            this.currentX = fromX;
            this.currentY = fromY;
            this.targetX = targetX;
            this.targetY = targetY;
            this.path = this.calculatePath();
            this.pathIndex = 0;
            this.moveProgress = 0;
            this.speed = 0.04; // Increased to match visual speed of recruits
            this.alive = true;
            this.isInvading = false;
            this.hasCrossedPortal = false;
            this.task = 'none';
            this.targetTileKey = null; // Track which tile this army is targeting
            this.hasBanner = false; // Track if this army carries a banner
            this.createdAt = game.currentTick; // Track when army was created for fish tracking
            
            // Route recording for Ignis shadows
            this.routeHistory = [{x: fromX, y: fromY, tick: game.currentTick}];
            this.lastRecordedTick = game.currentTick;
            
            // Initialize in spatial index
            updateEntityChunk(this, worldId);
            
            // Check if starting in foreign territory
            const world = worlds[worldId];
            if (world) {
                const startTile = world.tiles[Math.floor(fromX)][Math.floor(fromY)];
                if (startTile.owner !== null && startTile.owner !== kingdom.id) {
                    // Check if this army's kingdom is from another world
                    const isNative = world.kingdoms.some(k => k.id === kingdom.id);
                    if (!isNative) {
                        // This is a foreign army starting in someone's territory
                        const ownerKingdom = world.kingdoms.find(k => k.id === startTile.owner && k.alive);
                        if (ownerKingdom) {
                            ownerKingdom.foreignInvaders.add(kingdom.id);
                        }
                    }
                }
            }
        }
        
        // Path cache for armies
        var pathCache = new Map(); // Key: "fromX,fromY,toX,toY" Value: path array
        var pathCacheHits = 0;
        var pathCacheMisses = 0;
        
        Army.prototype.calculatePath = function() {
            // Create cache key including worldId for accuracy
            const cacheKey = `${this.currentX},${this.currentY},${this.targetX},${this.targetY},${this.worldId}`;
            
            // Check cache first
            if (pathCache.has(cacheKey)) {
                pathCacheHits++;
                return pathCache.get(cacheKey).slice(); // Return copy of cached path
            }
            
            pathCacheMisses++;
            
            // Get the world for tile checking
            const world = worlds[this.worldId];
            if (!world) {
                console.warn('Invalid world ID:', this.worldId);
                return [];
            }
            
            // Early exit for same position
            if (this.currentX === this.targetX && this.currentY === this.targetY) {
                return [];
            }
            
            // NEW: A* pathfinding that avoids inactive tiles
            const openSet = [];
            const closedSet = new Set();
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();
            
            const startKey = `${Math.floor(this.currentX)},${Math.floor(this.currentY)}`;
            const goalKey = `${this.targetX},${this.targetY}`;
            
            openSet.push(startKey);
            gScore.set(startKey, 0);
            fScore.set(startKey, this.heuristic(Math.floor(this.currentX), Math.floor(this.currentY), this.targetX, this.targetY));
            
            while (openSet.length > 0) {
                // Get node with lowest fScore
                let current = openSet[0];
                let currentIndex = 0;
                for (let i = 1; i < openSet.length; i++) {
                    if (fScore.get(openSet[i]) < fScore.get(current)) {
                        current = openSet[i];
                        currentIndex = i;
                    }
                }
                
                // Check if we reached the goal
                if (current === goalKey) {
                    // Reconstruct path
                    const path = [];
                    let temp = current;
                    while (cameFrom.has(temp)) {
                        const [x, y] = temp.split(',').map(Number);
                        path.unshift({x, y});
                        temp = cameFrom.get(temp);
                    }
                    
                    // Cache the path
                    if (pathCache.size > 1000) {
                        const firstKey = pathCache.keys().next().value;
                        pathCache.delete(firstKey);
                    }
                    pathCache.set(cacheKey, path);
                    
                    return path;
                }
                
                // Move current from open to closed
                openSet.splice(currentIndex, 1);
                closedSet.add(current);
                
                // Check neighbors
                const [cx, cy] = current.split(',').map(Number);
                const neighbors = [
                    {x: cx + 1, y: cy},
                    {x: cx - 1, y: cy},
                    {x: cx, y: cy + 1},
                    {x: cx, y: cy - 1}
                ];
                
                for (const neighbor of neighbors) {
                    // Check bounds
                    if (neighbor.x < 0 || neighbor.x >= WORLD_SIZE || 
                        neighbor.y < 0 || neighbor.y >= WORLD_SIZE) {
                        continue;
                    }
                    
                    // NEW: Check if tile is active (not air) and not lava
                    const neighborTile = world.tiles[neighbor.x][neighbor.y];
                    if (!neighborTile.active || neighborTile.isLava) {
                        continue; // Skip inactive/air tiles and lava tiles
                    }
                    
                    const neighborKey = `${neighbor.x},${neighbor.y}`;
                    if (closedSet.has(neighborKey)) {
                        continue;
                    }
                    
                    const tentativeGScore = gScore.get(current) + 1;
                    
                    if (!openSet.includes(neighborKey)) {
                        openSet.push(neighborKey);
                    } else if (tentativeGScore >= gScore.get(neighborKey)) {
                        continue;
                    }
                    
                    // This path is the best so far
                    cameFrom.set(neighborKey, current);
                    gScore.set(neighborKey, tentativeGScore);
                    fScore.set(neighborKey, tentativeGScore + this.heuristic(neighbor.x, neighbor.y, this.targetX, this.targetY));
                }
                
                // Safety check to prevent infinite loops
                if (closedSet.size > WORLD_SIZE * WORLD_SIZE) {
                    console.warn('Pathfinding exceeded maximum iterations');
                    break;
                }
            }
            
            // No path found - fallback to simple direct path if target is unreachable
            console.warn('No path found from', this.currentX, this.currentY, 'to', this.targetX, this.targetY);
            return [];
        };
        
        // Heuristic function for A* (Manhattan distance)
        Army.prototype.heuristic = function(x1, y1, x2, y2) {
            return manhattanDistance(x1, y1, x2, y2);
        };
        
        Army.prototype.update = function(world) {
            if (!this.alive) return;
            
            // Handle messenger armies
            if (this.task === 'messenger') {
                // Check if the request still exists
                if (!this.request || !this.kingdom.templeRequests.includes(this.request)) {
                    // Request completed or cancelled, return home
                    if (!this.isReturning) {
                        this.isReturning = true;
                        this.targetX = this.returnTarget.x;
                        this.targetY = this.returnTarget.y;
                        this.path = this.calculatePath();
                        this.pathIndex = 0;
                        this.moveProgress = 0;
                    }
                }
                
                // Check if we've reached our destination
                const currentPos = this.getPosition();
                const distToTarget = Math.sqrt(
                    Math.pow(currentPos.x - this.targetX, 2) + 
                    Math.pow(currentPos.y - this.targetY, 2)
                );
                
                if (distToTarget < 1) {
                    if (this.isReturning) {
                        // Reached home, dissolve the army
                        this.kingdom.troops += this.size;
                        this.alive = false;
                        // Clear the messenger reference so a new one can be spawned
                        if (this.request && this.request.messengerArmy === this) {
                            this.request.messengerArmy = null;
                        }
                        return;
                    } else {
                        // Reached pointing location, start pointing
                        this.pointingTimer++;
                        if (this.pointingTimer >= this.maxPointingTime) {
                            // Done pointing, return home
                            this.isReturning = true;
                            this.targetX = this.returnTarget.x;
                            this.targetY = this.returnTarget.y;
                            this.path = this.calculatePath();
                            this.pathIndex = 0;
                            this.moveProgress = 0;
                        }
                        return; // Don't move while pointing
                    }
                }
            }
            
            // Check if heading to a portal that no longer exists or is about to close
            if (this.isInvading && this.portalId !== undefined) {
                const portal = game.portals.find(p => p.id === this.portalId);
                if (!portal || portal.expiresTick - game.currentTick < 30) {
                    // Portal gone or closing - return to nearest capital
                    const nearestCapital = this.kingdom.findClosestStagingPoint(this.currentX, this.currentY, this.worldId);
                    if (nearestCapital) {
                        this.targetX = nearestCapital.x;
                        this.targetY = nearestCapital.y;
                        this.isInvading = false;
                        this.task = 'return';
                        this.portalId = undefined;
                        this.path = this.calculatePath();
                        this.pathIndex = 0;
                        this.moveProgress = 0;
                    } else {
                        // No valid capital - convert back to troops
                        this.kingdom.troops++;
                        this.alive = false;
                    }
                    return;
                }
            }

            // Check if this army needs retargeting (notified by tile capture)
            if (this.needsRetargeting && (this.task === 'attack' || this.task === 'defend')) {
                this.needsRetargeting = false; // Reset flag
                // Release current target
                if (this.targetTileKey) {
                    delete this.kingdom.targetedTiles[this.targetTileKey];
                    this.targetTileKey = null;
                }
                
                // Check if kingdom is at war with anyone
                const atWarWith = [];
                
                // First check if kingdom has a war target
                if (this.kingdom.targetKingdom) {
                    const targetEnemy = findKingdomById(this.kingdom.targetKingdom);
                    if (targetEnemy && targetEnemy.alive) {
                        atWarWith.push(targetEnemy);
                    }
                } else {
                    // Otherwise check regular enemies
                    for (const enemyId in this.kingdom.enemies) {
                        if (this.kingdom.enemies[enemyId] && !this.kingdom.truces[enemyId]) {
                            // Find the enemy kingdom (could be in this world or another)
                            let enemyKingdom = world.kingdoms.find(k => k.id == enemyId && k.alive);
                            if (!enemyKingdom) {
                                // Check other worlds for this enemy
                                for (let w = 0; w < worlds.length; w++) {
                                    enemyKingdom = worlds[w].kingdoms.find(k => k.id == enemyId && k.alive);
                                    if (enemyKingdom) break;
                                }
                            }
                            if (enemyKingdom) atWarWith.push(enemyKingdom);
                        }
                    }
                }
                
                let allBorderTiles = [];
                
                // First priority: attack kingdoms we're at war with
                if (atWarWith.length > 0) {
                    atWarWith.forEach(enemy => {
                        allBorderTiles.push(...this.kingdom.findAllEnemyBorderTiles(world, enemy));
                    });
                }
                
                // Second priority: any enemy border tiles
                if (allBorderTiles.length === 0) {
                    const enemies = world.kingdoms.filter(k => k.alive && k.id !== this.kingdom.id);
                    enemies.forEach(enemy => {
                        if (!this.kingdom.truces[enemy.id]) {
                            allBorderTiles.push(...this.kingdom.findAllEnemyBorderTiles(world, enemy));
                        }
                    });
                }
                
                // Filter out tiles already targeted by other armies
                const availableTargets = allBorderTiles.filter(tile => {
                    const tileKey = tile.x + ',' + tile.y + ',' + world.id;
                    return !this.kingdom.targetedTiles[tileKey];
                });
                
                // Use available targets if any, otherwise use all targets
                const targetsToConsider = availableTargets.length > 0 ? availableTargets : allBorderTiles;

                if (targetsToConsider.length > 0) {
                    // Use actual current position for finding closest target
                    const currentPos = this.getPosition();
                    targetsToConsider.sort((a, b) => {
                        const distA = Math.abs(a.x - currentPos.x) + Math.abs(a.y - currentPos.y);
                        const distB = Math.abs(b.x - currentPos.x) + Math.abs(b.y - currentPos.y);
                        return distA - distB;
                    });
                    const newTarget = targetsToConsider[0];
                    const newTileKey = newTarget.x + ',' + newTarget.y + ',' + world.id;
                    
                    this.targetX = newTarget.x;
                    this.targetY = newTarget.y;
                    this.targetTileKey = newTileKey;
                    this.kingdom.targetedTiles[newTileKey] = this;
                    this.path = this.calculatePath();
                    this.pathIndex = 0;
                    this.moveProgress = 0;
                } else {
                    // No valid targets - convert army back to troops
                    this.kingdom.troops++;
                    this.alive = false;
                    return;
                }
            }

            if (this.pathIndex >= this.path.length) return;
            
            // Add wear at current interpolated position
            var currentPos = this.getPosition();
            addWearToTile(world, currentPos.x, currentPos.y, 0.02 * this.speed);
            
            this.moveProgress += this.speed;
            
            if (this.moveProgress >= 1) {
                this.moveProgress = 0;
                // Store previous position
                const prevX = this.currentX;
                const prevY = this.currentY;
                
                this.currentX = this.path[this.pathIndex].x;
                this.currentY = this.path[this.pathIndex].y;
                this.pathIndex++;
                
                // Record route for Ignis shadow spawning (record every 10 ticks for performance)
                if (world.name === 'Ignis' && game.currentTick - this.lastRecordedTick >= 10) {
                    this.routeHistory.push({
                        x: this.currentX,
                        y: this.currentY,
                        tick: game.currentTick
                    });
                    this.lastRecordedTick = game.currentTick;
                }
                
                // Update spatial index when position changes
                updateEntityChunk(this, this.worldId);
                
                // Update foreign invader tracking
                this.updateInvaderTracking(prevX, prevY, world);
                
                // Check for collision with enemy armies
                this.checkArmyCollisions(world);
            }
        };
        
        Army.prototype.checkArmyCollisions = function(world) {
            if (!this.alive) return;
            
            const myPos = this.getPosition();
            const collisionRadius = 0.5; // Half a tile distance for collision
            
            // Get all armies in this world
            const allArmies = [];
            
            // Check native kingdom armies
            world.kingdoms.forEach(kingdom => {
                if (kingdom.alive && kingdom.id !== this.kingdom.id) {
                    kingdom.armies.forEach(army => {
                        if (army.alive && army.worldId === world.id && army !== this) {
                            allArmies.push(army);
                        }
                    });
                }
            });
            
            // Check foreign kingdom armies
            for (let w = 0; w < worlds.length; w++) {
                if (w !== world.id) {
                    worlds[w].kingdoms.forEach(kingdom => {
                        if (kingdom.alive && kingdom.id !== this.kingdom.id) {
                            kingdom.armies.forEach(army => {
                                if (army.alive && army.worldId === world.id && army !== this) {
                                    allArmies.push(army);
                                }
                            });
                        }
                    });
                }
            }
            
            // Check for collisions
            for (const enemyArmy of allArmies) {
                const enemyPos = enemyArmy.getPosition();
                const distance = Math.sqrt(
                    Math.pow(myPos.x - enemyPos.x, 2) + 
                    Math.pow(myPos.y - enemyPos.y, 2)
                );
                
                if (distance < collisionRadius) {
                    // Collision detected! Both armies die with smoke effect
                    
                    // Create smoke effect at collision point
                    const collisionX = (myPos.x + enemyPos.x) / 2;
                    const collisionY = (myPos.y + enemyPos.y) / 2;
                    const collisionIso = worldToIsometric(collisionX, collisionY);
                    
                    game.divineEffects.push(new ArmyDeathSmoke(collisionIso.x, collisionIso.y, world.id));
                    
                    // Clean up both armies
                    this.alive = false;
                    this.cleanupOnDeath(world);
                    
                    enemyArmy.alive = false;
                    enemyArmy.cleanupOnDeath(world);
                    
                    // Return troops to kingdoms (representing survivors fleeing)
                    this.kingdom.troops += Math.floor(this.size * 0.2); // 20% survive
                    enemyArmy.kingdom.troops += Math.floor(enemyArmy.size * 0.2); // 20% survive
                    
                    return; // Exit since this army is dead
                }
            }
        };
        
        Army.prototype.hasReachedDestination = function() {
            return this.pathIndex >= this.path.length;
        };
        
        Army.prototype.cleanupOnDeath = function(world) {
            if (!world) return;
            
            // Record route for Ignis shadow spawning (every 10th army)
            if (world.name === 'Ignis' && world.effect && this.routeHistory.length > 3) {
                world.effect.armyDeathCount++;
                if (world.effect.armyDeathCount % 10 === 0) {
                    // Add this army's route to pending routes for shadow spawning
                    world.effect.pendingRoutes.push({
                        route: [...this.routeHistory], // Copy the route
                        deathTick: game.currentTick,
                        armySize: this.size,
                        kingdomColor: this.kingdom.color
                    });
                }
            }
            
            // Remove from foreign invader tracking
            const currTile = world.tiles[Math.floor(this.currentX)][Math.floor(this.currentY)];
            if (currTile.owner !== null && currTile.owner !== this.kingdom.id) {
                // Check if this army's kingdom is from another world
                const isNative = world.kingdoms.some(k => k.id === this.kingdom.id);
                if (!isNative) {
                    const ownerKingdom = world.kingdoms.find(k => k.id === currTile.owner && k.alive);
                    if (ownerKingdom) {
                        // Check if any other armies from our kingdom are still in their territory
                        let stillInTerritory = false;
                        for (const army of this.kingdom.armies) {
                            if (army !== this && army.alive && army.worldId === world.id) {
                                const armyTile = world.tiles[Math.floor(army.currentX)][Math.floor(army.currentY)];
                                if (armyTile.owner === currTile.owner) {
                                    stillInTerritory = true;
                                    break;
                                }
                            }
                        }
                        
                        if (!stillInTerritory) {
                            ownerKingdom.foreignInvaders.delete(this.kingdom.id);
                        }
                    }
                }
            }
            
            // Remove from spatial index
            const chunks = spatialIndex.entityChunks.get(this.worldId);
            if (chunks && this._chunkKey) {
                const chunk = chunks.get(this._chunkKey);
                if (chunk) {
                    chunk.delete(this);
                }
            }
        };
        
        Army.prototype.getPosition = function() {
            if (this.pathIndex >= this.path.length) {
                return {x: this.targetX, y: this.targetY};
            }
            
            var from = this.pathIndex === 0 ? {x: this.currentX, y: this.currentY} : this.path[this.pathIndex - 1];
            var to = this.path[this.pathIndex];

            return {
                x: from.x + (to.x - from.x) * this.moveProgress,
                y: from.y + (to.y - from.y) * this.moveProgress
            };
        };
        
        Army.prototype.updateInvaderTracking = function(prevX, prevY, world) {
            // Skip if the army hasn't actually moved
            if (prevX === this.currentX && prevY === this.currentY) return;
            
            // Get previous and current tile owners
            const prevTile = world.tiles[Math.floor(prevX)][Math.floor(prevY)];
            const currTile = world.tiles[Math.floor(this.currentX)][Math.floor(this.currentY)];
            
            // Leaving a tile
            if (prevTile.owner !== null && prevTile.owner !== this.kingdom.id) {
                // Check if this army's kingdom is from another world
                const isNative = world.kingdoms.some(k => k.id === this.kingdom.id);
                if (!isNative) {
                    // This is a foreign army leaving someone's territory
                    const ownerKingdom = world.kingdoms.find(k => k.id === prevTile.owner && k.alive);
                    if (ownerKingdom) {
                        // Check if any other armies from our kingdom are still in their territory
                        let stillInTerritory = false;
                        for (const army of this.kingdom.armies) {
                            if (army !== this && army.alive && army.worldId === world.id) {
                                const armyTile = world.tiles[Math.floor(army.currentX)][Math.floor(army.currentY)];
                                if (armyTile.owner === prevTile.owner) {
                                    stillInTerritory = true;
                                    break;
                                }
                            }
                        }
                        
                        if (!stillInTerritory) {
                            ownerKingdom.foreignInvaders.delete(this.kingdom.id);
                        }
                    }
                }
            }
            
            // Entering a tile
            if (currTile.owner !== null && currTile.owner !== this.kingdom.id) {
                // Check if this army's kingdom is from another world
                const isNative = world.kingdoms.some(k => k.id === this.kingdom.id);
                if (!isNative) {
                    // This is a foreign army entering someone's territory
                    const ownerKingdom = world.kingdoms.find(k => k.id === currTile.owner && k.alive);
                    if (ownerKingdom) {
                        ownerKingdom.foreignInvaders.add(this.kingdom.id);
                    }
                }
            }
        };
        
        // Static method to check if recruits can reach target
        RecruitGroup.canReachTarget = Army.canReachTarget;
        
        function RecruitGroup(kingdom, fromX, fromY, targetX, targetY, worldId) {
            this.kingdom = kingdom;
            this.size = 1;
            this.currentX = fromX;
            this.currentY = fromY;
            this.targetX = targetX;
            this.targetY = targetY;
            this.worldId = worldId || kingdom.worldId;
            this.path = this.calculatePath();
            this.pathIndex = 0;
            this.moveProgress = 0;
            this.speed = 0.03; // 3x faster (was 0.01)
            this.alive = true;
            
            // Initialize in spatial index
            updateEntityChunk(this, this.worldId);
        }
        RecruitGroup.prototype.calculatePath = Army.prototype.calculatePath;
        RecruitGroup.prototype.heuristic = Army.prototype.heuristic; // FIX: Add missing heuristic method
        RecruitGroup.prototype.update = function(world) {
            if (!this.alive) return;
            
            // Check if destination capital is still valid
            const destinationStillValid = this.kingdom.controlledCapitals.some(capital => 
                capital.x === this.targetX && capital.y === this.targetY
            );
            
            if (!destinationStillValid) {
                // Find new closest capital
                const closestCapital = this.kingdom.findClosestStagingPoint(this.currentX, this.currentY, this.worldId);
                if (closestCapital) {
                    // Check if the capital isn't burned
                    const capitalKey = closestCapital.x + ',' + closestCapital.y + ',' + this.worldId;
                    if (!game.burnedCapitals[capitalKey]) {
                        // Update destination and recalculate path
                        this.targetX = closestCapital.x;
                        this.targetY = closestCapital.y;
                        this.path = this.calculatePath();
                        this.pathIndex = 0;
                        this.moveProgress = 0;
                    } else {
                        // No valid capital, recruit disbands
                        this.alive = false;
                        return;
                    }
                } else {
                    // No valid capital found, recruit disbands
                    this.alive = false;
                    return;
                }
            }
            
            if (this.pathIndex >= this.path.length) return;
            
            // Add wear at current interpolated position
            var currentPos = this.getPosition();
            addWearToTile(world, currentPos.x, currentPos.y, 0.04 * this.speed);
            
            this.moveProgress += this.speed;
            
            if (this.moveProgress >= 1) {
                this.moveProgress = 0;
                this.currentX = this.path[this.pathIndex].x;
                this.currentY = this.path[this.pathIndex].y;
                this.pathIndex++;
                
                // Update spatial index when position changes
                updateEntityChunk(this, this.worldId);
            }
        };
        RecruitGroup.prototype.hasReachedDestination = Army.prototype.hasReachedDestination;
        RecruitGroup.prototype.getPosition = Army.prototype.getPosition;

        function TempleRequest(kingdom, type, target, fromCapital) {
            this.kingdom = kingdom;
            this.type = type;
            this.target = target;
            this.duration = 600;
            this.currentTick = 0;
            this.emojis = this.generateEmojis();
            this.completed = false;
            // Store which capital this request is from
            this.capital = fromCapital || { x: kingdom.capitalX, y: kingdom.capitalY };
        }
        
        TempleRequest.prototype.generateEmojis = function() {
            let actionEmoji, directionEmoji;
            
            switch(this.type) {
                case 'attack':
                    actionEmoji = '⚔️';
                    break;
                case 'defend':
                    actionEmoji = '🛡️';
                    break;
                case 'protect':
                    actionEmoji = '🏰';
                    break;
                case 'peace':
                    actionEmoji = '🕊️';
                    break;
                case 'blessing':
                    actionEmoji = '🌟';
                    break;
                case 'terraform':
                    actionEmoji = '⛰️';
                    break;
                case 'portal':
                    actionEmoji = '🌀';
                    break;
                default:
                    actionEmoji = '❓';
            }
            
            // Calculate direction emoji if there's a target or location
            if (this.target && this.target.capitalX !== undefined) {
                const dx = this.target.capitalX - this.kingdom.capitalX;
                const dy = this.target.capitalY - this.kingdom.capitalY;
                const angle = Math.atan2(dy, dx);
                const octant = Math.round(8 * angle / (2 * Math.PI) + 8) % 8;
                
                const directions = ['➡️', '↗️', '⬆️', '↖️', '⬅️', '↙️', '⬇️', '↘️'];
                directionEmoji = directions[octant];
            } else if (this.location) {
                const dx = this.location.x - this.kingdom.capitalX;
                const dy = this.location.y - this.kingdom.capitalY;
                const angle = Math.atan2(dy, dx);
                const octant = Math.round(8 * angle / (2 * Math.PI) + 8) % 8;
                
                const directions = ['➡️', '↗️', '⬆️', '↖️', '⬅️', '↙️', '⬇️', '↘️'];
                directionEmoji = directions[octant];
            } else {
                // Special emojis for non-directional requests
                switch(this.type) {
                    case 'blessing':
                        directionEmoji = '🙏';
                        break;
                    case 'protect':
                        directionEmoji = '⚡';
                        break;
                    default:
                        directionEmoji = '❓';
                }
            }
            
            return { action: actionEmoji, direction: directionEmoji };
        };
        
        TempleRequest.prototype.update = function() {
            // Check if request is still valid
            const isInvalid = this.checkIfInvalid();
            
            // If request is completed or invalid, fade out the bubble
            if (this.completed || isInvalid) {
                if (!this.fadingOut) {
                    this.fadingOut = true;
                    this.fadeTimer = 30; // Half second fade
                }
                this.fadeTimer--;
                return this.fadeTimer > 0;
            }
            
            this.currentTick++;
            if (this.currentTick >= this.duration) {
                // Request is expiring, clean up messenger if exists
                if (this.messengerArmy && this.messengerArmy.alive) {
                    this.messengerArmy.kingdom.troops += this.messengerArmy.size;
                    this.messengerArmy.alive = false;
                }
                return false;
            }
            return true;
        };
        
        TempleRequest.prototype.checkIfInvalid = function() {
            // Check if the target kingdom still exists and is alive
            if (this.target && this.type !== 'blessing') {
                // For requests that target another kingdom
                if (!this.target.alive) {
                    return true; // Target kingdom is dead
                }
                
                // For attack requests, check if they're still enemies
                if (this.type === 'attack' && !this.kingdom.isAtWarWith(this.target.id)) {
                    return true; // No longer at war
                }
                
                // For peace requests, check if they're still at war
                if (this.type === 'peace' && !this.kingdom.isAtWarWith(this.target.id)) {
                    return true; // Already at peace
                }
            }
            
            return false;
        };
        
        // Temple class
        function Temple(x, y, kingdomId, worldId) {
            this.x = x;
            this.y = y;
            this.kingdomId = kingdomId;
            this.worldId = worldId;
            this.health = 100;
            this.maxHealth = 100;
            this.powerGeneration = 0.02; // Power per tick
            this.glowPhase = Math.random() * Math.PI * 2;
            this.active = true; // Can be deactivated when attacking the kingdom
        }
        
        Temple.prototype.update = function() {
            // Only generate power if temple is active
            if (this.active && game.power < game.maxPower) {
                game.power = game.power + this.powerGeneration;
                
                // Cap at max power
                if (game.power >= game.maxPower) {
                    game.power = game.maxPower;
                }
            }
            
            // Update glow animation
            this.glowPhase += 0.02;
        };
        
        // Create temple near capital
        function createTemple(kingdom, world, capital) {
            if (!kingdom.alive) return null;
            
            // Use provided capital or default to kingdom's original capital
            const targetCapital = capital || { x: kingdom.capitalX, y: kingdom.capitalY };
            if (targetCapital.x === undefined || targetCapital.y === undefined) return null;
            
            // Find a suitable location near the capital
            const searchRadius = 3;
            let bestLocation = null;
            let minDistance = Infinity;
            
            for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                    const x = targetCapital.x + dx;
                    const y = targetCapital.y + dy;
                    
                    // Check bounds
                    if (x < 0 || x >= WORLD_SIZE || y < 0 || y >= WORLD_SIZE) continue;
                    
                    const tile = world.tiles[x][y];
                    // Skip air tiles and water tiles
                    if (!tile || !tile.active || tile.elevation <= 0) continue;
                    
                    // Must be owned by the kingdom
                    if (tile.owner !== kingdom.id) continue;
                    
                    // Check if tile has a building
                    if (tile.hasBuilding || tile.buildingType) continue;
                    
                    // Check if it's a capital or village location
                    const isCapital = world.capitals.some(cap => cap.x === x && cap.y === y);
                    
                    // Check both world villages and kingdom villages
                    let isVillage = false;
                    if (world.villages) {
                        isVillage = world.villages.some(vil => vil.x === x && vil.y === y);
                    }
                    if (!isVillage && kingdom.villages) {
                        isVillage = kingdom.villages.some(vil => vil.x === x && vil.y === y);
                    }
                    
                    if (isCapital || isVillage) continue;
                    
                    // Check if location is clear
                    let isOccupied = false;
                    
                    // Check for other temples
                    for (const temple of game.temples) {
                        if (temple.worldId === world.id && temple.x === x && temple.y === y) {
                            isOccupied = true;
                            break;
                        }
                    }
                    
                    // Check for armies
                    if (!isOccupied) {
                        const nearbyArmies = getNearbyEntities(x, y, 0, world.id, 'armies');
                        if (nearbyArmies.length > 0) isOccupied = true;
                    }
                    
                    if (!isOccupied) {
                        const distance = Math.abs(dx) + Math.abs(dy);
                        if (distance < minDistance && distance > 0) {
                            minDistance = distance;
                            bestLocation = { x, y };
                        }
                    }
                }
            }
            
            if (bestLocation) {
                const temple = new Temple(bestLocation.x, bestLocation.y, kingdom.id, world.id);
                game.temples.push(temple);
                kingdom.temples.push(temple);
                
                // Mark the tile as having a temple
                const tile = world.tiles[bestLocation.x][bestLocation.y];
                tile.hasBuilding = true;
                tile.buildingType = 'temple';
                
                // Update max power
                game.maxPower += 10;
                updatePowerDisplay();
                
                // Check for ability unlocks
                checkAbilityUnlocks();
                
                // Create golden particle effect
                for (let i = 0; i < 20; i++) {
                    game.divineEffects.push(new TempleSpawnParticle(
                        bestLocation.x, 
                        bestLocation.y, 
                        world.id
                    ));
                }
                
                return temple;
            }
            
            return null;
        }
        
        // Temple spawn effect
        function TempleSpawnParticle(x, y, worldId) {
            const iso = worldToIsometric(x, y);
            // Get world and tile elevation
            const world = worlds[worldId];
            const tile = world && world.tiles[x] && world.tiles[x][y];
            const elevationOffset = tile ? tile.elevation * 5 : 0;
            
            this.x = iso.x + (Math.random() - 0.5) * 20;
            this.y = iso.y - elevationOffset + (Math.random() - 0.5) * 20;
            this.worldId = worldId;
            this.vx = (Math.random() - 0.5) * 2;
            this.vy = -Math.random() * 3 - 1;
            this.duration = 60;
            this.currentTick = 0;
            this.size = Math.random() * 3 + 2;
        }
        
        TempleSpawnParticle.prototype.update = function() {
            this.currentTick++;
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.1; // gravity
            return this.currentTick < this.duration;
        };
        
        // Temple destruction particle
        function TempleDestructionParticle(x, y, worldId) {
            // x and y are already in isometric screen coordinates from the temple destruction
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.vx = (Math.random() - 0.5) * 4;
            this.vy = -Math.random() * 5 - 2;
            this.duration = 80;
            this.currentTick = 0;
            this.size = Math.random() * 4 + 2;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotationSpeed = (Math.random() - 0.5) * 0.3;
            this.color = Math.random() < 0.5 ? '#ffd700' : '#fff8dc';
        }
        
        TempleDestructionParticle.prototype.update = function() {
            this.currentTick++;
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.15; // gravity
            this.rotation += this.rotationSpeed;
            this.vx *= 0.98; // air resistance
            return this.currentTick < this.duration;
        };
        
        function Battle(x, y, worldId, duration) {
            this.x = x;
            this.y = y;
            this.worldId = worldId;
            this.duration = duration || 30;
            this.currentTick = 0;
        }
        
        Battle.prototype.update = function() {
            this.currentTick++;
            return this.currentTick < this.duration;
        };
        
        function ArmySpawn(x, y, kingdom, worldId) {
            this.x = x;
            this.y = y;
            this.kingdom = kingdom;
            this.worldId = worldId;
            this.duration = 20;
            this.currentTick = 0;
        }
        
        ArmySpawn.prototype.update = function() {
            this.currentTick++;
            return this.currentTick < this.duration;
        };
        
        function generateWorldShape(size, worldId) {
            // Create a unique jagged shape for each world
            var shape = [];
            for (var x = 0; x < size; x++) {
                shape[x] = [];
                for (var y = 0; y < size; y++) {
                    shape[x][y] = false; // Default to inactive
                }
            }
            
            // Different shape generation patterns based on world
            var centerX = Math.floor(size / 2);
            var centerY = Math.floor(size / 2);
            
            // Use world ID to determine shape pattern
            var shapeType = worldId % 7;
            
            switch(shapeType) {
                case 0: // Ignis - Rough diamond with volcanic edges
                    for (var x = 0; x < size; x++) {
                        for (var y = 0; y < size; y++) {
                            var dist = Math.abs(x - centerX) + Math.abs(y - centerY);
                            var maxDist = size * 0.4 + Math.sin((x + y) * 0.3) * 4;
                            shape[x][y] = dist < maxDist;
                        }
                    }
                    break;
                    
                case 1: // Aqua - Flowing, wave-like edges
                    for (var x = 0; x < size; x++) {
                        for (var y = 0; y < size; y++) {
                            var dist = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                            var angle = Math.atan2(y - centerY, x - centerX);
                            var waveRadius = size * 0.42 + Math.sin(angle * 4) * 3 + Math.cos(angle * 7) * 2;
                            shape[x][y] = dist < waveRadius;
                        }
                    }
                    break;
                    
                case 2: // Aether - Cloud-like, soft edges
                    for (var x = 0; x < size; x++) {
                        for (var y = 0; y < size; y++) {
                            var dist = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                            var noise = Math.sin(x * 0.2) * Math.cos(y * 0.2) * 5;
                            shape[x][y] = dist < size * 0.4 + noise;
                        }
                    }
                    break;
                    
                case 3: // Terra - Rocky, irregular chunks
                    // Create multiple "land masses"
                    var seeds = [
                        {x: centerX, y: centerY, r: size * 0.35},
                        {x: centerX - 8, y: centerY + 6, r: size * 0.2},
                        {x: centerX + 10, y: centerY - 5, r: size * 0.15}
                    ];
                    for (var x = 0; x < size; x++) {
                        for (var y = 0; y < size; y++) {
                            for (var s = 0; s < seeds.length; s++) {
                                var seed = seeds[s];
                                var dist = Math.sqrt(Math.pow(x - seed.x, 2) + Math.pow(y - seed.y, 2));
                                var jitter = Math.sin(x * 0.5) * Math.cos(y * 0.5) * 3;
                                if (dist < seed.r + jitter) {
                                    shape[x][y] = true;
                                    break;
                                }
                            }
                        }
                    }
                    break;
                    
                case 4: // Lux - Star-like rays with curved edges
                    for (var x = 0; x < size; x++) {
                        for (var y = 0; y < size; y++) {
                            var dist = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                            var angle = Math.atan2(y - centerY, x - centerX);
                            var rays = 6;
                            // More curved rays with smoother transitions
                            var rayIntensity = (Math.sin(angle * rays) + 1) / 2; // Normalized 0-1
                            var curvedRay = Math.pow(rayIntensity, 1.5); // Apply curve for smoother shape
                            var rayWidth = curvedRay * 6 + 2; // Smaller ray variations (2-8 instead of 4-20)
                            // Base size reduced to match other worlds, max extent around 0.38-0.42
                            shape[x][y] = dist < size * 0.36 + rayWidth;
                        }
                    }
                    break;
                    
                case 5: // Umbra - Twisted, shadow-like
                    for (var x = 0; x < size; x++) {
                        for (var y = 0; y < size; y++) {
                            var dx = x - centerX;
                            var dy = y - centerY;
                            var twist = Math.sin(Math.sqrt(dx * dx + dy * dy) * 0.15) * 0.3;
                            var twistedX = dx * Math.cos(twist) - dy * Math.sin(twist);
                            var twistedY = dx * Math.sin(twist) + dy * Math.cos(twist);
                            var dist = Math.abs(twistedX) + Math.abs(twistedY);
                            shape[x][y] = dist < size * 0.4;
                        }
                    }
                    break;
                    
                case 6: // Vita - Organic, growth-like with small holes
                    // Cellular automata-like growth
                    shape[centerX][centerY] = true;
                    var growth = [{x: centerX, y: centerY}];
                    var maxGrowth = size * size * 0.4;
                    var grown = 0;
                    
                    while (growth.length > 0 && grown < maxGrowth) {
                        var idx = Math.floor(Math.random() * growth.length);
                        var cell = growth[idx];
                        growth.splice(idx, 1);
                        
                        var neighbors = [
                            {x: cell.x + 1, y: cell.y},
                            {x: cell.x - 1, y: cell.y},
                            {x: cell.x, y: cell.y + 1},
                            {x: cell.x, y: cell.y - 1}
                        ];
                        
                        for (var n = 0; n < neighbors.length; n++) {
                            var neighbor = neighbors[n];
                            if (neighbor.x >= 0 && neighbor.x < size && 
                                neighbor.y >= 0 && neighbor.y < size && 
                                !shape[neighbor.x][neighbor.y] && 
                                Math.random() < 0.65) {
                                shape[neighbor.x][neighbor.y] = true;
                                growth.push(neighbor);
                                grown++;
                            }
                        }
                    }
                    
                    // Create small random holes
                    var holeCount = 3 + Math.floor(Math.random() * 4); // 3-6 holes
                    for (var h = 0; h < holeCount; h++) {
                        // Random position within the grown area
                        var holeX = centerX + Math.floor((Math.random() - 0.5) * size * 0.6);
                        var holeY = centerY + Math.floor((Math.random() - 0.5) * size * 0.6);
                        
                        // Only create hole if position is active and not too close to center
                        var distFromCenter = Math.sqrt(Math.pow(holeX - centerX, 2) + Math.pow(holeY - centerY, 2));
                        
                        if (holeX >= 0 && holeX < size && holeY >= 0 && holeY < size && 
                            shape[holeX][holeY] && distFromCenter > 5) {
                            
                            // Small hole - just 1-4 tiles
                            shape[holeX][holeY] = false;
                            
                            // Sometimes expand to adjacent tiles
                            if (Math.random() < 0.6) {
                                var holeNeighbors = [
                                    {x: holeX + 1, y: holeY},
                                    {x: holeX - 1, y: holeY},
                                    {x: holeX, y: holeY + 1},
                                    {x: holeX, y: holeY - 1}
                                ];
                                
                                // Remove 1-3 adjacent tiles
                                var removeCount = 1 + Math.floor(Math.random() * 3);
                                for (var r = 0; r < removeCount && r < holeNeighbors.length; r++) {
                                    var hn = holeNeighbors[Math.floor(Math.random() * holeNeighbors.length)];
                                    if (hn.x >= 0 && hn.x < size && hn.y >= 0 && hn.y < size) {
                                        shape[hn.x][hn.y] = false;
                                    }
                                }
                            }
                        }
                    }
                    break;
            }
            
            // Ensure minimum playable area
            var activeCount = 0;
            for (var x = 0; x < size; x++) {
                for (var y = 0; y < size; y++) {
                    if (shape[x][y]) activeCount++;
                }
            }
            
            // If too small, add more tiles organically
            var minTiles = size * size * 0.35;
            if (activeCount < minTiles && shapeType === 6) {
                // For Vita, use organic growth from existing tiles
                var attempts = 0;
                while (activeCount < minTiles && attempts < 1000) {
                    attempts++;
                    
                    // Find a random active tile
                    var activeX = -1, activeY = -1;
                    var searchAttempts = 0;
                    while ((activeX === -1 || activeY === -1) && searchAttempts < 100) {
                        var rx = Math.floor(Math.random() * size);
                        var ry = Math.floor(Math.random() * size);
                        if (shape[rx][ry]) {
                            activeX = rx;
                            activeY = ry;
                        }
                        searchAttempts++;
                    }
                    
                    if (activeX !== -1 && activeY !== -1) {
                        // Grow from this tile
                        var angle = Math.random() * Math.PI * 2;
                        var dist = 1 + Math.floor(Math.random() * 3);
                        var newX = Math.round(activeX + Math.cos(angle) * dist);
                        var newY = Math.round(activeY + Math.sin(angle) * dist);
                        
                        if (newX >= 0 && newX < size && newY >= 0 && newY < size && !shape[newX][newY]) {
                            shape[newX][newY] = true;
                            activeCount++;
                            
                            // Sometimes fill in gaps
                            if (Math.random() < 0.5) {
                                var midX = Math.round((activeX + newX) / 2);
                                var midY = Math.round((activeY + newY) / 2);
                                if (midX >= 0 && midX < size && midY >= 0 && midY < size && !shape[midX][midY]) {
                                    shape[midX][midY] = true;
                                    activeCount++;
                                }
                            }
                        }
                    }
                }
            } else if (activeCount < minTiles) {
                // For other worlds, use the original square fill
                for (var radius = 1; activeCount < minTiles && radius < size/2; radius++) {
                    for (var x = centerX - radius; x <= centerX + radius; x++) {
                        for (var y = centerY - radius; y <= centerY + radius; y++) {
                            if (x >= 0 && x < size && y >= 0 && y < size && !shape[x][y]) {
                                shape[x][y] = true;
                                activeCount++;
                            }
                        }
                    }
                }
            }
            
            return shape;
        }
        
        function generateWorldTiles(size, shape) {
            var tiles = [];
            
            // Generate smooth elevation using multiple octaves of noise for HEIGHT
            var heightMap = [];
            var noiseScale1 = 0.06; // Even larger features
            var noiseScale2 = 0.12; // Medium features
            var noiseScale3 = 0.25;  // Small details
            
            // Simple value noise function
            function smoothNoise(x, y, scale) {
                var scaledX = x * scale;
                var scaledY = y * scale;
                
                var x0 = Math.floor(scaledX);
                var x1 = x0 + 1;
                var y0 = Math.floor(scaledY);
                var y1 = y0 + 1;
                
                // Pseudo-random values at grid points
                function hash(ix, iy) {
                    var h = (ix * 374761393 + iy * 668265263) ^ 1274126177;
                    h = ((h ^ (h >> 13)) * 1274126177) ^ (h >> 15);
                    return (h & 0x7fffffff) / 0x7fffffff;
                }
                
                var v00 = hash(x0, y0);
                var v10 = hash(x1, y0);
                var v01 = hash(x0, y1);
                var v11 = hash(x1, y1);
                
                // Interpolation weights
                var fx = scaledX - x0;
                var fy = scaledY - y0;
                
                // Smooth interpolation
                fx = fx * fx * (3 - 2 * fx);
                fy = fy * fy * (3 - 2 * fy);
                
                // Bilinear interpolation
                var v0 = v00 * (1 - fx) + v10 * fx;
                var v1 = v01 * (1 - fx) + v11 * fx;
                
                return v0 * (1 - fy) + v1 * fy;
            }
            
            // Create tiles with separate height and color values
            for (var x = 0; x < size; x++) {
                tiles[x] = [];
                for (var y = 0; y < size; y++) {
                    // Calculate smooth height for terrain
                    var height = 0;
                    if (shape && shape[x][y]) {
                        height += smoothNoise(x, y, noiseScale1) * 0.5;
                        height += smoothNoise(x, y, noiseScale2) * 0.3;
                        height += smoothNoise(x, y, noiseScale3) * 0.2;
                        // Normalize to 0.2-1.0 range for even taller hills
                        height = height * 0.8 + 0.2;
                    }
                    
                    // Pre-calculate isometric position with elevation
                    var iso = worldToIsometric(x, y);
                    var elevationOffset = (height - 0.65) * 240;
                    
                    tiles[x][y] = { 
                        x: x, 
                        y: y, 
                        elevation: Math.random() * 0.3 + 0.7, // Random color gradient (original)
                        height: height, // Smooth height for terrain
                        owner: null,
                        active: shape ? shape[x][y] : true,
                        wear: 0, // Track how worn this tile is from foot traffic (0-1)
                        // Pre-calculated render positions
                        isoX: iso.x,
                        isoY: iso.y,
                        renderY: iso.y - elevationOffset
                    };
                }
            }
            return tiles;
        }
        
        function isValidCapitalPosition(world, x, y, minDistance) {
            minDistance = minDistance || 4;
            
            // Check if tile is active
            if (!world.tiles[x][y].active) return false;
            
            // Check boundaries (need buffer from edges)
            if (x < 2 || x >= WORLD_SIZE - 2 || y < 2 || y >= WORLD_SIZE - 2) return false;
            
            // Make sure there's enough active tiles around for expansion
            var activeNeighbors = 0;
            for (var dx = -2; dx <= 2; dx++) {
                for (var dy = -2; dy <= 2; dy++) {
                    var nx = x + dx;
                    var ny = y + dy;
                    if (nx >= 0 && nx < WORLD_SIZE && ny >= 0 && ny < WORLD_SIZE && 
                        world.tiles[nx][ny].active) {
                        activeNeighbors++;
                    }
                }
            }
            if (activeNeighbors < 20) return false; // Need sufficient active area
            
            for (var i = 0; i < world.kingdoms.length; i++) {
                var kingdom = world.kingdoms[i];
                var dx = kingdom.capitalX - x;
                var dy = kingdom.capitalY - y;
                var distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < minDistance) return false;
            }
            
            return true;
        }
        
        function expandKingdomTerritory(world, kingdom, maxTiles) {
            var queue = [{x: kingdom.capitalX, y: kingdom.capitalY}];
            var visited = {};
            var tilesAssigned = 0;
            
            world.tiles[kingdom.capitalX][kingdom.capitalY].owner = kingdom.id;
            visited[kingdom.capitalX + ',' + kingdom.capitalY] = true;
            tilesAssigned++;
            
            while (queue.length > 0 && tilesAssigned < maxTiles) {
                var current = queue.shift();
                
                var neighbors = [
                    {x: current.x + 1, y: current.y}, {x: current.x - 1, y: current.y},
                    {x: current.x, y: current.y + 1}, {x: current.x, y: current.y - 1}
                ];
                
                for (var i = 0; i < neighbors.length; i++) {
                    var neighbor = neighbors[i];
                    var key = neighbor.x + ',' + neighbor.y;
                    if (neighbor.x >= 0 && neighbor.x < WORLD_SIZE && 
                        neighbor.y >= 0 && neighbor.y < WORLD_SIZE &&
                        !visited[key] && world.tiles[neighbor.x][neighbor.y].owner === null &&
                        world.tiles[neighbor.x][neighbor.y].active && // Only expand into active tiles
                        tilesAssigned < maxTiles) {
                        
                        world.tiles[neighbor.x][neighbor.y].owner = kingdom.id;
                        visited[key] = true;
                        queue.push(neighbor);
                        tilesAssigned++;
                    }
                }
            }
            
            kingdom.territory = tilesAssigned;
            kingdom.territoryCount = tilesAssigned;
            
            // NEW: Initialize border tiles after territory assignment
            kingdom.recalculateBorders(world);
        }
        
        function generateKingdoms(world) {
            var usedNames = {};
            
            for (var i = 0; i < KINGDOMS_PER_WORLD; i++) {
                var attempts = 0;
                var placed = false;
                
                while (!placed && attempts < 100) {
                    var x = Math.floor(Math.random() * (WORLD_SIZE - 4)) + 2;
                    var y = Math.floor(Math.random() * (WORLD_SIZE - 4)) + 2;
                    
                    if (isValidCapitalPosition(world, x, y, 5)) {
                        var name;
                        do { name = generateKingdomName(); } while (usedNames[name]);
                        usedNames[name] = true;
                        
                        var kingdom = new Kingdom(i, name, generateKingdomColor(), x, y, world.id);
                        world.kingdoms.push(kingdom);
                        world.capitals.push({ x: x, y: y });

                        var initialTiles = 5 + Math.floor(Math.random() * 4);
                        expandKingdomTerritory(world, kingdom, initialTiles);
                        
                        placed = true;
                    }
                    attempts++;
                }
            }
        }
        
        function initializeWorlds() {
            var colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#DDA0DD', '#7FB5A5'];
            var names = ['Ignis', 'Aqua', 'Aether', 'Terra', 'Lux', 'Umbra', 'Vita'];
            
            for (var i = 0; i < WORLD_COUNT; i++) {
                var angle = (i / WORLD_COUNT) * Math.PI * 2 - Math.PI / 2;
                var radius = 250;
                var shape = generateWorldShape(WORLD_SIZE, i);
                var world = {
                    id: i, name: names[i], color: colors[i],
                    x: Math.cos(angle) * radius, y: Math.sin(angle) * radius,
                    shape: shape,
                    tiles: generateWorldTiles(WORLD_SIZE, shape),
                    kingdoms: [], capitals: [], recruits: [], villages: [], buildings: []
                };
                
                // Add unique world effect based on world name
                switch(world.name) {
                    case 'Ignis': world.effect = new IgnisEffect(i); break;
                    case 'Aqua': world.effect = new AquaEffect(i); break;
                    case 'Aether': 
                        world.effect = new AetherEffect(i);
                        // Initialize nomad tribe for Aether world
                        world.nomadTribe = createNomadTribe(i);
                        break;
                    case 'Terra': world.effect = new TerraEffect(i); break;
                    case 'Lux': world.effect = new LuxEffect(i); break;
                    case 'Umbra': world.effect = new UmbraEffect(i); break;
                    case 'Vita': world.effect = new VitaEffect(i, shape); break;
                }
                
                generateKingdoms(world);
                
                worlds.push(world);
                
                // Mark all tiles as dirty for initial render
                markAllTilesDirty(world.id);
            }
        }
        
        function worldToIsometric(x, y) { return { x: (x - y) * 32, y: (x + y) * 16 }; }
        function screenToWorld(screenX, screenY) { return { x: (screenX - canvas.width / 2) / camera.zoom - camera.x, y: (screenY - canvas.height / 2) / camera.zoom - camera.y }; }
        function isometricToTile(isoX, isoY) { return { x: Math.floor((isoX / 32 + isoY / 16) / 2), y: Math.floor((isoY / 16 - isoX / 32) / 2) }; }
        function tileToIsometric(tileX, tileY) { return worldToIsometric(tileX, tileY); }
        
        // Update spatial index for a world
        function updateSpatialIndex(world) {
            const worldId = world.id;
            const currentTick = game.currentTick;
            
            // Dynamic update frequency based on game speed
            let updateInterval = 30;
            if (game.timeScale >= 100) {
                updateInterval = 60; // Update less frequently at extreme speeds
            } else if (game.timeScale >= 50) {
                updateInterval = 45;
            }
            
            const lastUpdate = spatialIndex.lastUpdate.get(worldId) || 0;
            if (currentTick - lastUpdate < updateInterval) return;
            
            spatialIndex.lastUpdate.set(worldId, currentTick);
            
            // Clear old data
            const gridSize = 10;
            const cellSize = WORLD_SIZE / gridSize;
            const grid = Array(gridSize).fill(null).map(() => 
                Array(gridSize).fill(null).map(() => new Set())
            );
            
            // Clear kingdom borders
            world.kingdoms.forEach(k => {
                if (k.alive) {
                    spatialIndex.kingdomBorders.set(k.id, new Set());
                }
            });
            
            // Build spatial index
            for (let y = 0; y < WORLD_SIZE; y++) {
                for (let x = 0; x < WORLD_SIZE; x++) {
                    const tile = world.tiles[x][y];
                    if (tile.owner !== null) {
                        // Add to grid
                        const gridX = Math.floor(x / cellSize);
                        const gridY = Math.floor(y / cellSize);
                        grid[gridY][gridX].add(tile.owner);
                        
                        // Check if border tile
                        const neighbors = getTileNeighbors(x, y);
                        let isBorder = false;
                        for (const n of neighbors) {
                            if (world.tiles[n.x][n.y].owner !== tile.owner) {
                                isBorder = true;
                                break;
                            }
                        }
                        
                        if (isBorder) {
                            const borders = spatialIndex.kingdomBorders.get(tile.owner) || new Set();
                            borders.add(`${x},${y}`);
                            spatialIndex.kingdomBorders.set(tile.owner, borders);
                        }
                    }
                }
            }
            
            spatialIndex.territoryGrids.set(worldId, grid);
        }
        
        // Get cached tile neighbors
        function getTileNeighbors(x, y) {
            const key = `${x},${y}`;
            let neighbors = spatialIndex.tileNeighbors.get(key);
            
            if (!neighbors) {
                neighbors = [];
                const dirs = [{x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1}];
                
                for (const dir of dirs) {
                    const nx = x + dir.x;
                    const ny = y + dir.y;
                    if (nx >= 0 && nx < WORLD_SIZE && ny >= 0 && ny < WORLD_SIZE) {
                        neighbors.push({x: nx, y: ny});
                    }
                }
                
                spatialIndex.tileNeighbors.set(key, neighbors);
            }
            
            return neighbors;
        }
        
        canvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            
            // Continue following entity while zooming
            
            var rect = canvas.getBoundingClientRect();
            camera.zoomMouseX = e.clientX - rect.left;
            camera.zoomMouseY = e.clientY - rect.top;
            camera.isZooming = true;
            
            var zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
            camera.targetZoom *= zoomDelta;
            
            if (camera.viewMode === 'world' && camera.targetZoom < 0.2) {
                camera.isTransitioning = true;
                // Store the current world's position before transitioning
                const worldX = camera.currentWorld.x;
                const worldY = camera.currentWorld.y;
                
                setTimeout(function() {
                    camera.viewMode = 'ethereal';
                    camera.targetZoom = camera.etherealZoom;
                    // Position camera to center on the world we're leaving
                    camera.x = -worldX;
                    camera.y = -worldY;
                    camera.currentWorld = null;
                    camera.isZooming = false;
                    document.getElementById('viewMode').textContent = 'Ethereal';
                    camera.isTransitioning = false;
                }, 300);
            } else if (camera.viewMode === 'ethereal') {
                var mouseWorld = screenToWorld(camera.zoomMouseX, camera.zoomMouseY);
                
                // Check if zooming over crystal ball
                const ballX = 0;
                const ballY = 0;
                const baseRadius = 135;
                const distFromBall = Math.sqrt(Math.pow(mouseWorld.x - ballX, 2) + Math.pow(mouseWorld.y - ballY, 2));
                
                if (distFromBall < baseRadius && crystalBall.currentWorld !== null && camera.targetZoom > 6) {
                    // Zoom into crystal ball world
                    camera.isTransitioning = true;
                    const targetWorld = worlds[crystalBall.currentWorld];
                    
                    setTimeout(function() {
                        camera.viewMode = 'world';
                        camera.currentWorld = targetWorld;
                        // Use crystal ball's current view position and zoom
                        camera.x = -crystalBall.viewX;
                        camera.y = -crystalBall.viewY;
                        camera.targetZoom = crystalBall.zoom;
                        camera.zoom = crystalBall.zoom;
                        camera.isZooming = false;
                        document.getElementById('viewMode').textContent = 'World: ' + targetWorld.name;
                        camera.isTransitioning = false;
                    }, 300);
                }
            }
            
            if (!camera.isTransitioning) {
                if (camera.viewMode === 'world') {
                    camera.targetZoom = Math.max(camera.minWorldZoom, Math.min(camera.maxWorldZoom, camera.targetZoom));
                } else {
                    camera.targetZoom = Math.max(0.5, Math.min(6, camera.targetZoom));
                }
            }
        });
        
        canvas.addEventListener('mousedown', function(e) {
            // Handle middle mouse button for entity following
            if (e.button === 1) {
                e.preventDefault();
                console.log('mousedown middle button, viewMode:', camera.viewMode);
                
                // Check if we're in world view
                if (camera.viewMode === 'world' && camera.currentWorld) {
                    var rect = canvas.getBoundingClientRect();
                    var clickX = e.clientX - rect.left;
                    var clickY = e.clientY - rect.top;
                    var worldPos = screenToWorld(clickX, clickY);
                    
                    // Check if we're already following something - if so, stop following
                    if (camera.followingEntity) {
                        camera.followingEntity = null;
                        return;
                    }
                    
                    // Find the closest entity to the click position
                    var closestEntity = null;
                    var closestDistance = 100; // Maximum click distance in world/isometric units
                    
                    // Helper function to check entity distance using world coordinates
                    function checkEntityDistance(entity, type) {
                        // Convert entity tile position to world position
                        var entityWorldPos = worldToIsometric(entity.x, entity.y);
                        var distance = Math.sqrt(Math.pow(entityWorldPos.x - worldPos.x, 2) + Math.pow(entityWorldPos.y - worldPos.y, 2));
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestEntity = { type: type, entity: entity };
                        }
                    }
                    
                    // Check all armies
                    var allArmies = [];
                    
                    // Native kingdom armies
                    camera.currentWorld.kingdoms.forEach(kingdom => {
                        if (kingdom.alive) {
                            kingdom.armies.forEach(army => {
                                if (army.alive && army.worldId === camera.currentWorld.id) {
                                    allArmies.push(army);
                                }
                            });
                        }
                    });
                    
                    // Foreign kingdom armies
                    for (var w = 0; w < worlds.length; w++) {
                        if (w !== camera.currentWorld.id) {
                            worlds[w].kingdoms.forEach(kingdom => {
                                if (kingdom.alive) {
                                    kingdom.armies.forEach(army => {
                                        if (army.alive && army.worldId === camera.currentWorld.id) {
                                            allArmies.push(army);
                                        }
                                    });
                                }
                            });
                        }
                    }
                    
                    // Check distance to all armies
                    console.log('Found', allArmies.length, 'armies');
                    allArmies.forEach(army => {
                        var pos = army.getPosition();
                        var armyWorldPos = worldToIsometric(pos.x, pos.y);
                        var distance = Math.sqrt(Math.pow(armyWorldPos.x - worldPos.x, 2) + Math.pow(armyWorldPos.y - worldPos.y, 2));
                        console.log('Army at tile', pos, 'world pos:', armyWorldPos, 'distance:', distance);
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestEntity = { type: 'army', entity: army };
                        }
                    });
                    
                    // Check recruit groups
                    if (camera.currentWorld.recruits) {
                        camera.currentWorld.recruits.forEach(recruit => {
                            if (recruit.alive && recruit.size > 0) {
                                var pos = recruit.getPosition();
                                var recruitWorldPos = worldToIsometric(pos.x, pos.y);
                                var distance = Math.sqrt(Math.pow(recruitWorldPos.x - worldPos.x, 2) + Math.pow(recruitWorldPos.y - worldPos.y, 2));
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestEntity = { type: 'recruit', entity: recruit };
                                }
                            }
                        });
                    }
                    
                    // Check Giant Fish (Aqua world)
                    if (camera.currentWorld.name === 'Aqua' && game.giantFish.active) {
                        checkEntityDistance(game.giantFish, 'giantFish');
                    }
                    
                    // Check Terra Witch (Terra world)
                    if (camera.currentWorld.name === 'Terra' && game.terraWitch.active) {
                        // Special handling for witch since she flies at height
                        var witchWorldPos = worldToIsometric(game.terraWitch.x, game.terraWitch.y);
                        // Adjust for witch's visual height offset
                        var witchScreenY = witchWorldPos.y - (game.terraWitch.currentHeight || 0);
                        var distance = Math.sqrt(Math.pow(witchWorldPos.x - worldPos.x, 2) + Math.pow(witchScreenY - worldPos.y, 2));
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestEntity = { type: 'terraWitch', entity: game.terraWitch };
                        }
                    }
                    
                    // Check Nomad Tribe wagons (Aether world)
                    if (camera.currentWorld.name === 'Aether' && camera.currentWorld.nomadTribe) {
                        camera.currentWorld.nomadTribe.wagons.forEach((wagon, index) => {
                            var wagonWorldPos = worldToIsometric(wagon.x, wagon.y);
                            var distance = Math.sqrt(Math.pow(wagonWorldPos.x - worldPos.x, 2) + Math.pow(wagonWorldPos.y - worldPos.y, 2));
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestEntity = { type: 'nomadWagon', entity: wagon, wagonIndex: index };
                            }
                        });
                    }
                    
                    // Check Umbra Ghosts (Umbra world)
                    if (camera.currentWorld.name === 'Umbra' && camera.currentWorld.effect && camera.currentWorld.effect.ghosts) {
                        camera.currentWorld.effect.ghosts.forEach((ghost, index) => {
                            // Ghosts store positions in tile coordinates, same as armies
                            var ghostWorldPos = worldToIsometric(ghost.x, ghost.y);
                            var distance = Math.sqrt(Math.pow(ghostWorldPos.x - worldPos.x, 2) + Math.pow(ghostWorldPos.y - worldPos.y, 2));
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestEntity = { type: 'umbraGhost', entity: ghost, ghostIndex: index };
                            }
                        });
                    }
                    
                    // Check Ignis Shadow Armies (Ignis world)
                    if (camera.currentWorld.name === 'Ignis' && camera.currentWorld.effect && camera.currentWorld.effect.shadowArmies) {
                        camera.currentWorld.effect.shadowArmies.forEach((shadow, index) => {
                            // Get current position from route
                            var currentPos = null;
                            if (shadow.route && shadow.route.length > 0) {
                                if (shadow.routeIndex < shadow.route.length - 1) {
                                    var from = shadow.route[shadow.routeIndex];
                                    var to = shadow.route[shadow.routeIndex + 1];
                                    currentPos = {
                                        x: from.x + (to.x - from.x) * (shadow.moveProgress || 0),
                                        y: from.y + (to.y - from.y) * (shadow.moveProgress || 0)
                                    };
                                } else {
                                    currentPos = shadow.route[shadow.route.length - 1];
                                }
                                
                                var shadowWorldPos = worldToIsometric(currentPos.x, currentPos.y);
                                var distance = Math.sqrt(Math.pow(shadowWorldPos.x - worldPos.x, 2) + Math.pow(shadowWorldPos.y - worldPos.y, 2));
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestEntity = { type: 'ignisShadow', entity: shadow, shadowIndex: index };
                                }
                            }
                        });
                    }
                    
                    // Check Vita Walking Leaves (Vita world)
                    if (camera.currentWorld.name === 'Vita' && camera.currentWorld.effect && camera.currentWorld.effect.walkingLeaves) {
                        camera.currentWorld.effect.walkingLeaves.forEach((leaf, index) => {
                            if (leaf.state === 'walking') {
                                var leafWorldPos = worldToIsometric(leaf.currentX, leaf.currentY);
                                var distance = Math.sqrt(Math.pow(leafWorldPos.x - worldPos.x, 2) + Math.pow(leafWorldPos.y - worldPos.y, 2));
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestEntity = { type: 'vitaLeaf', entity: leaf, leafIndex: index };
                                }
                            }
                        });
                    }
                    
                    // Start following the closest entity if found
                    if (closestEntity) {
                        camera.followingEntity = closestEntity;
                        // Calculate initial offset based on entity type
                        var entityPos;
                        if (closestEntity.type === 'army' || closestEntity.type === 'recruit') {
                            entityPos = closestEntity.entity.getPosition();
                        } else {
                            // For other entities, they have direct x,y properties
                            entityPos = { x: closestEntity.entity.x, y: closestEntity.entity.y };
                        }
                        var entityIso = worldToIsometric(entityPos.x, entityPos.y);
                        camera.followOffsetX = camera.x + entityIso.x;
                        camera.followOffsetY = camera.y + entityIso.y;
                    }
                }
            } else if (camera.viewMode === 'ethereal' && crystalBall.currentWorld !== null) {
                // Handle middle mouse in ethereal view for crystal ball
                e.preventDefault();
                
                var rect = canvas.getBoundingClientRect();
                var clickX = e.clientX - rect.left;
                var clickY = e.clientY - rect.top;
                
                
                // Check if click is inside crystal ball
                const ballX = 0;
                const ballY = 0;
                const baseRadius = 135;
                const screenX = (ballX + camera.x) * camera.zoom + canvas.width / 2;
                const screenY = (ballY + camera.y) * camera.zoom + canvas.height / 2;
                const radius = baseRadius * camera.zoom;
                
                const distFromCenter = Math.sqrt(Math.pow(clickX - screenX, 2) + Math.pow(clickY - screenY, 2));
                
                
                if (distFromCenter <= radius) {
                    // Convert click to crystal ball coordinates
                    const relX = (clickX - screenX) / crystalBall.zoom;
                    const relY = (clickY - screenY) / crystalBall.zoom;
                    
                    // The crystal ball view is centered at crystalBall.viewX/viewY (in isometric coordinates)
                    // We need to convert the relative click position to tile coordinates
                    const clickIsoX = relX + crystalBall.viewX;
                    const clickIsoY = relY + crystalBall.viewY;
                    
                    // Convert from isometric to tile coordinates
                    const tilePos = isometricToTile(clickIsoX, clickIsoY);
                    
                    
                    // Check if we're already following - if so, stop
                    if (camera.followingEntity) {
                        camera.followingEntity = null;
                        return;
                    }
                    
                    // Find entities in the crystal ball's world
                    const cbWorld = worlds[crystalBall.currentWorld];
                    var closestEntity = null;
                    var closestDistance = 3; // Maximum distance in tiles
                    
                    // Check armies
                    var allArmies = [];
                    
                    // Native armies
                    cbWorld.kingdoms.forEach(kingdom => {
                        if (kingdom.alive) {
                            kingdom.armies.forEach(army => {
                                if (army.alive && army.worldId === crystalBall.currentWorld) {
                                    allArmies.push(army);
                                }
                            });
                        }
                    });
                    
                    // Foreign armies
                    for (var w = 0; w < worlds.length; w++) {
                        if (w !== crystalBall.currentWorld) {
                            worlds[w].kingdoms.forEach(kingdom => {
                                if (kingdom.alive) {
                                    kingdom.armies.forEach(army => {
                                        if (army.alive && army.worldId === crystalBall.currentWorld) {
                                            allArmies.push(army);
                                        }
                                    });
                                }
                            });
                        }
                    }
                    
                    // Check distance to armies
                    allArmies.forEach(army => {
                        var pos = army.getPosition();
                        var distance = Math.sqrt(Math.pow(pos.x - tilePos.x, 2) + Math.pow(pos.y - tilePos.y, 2));
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestEntity = { type: 'army', entity: army };
                        }
                    });
                    
                    // Check recruits
                    if (cbWorld.recruits) {
                        cbWorld.recruits.forEach(recruit => {
                            if (recruit.alive && recruit.size > 0) {
                                var pos = recruit.getPosition();
                                var distance = Math.sqrt(Math.pow(pos.x - tilePos.x, 2) + Math.pow(pos.y - tilePos.y, 2));
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestEntity = { type: 'recruit', entity: recruit };
                                }
                            }
                        });
                    }
                    
                    // Check world-specific entities
                    switch (cbWorld.name) {
                        case 'Aqua':
                            if (game.giantFish.active) {
                                var distance = Math.sqrt(Math.pow(game.giantFish.x - tilePos.x, 2) + 
                                                       Math.pow(game.giantFish.y - tilePos.y, 2));
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestEntity = { type: 'giantFish', entity: game.giantFish };
                                }
                            }
                            break;
                            
                        case 'Terra':
                            if (game.terraWitch.active) {
                                var distance = Math.sqrt(Math.pow(game.terraWitch.x - tilePos.x, 2) + 
                                                       Math.pow(game.terraWitch.y - tilePos.y, 2));
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestEntity = { type: 'terraWitch', entity: game.terraWitch };
                                }
                            }
                            break;
                            
                        case 'Aether':
                            if (cbWorld.nomadTribe) {
                                cbWorld.nomadTribe.wagons.forEach((wagon, index) => {
                                    var distance = Math.sqrt(Math.pow(wagon.x - tilePos.x, 2) + 
                                                           Math.pow(wagon.y - tilePos.y, 2));
                                    if (distance < closestDistance) {
                                        closestDistance = distance;
                                        closestEntity = { type: 'nomadWagon', entity: wagon, wagonIndex: index };
                                    }
                                });
                            }
                            break;
                            
                        case 'Umbra':
                            if (cbWorld.effect && cbWorld.effect.ghosts) {
                                cbWorld.effect.ghosts.forEach((ghost, index) => {
                                    var distance = Math.sqrt(Math.pow(ghost.x - tilePos.x, 2) + 
                                                           Math.pow(ghost.y - tilePos.y, 2));
                                    if (distance < closestDistance) {
                                        closestDistance = distance;
                                        closestEntity = { type: 'umbraGhost', entity: ghost, ghostIndex: index };
                                    }
                                });
                            }
                            break;
                            
                        case 'Ignis':
                            if (cbWorld.effect && cbWorld.effect.shadowArmies) {
                                cbWorld.effect.shadowArmies.forEach((shadow, index) => {
                                    // Get current position from route
                                    var currentPos = null;
                                    if (shadow.route && shadow.route.length > 0) {
                                        if (shadow.routeIndex < shadow.route.length - 1) {
                                            var from = shadow.route[shadow.routeIndex];
                                            var to = shadow.route[shadow.routeIndex + 1];
                                            currentPos = {
                                                x: from.x + (to.x - from.x) * (shadow.moveProgress || 0),
                                                y: from.y + (to.y - from.y) * (shadow.moveProgress || 0)
                                            };
                                        } else {
                                            currentPos = shadow.route[shadow.route.length - 1];
                                        }
                                        
                                        var distance = Math.sqrt(Math.pow(currentPos.x - tilePos.x, 2) + 
                                                               Math.pow(currentPos.y - tilePos.y, 2));
                                        if (distance < closestDistance) {
                                            closestDistance = distance;
                                            closestEntity = { type: 'ignisShadow', entity: shadow, shadowIndex: index };
                                        }
                                    }
                                });
                            }
                            break;
                            
                        case 'Vita':
                            if (cbWorld.effect && cbWorld.effect.walkingLeaves) {
                                cbWorld.effect.walkingLeaves.forEach((leaf, index) => {
                                    if (leaf.state === 'walking') {
                                        var distance = Math.sqrt(Math.pow(leaf.currentX - tilePos.x, 2) + 
                                                               Math.pow(leaf.currentY - tilePos.y, 2));
                                        if (distance < closestDistance) {
                                            closestDistance = distance;
                                            closestEntity = { type: 'vitaLeaf', entity: leaf, leafIndex: index };
                                        }
                                    }
                                });
                            }
                            break;
                    }
                    
                    // Start following if we found an entity
                    if (closestEntity) {
                        camera.followingEntity = closestEntity;
                    }
                }
            }
            
            // Normal drag handling for left/right mouse buttons (not middle)
            if (e.button !== 1) {
                // Don't start camera dragging if terraform is active
                if (!game.abilities.terraform.active) {
                    camera.isDragging = true;
                }
            }
            camera.lastMouseX = e.clientX;
            camera.lastMouseY = e.clientY;
            camera.dragStartX = e.clientX;
            camera.dragStartY = e.clientY;
            camera.hasDraggedSignificantly = false;
            
            // Handle terraform in mousedown for immediate response
            if (game.abilities.terraform.active && e.button === 0 && camera.viewMode === 'world' && camera.currentWorld && hoveredTile) {
                var rect = canvas.getBoundingClientRect();
                var clickX = e.clientX - rect.left;
                var clickY = e.clientY - rect.top;
                
                // Use the hovered tile instead of searching for best tile
                const tile = camera.currentWorld.tiles[hoveredTile.x][hoveredTile.y];
                
                if (tile) {
                    // Check if we have enough power
                    if (game.power >= game.abilities.terraform.cost) {
                        // Start terraforming
                        game.abilities.terraform.isDragging = true;
                        game.abilities.terraform.startTile = {x: hoveredTile.x, y: hoveredTile.y};
                        game.abilities.terraform.startHeight = tile.height;
                        game.abilities.terraform.dragStartY = e.clientY;
                        
                        // Consume power once
                        game.power -= game.abilities.terraform.cost;
                        updatePowerDisplay();
                    } else {
                        // Create sweat particles for insufficient power
                        const particleX = clickX;
                        const particleY = clickY - 40;
                        for (let i = 0; i < 8; i++) {
                            game.sweatParticles.push(new SweatParticle(particleX + (Math.random() - 0.5) * 30, particleY + Math.random() * 15));
                        }
                    }
                }
            }
            
        });
        
        // Check if mouse is hovering over any temple request
        function checkRequestHover() {
            camera.activeRequest = null;
            
            // Ensure game is initialized
            if (!game || !game.worlds || game.currentWorldIndex === undefined) {
                return;
            }
            
            const currentWorld = game.worlds[game.currentWorldIndex];
            if (!currentWorld || !currentWorld.kingdoms) {
                return;
            }
            
            currentWorld.kingdoms.forEach(kingdom => {
                if (kingdom.alive && kingdom.templeRequests.length > 0) {
                    const request = kingdom.templeRequests[0];
                    if (request.bubbleX !== undefined) {
                        const capitalIso = worldToIsometric(kingdom.capitalX, kingdom.capitalY);
                        const heightExtension = (kingdom.controlledCapitals.length - 1) * 8;
                        const requestYOffset = 90 + heightExtension + (kingdom.worldConqueror ? 10 : 0);
                        const reqX = capitalIso.x;
                        const reqY = capitalIso.y - requestYOffset;
                        
                        if (isMouseOverRequest(reqX, reqY, request.bubbleWidth || 70, request.bubbleHeight || 40)) {
                            camera.activeRequest = request;
                            canvas.style.cursor = 'pointer';
                            return;
                        }
                    }
                }
            });
            
            if (!camera.activeRequest && !camera.isDragging) {
                canvas.style.cursor = 'grab';
            }
        }
        
        canvas.addEventListener('mousemove', function(e) {
            // Store current mouse position for hover detection
            camera.currentMouseX = e.clientX;
            camera.currentMouseY = e.clientY;
            
            // Check for hovering over requests
            checkRequestHover();
            var rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            if (!camera.isDragging) {
                camera.zoomMouseX = e.clientX - rect.left;
                camera.zoomMouseY = e.clientY - rect.top;
            }
            
            if (camera.isDragging) {
                // Stop following entity when user drags
                if (camera.followingEntity) {
                    camera.followingEntity = null;
                }
                
                var dx = e.clientX - camera.lastMouseX;
                var dy = e.clientY - camera.lastMouseY;
                camera.x += dx / camera.zoom;
                camera.y += dy / camera.zoom;
                camera.lastMouseX = e.clientX;
                camera.lastMouseY = e.clientY;
                
                // Check if dragged significantly (more than threshold pixels)
                const dragDistance = Math.sqrt(
                    Math.pow(e.clientX - camera.dragStartX, 2) + 
                    Math.pow(e.clientY - camera.dragStartY, 2)
                );
                
                // Use higher threshold when powers are active to prevent accidental drags
                const threshold = (game.abilities.smite.active || game.abilities.bless.active) ? 10 : 5;
                
                if (dragDistance > threshold) {
                    camera.hasDraggedSignificantly = true;
                }
            }
            
            // Handle terraform dragging
            if (game.abilities.terraform.isDragging && game.abilities.terraform.active) {
                const deltaY = e.clientY - game.abilities.terraform.dragStartY;
                const heightChange = -deltaY * 0.001; // Negative because dragging up should increase height
                
                // Apply height change to the tile and surrounding tiles
                applyTerraformChanges(
                    camera.currentWorld,
                    game.abilities.terraform.startTile.x,
                    game.abilities.terraform.startTile.y,
                    game.abilities.terraform.startHeight + heightChange
                );
                
                // Check for request completion
                checkRequestCompletion('terraform', {
                    x: game.abilities.terraform.startTile.x,
                    y: game.abilities.terraform.startTile.y
                }, camera.currentWorld);
            }
            
            if (camera.viewMode === 'world' && camera.currentWorld) {
                var worldPos = screenToWorld(camera.zoomMouseX, camera.zoomMouseY);
                
                // Find the tile under the cursor accounting for elevation
                var bestTile = null;
                var bestDistance = Infinity;
                
                // Check a small area around the cursor position
                const checkRadius = 3;
                const baseTilePos = isometricToTile(worldPos.x, worldPos.y);
                
                for (let dx = -checkRadius; dx <= checkRadius; dx++) {
                    for (let dy = -checkRadius; dy <= checkRadius; dy++) {
                        const x = baseTilePos.x + dx;
                        const y = baseTilePos.y + dy;
                        
                        if (x >= 0 && x < WORLD_SIZE && y >= 0 && y < WORLD_SIZE) {
                            const tile = camera.currentWorld.tiles[x][y];
                            
                            // Calculate the screen position of this tile including elevation
                            let tileScreenX, tileScreenY;
                            if (tile.isoX !== undefined && tile.isoY !== undefined) {
                                tileScreenX = tile.isoX;
                                // Always account for height displacement
                                const elevationOffset = (tile.height - 0.65) * 240;
                                tileScreenY = tile.isoY - elevationOffset;
                            } else {
                                const iso = worldToIsometric(x, y);
                                tileScreenX = iso.x;
                                // Account for height displacement
                                const elevationOffset = (tile.height - 0.65) * 240;
                                tileScreenY = iso.y - elevationOffset;
                            }
                            
                            // Check if cursor is within the tile's diamond shape
                            const relX = worldPos.x - tileScreenX;
                            const relY = worldPos.y - tileScreenY;
                            
                            // Diamond hit test
                            if (Math.abs(relX / 33) + Math.abs(relY / 17) <= 1) {
                                const distance = Math.abs(relX) + Math.abs(relY);
                                if (distance < bestDistance) {
                                    bestDistance = distance;
                                    bestTile = {x, y};
                                }
                            }
                        }
                    }
                }
                
                // Also try direct tile calculation as fallback for high tiles
                if (!bestTile) {
                    const directTile = isometricToTile(worldPos.x, worldPos.y);
                    if (directTile.x >= 0 && directTile.x < WORLD_SIZE && 
                        directTile.y >= 0 && directTile.y < WORLD_SIZE) {
                        bestTile = directTile;
                    }
                }
                
                hoveredTile = bestTile;
            } else {
                hoveredTile = null;
            }
        });
        
        canvas.addEventListener('mouseup', function(e) {
            var rect = canvas.getBoundingClientRect();
            
            // If we dragged significantly, block power activation briefly
            if (camera.hasDraggedSignificantly) {
                camera.blockPowerActivation = true;
                setTimeout(function() {
                    camera.blockPowerActivation = false;
                }, 100); // 100ms delay to prevent accidental activation
            }
            
            // Handle middle mouse up for crystal ball entity following in ethereal view
            if (e.button === 1 && camera.viewMode === 'ethereal' && crystalBall.currentWorld !== null) {
                
                var clickX = e.clientX - rect.left;
                var clickY = e.clientY - rect.top;
                
                // Check if click is inside crystal ball
                const ballX = 0;
                const ballY = 0;
                const baseRadius = 135;
                const screenX = (ballX + camera.x) * camera.zoom + canvas.width / 2;
                const screenY = (ballY + camera.y) * camera.zoom + canvas.height / 2;
                const radius = baseRadius * camera.zoom;
                
                const distFromCenter = Math.sqrt(Math.pow(clickX - screenX, 2) + Math.pow(clickY - screenY, 2));
                
                if (distFromCenter <= radius) {
                    
                    // Convert click position to crystal ball view coordinates  
                    const relX = (clickX - screenX) / crystalBall.zoom;
                    const relY = (clickY - screenY) / crystalBall.zoom;
                    
                    // Convert to world coordinates in crystal ball view
                    const worldX = relX + crystalBall.viewX;
                    const worldY = relY + crystalBall.viewY;
                    const tilePos = isometricToTile(worldX, worldY);
                    
                    
                    // Check if we're already following - if so, stop
                    if (camera.followingEntity) {
                        camera.followingEntity = null;
                        return;
                    }
                    
                    // Find entities in the crystal ball's world
                    const cbWorld = worlds[crystalBall.currentWorld];
                    var closestEntity = null;
                    var closestDistance = 3; // Maximum distance in tiles
                    
                    // Check armies
                    var allArmies = [];
                    
                    // Native armies
                    cbWorld.kingdoms.forEach(kingdom => {
                        if (kingdom.alive) {
                            kingdom.armies.forEach(army => {
                                if (army.alive && army.worldId === crystalBall.currentWorld) {
                                    allArmies.push(army);
                                }
                            });
                        }
                    });
                    
                    // Foreign armies
                    for (var w = 0; w < worlds.length; w++) {
                        if (w !== crystalBall.currentWorld) {
                            worlds[w].kingdoms.forEach(kingdom => {
                                if (kingdom.alive) {
                                    kingdom.armies.forEach(army => {
                                        if (army.alive && army.worldId === crystalBall.currentWorld) {
                                            allArmies.push(army);
                                        }
                                    });
                                }
                            });
                        }
                    }
                    
                    // Check distance to armies
                    allArmies.forEach(army => {
                        var pos = army.getPosition();
                        var distance = Math.sqrt(Math.pow(pos.x - tilePos.x, 2) + Math.pow(pos.y - tilePos.y, 2));
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestEntity = { type: 'army', entity: army };
                        }
                    });
                    
                    // Check recruits
                    if (cbWorld.recruits) {
                        cbWorld.recruits.forEach(recruit => {
                            if (recruit.alive && recruit.size > 0) {
                                var pos = recruit.getPosition();
                                var distance = Math.sqrt(Math.pow(pos.x - tilePos.x, 2) + Math.pow(pos.y - tilePos.y, 2));
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestEntity = { type: 'recruit', entity: recruit };
                                }
                            }
                        });
                    }
                    
                    // Check world-specific entities
                    switch (cbWorld.name) {
                        case 'Aqua':
                            if (game.giantFish.active) {
                                var distance = Math.sqrt(Math.pow(game.giantFish.x - tilePos.x, 2) + 
                                                       Math.pow(game.giantFish.y - tilePos.y, 2));
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestEntity = { type: 'giantFish', entity: game.giantFish };
                                }
                            }
                            break;
                            
                        case 'Terra':
                            if (game.terraWitch.active) {
                                var distance = Math.sqrt(Math.pow(game.terraWitch.x - tilePos.x, 2) + 
                                                       Math.pow(game.terraWitch.y - tilePos.y, 2));
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestEntity = { type: 'terraWitch', entity: game.terraWitch };
                                }
                            }
                            break;
                            
                        case 'Aether':
                            if (cbWorld.nomadTribe) {
                                cbWorld.nomadTribe.wagons.forEach((wagon, index) => {
                                    var distance = Math.sqrt(Math.pow(wagon.x - tilePos.x, 2) + 
                                                           Math.pow(wagon.y - tilePos.y, 2));
                                    if (distance < closestDistance) {
                                        closestDistance = distance;
                                        closestEntity = { type: 'nomadWagon', entity: wagon, wagonIndex: index };
                                    }
                                });
                            }
                            break;
                            
                        case 'Umbra':
                            if (cbWorld.effect && cbWorld.effect.ghosts) {
                                cbWorld.effect.ghosts.forEach((ghost, index) => {
                                    var distance = Math.sqrt(Math.pow(ghost.x - tilePos.x, 2) + 
                                                           Math.pow(ghost.y - tilePos.y, 2));
                                    if (distance < closestDistance) {
                                        closestDistance = distance;
                                        closestEntity = { type: 'umbraGhost', entity: ghost, ghostIndex: index };
                                    }
                                });
                            }
                            break;
                            
                        case 'Ignis':
                            if (cbWorld.effect && cbWorld.effect.shadowArmies) {
                                cbWorld.effect.shadowArmies.forEach((shadow, index) => {
                                    // Get current position from route
                                    var currentPos = null;
                                    if (shadow.route && shadow.route.length > 0) {
                                        if (shadow.routeIndex < shadow.route.length - 1) {
                                            var from = shadow.route[shadow.routeIndex];
                                            var to = shadow.route[shadow.routeIndex + 1];
                                            currentPos = {
                                                x: from.x + (to.x - from.x) * (shadow.moveProgress || 0),
                                                y: from.y + (to.y - from.y) * (shadow.moveProgress || 0)
                                            };
                                        } else {
                                            currentPos = shadow.route[shadow.route.length - 1];
                                        }
                                        
                                        var distance = Math.sqrt(Math.pow(currentPos.x - tilePos.x, 2) + 
                                                               Math.pow(currentPos.y - tilePos.y, 2));
                                        if (distance < closestDistance) {
                                            closestDistance = distance;
                                            closestEntity = { type: 'ignisShadow', entity: shadow, shadowIndex: index };
                                        }
                                    }
                                });
                            }
                            break;
                            
                        case 'Vita':
                            if (cbWorld.effect && cbWorld.effect.walkingLeaves) {
                                cbWorld.effect.walkingLeaves.forEach((leaf, index) => {
                                    if (leaf.state === 'walking') {
                                        var distance = Math.sqrt(Math.pow(leaf.currentX - tilePos.x, 2) + 
                                                               Math.pow(leaf.currentY - tilePos.y, 2));
                                        if (distance < closestDistance) {
                                            closestDistance = distance;
                                            closestEntity = { type: 'vitaLeaf', entity: leaf, leafIndex: index };
                                        }
                                    }
                                });
                            }
                            break;
                    }
                    
                    // Start following if we found an entity
                    if (closestEntity) {
                        camera.followingEntity = closestEntity;
                    }
                }
            }
            
            camera.isDragging = false;
            camera.hasDraggedSignificantly = false;
            camera.zoomMouseX = e.clientX - rect.left;
            camera.zoomMouseY = e.clientY - rect.top;
            
            // Stop terraform dragging
            if (game.abilities.terraform.isDragging) {
                game.abilities.terraform.isDragging = false;
                game.abilities.terraform.startTile = null;
                game.abilities.terraform.startHeight = null;
                game.abilities.terraform.dragStartY = null;
            }
        });

        canvas.addEventListener('click', function(e) {
            // Don't activate powers if user was dragging or if activation is blocked
            if (camera.hasDraggedSignificantly || camera.blockPowerActivation) {
                return;
            }
            
            var rect = canvas.getBoundingClientRect();
            var clickX = e.clientX - rect.left;
            var clickY = e.clientY - rect.top;
            
            // Check if clicking on a request bubble
            if (camera.viewMode === 'world' && camera.currentWorld) {
                // Check all kingdoms for active requests
                let clickedRequest = null;
                camera.currentWorld.kingdoms.forEach(kingdom => {
                    if (kingdom.alive && kingdom.templeRequests.length > 0 && !clickedRequest) {
                        const request = kingdom.templeRequests[0];
                        if (request.bubbleX !== undefined && request.bubbleY !== undefined) {
                            // Convert click to world coordinates
                            const worldPos = screenToWorld(clickX, clickY);
                            
                            // Check if click is within bubble bounds
                            const bubbleWidth = request.bubbleWidth || 70;
                            const bubbleHeight = request.bubbleHeight || 40;
                            
                            if (Math.abs(worldPos.x - request.bubbleX) < bubbleWidth/2 && 
                                Math.abs(worldPos.y - request.bubbleY) < bubbleHeight/2) {
                                clickedRequest = request;
                            }
                        }
                    }
                });
                
                if (clickedRequest) {
                    // Create click effect at the request bubble position
                    game.divineEffects.push(new RequestBubbleClickEffect(
                        clickedRequest.bubbleX, 
                        clickedRequest.bubbleY, 
                        camera.currentWorld.id
                    ));
                    
                    // Handle messenger army spawning/redirecting
                    console.log('Clicked request:', clickedRequest);
                    console.log('Messenger army exists?', clickedRequest.messengerArmy);
                    console.log('Messenger alive?', clickedRequest.messengerArmy ? clickedRequest.messengerArmy.alive : 'no messenger');
                    
                    if (clickedRequest.messengerArmy && clickedRequest.messengerArmy.alive) {
                        // Messenger exists and is alive
                        if (clickedRequest.messengerArmy.isReturning) {
                            // Redirect the returning messenger back to show location
                            const army = clickedRequest.messengerArmy;
                            army.isReturning = false;
                            army.pointingTimer = 0;
                            
                            // Recalculate target based on request type (same logic as initial spawn)
                            let targetX, targetY;
                            const kingdom = camera.currentWorld.kingdoms.find(k => k.templeRequests.includes(clickedRequest));
                            const requestCapital = { x: kingdom.capitalX, y: kingdom.capitalY };
                            
                            if (clickedRequest.target && clickedRequest.target !== kingdom) {
                                // ATTACK REQUEST: Move towards enemy kingdom
                                const targetKingdom = clickedRequest.target;
                                if (targetKingdom.capitalX !== undefined && targetKingdom.capitalY !== undefined) {
                                    // Calculate direction from our capital to their capital
                                    const dx = targetKingdom.capitalX - requestCapital.x;
                                    const dy = targetKingdom.capitalY - requestCapital.y;
                                    const angle = Math.atan2(dy, dx);
                                    
                                    // Move 5-10 tiles in that direction (staying in our territory)
                                    let bestDistance = 0;
                                    targetX = requestCapital.x;
                                    targetY = requestCapital.y;
                                    
                                    // Try different distances to find a good spot
                                    for (let dist = 10; dist >= 5; dist--) {
                                        const testX = Math.floor(requestCapital.x + Math.cos(angle) * dist);
                                        const testY = Math.floor(requestCapital.y + Math.sin(angle) * dist);
                                        
                                        // Check if this position is valid and in our territory
                                        if (testX >= 0 && testX < WORLD_SIZE && testY >= 0 && testY < WORLD_SIZE) {
                                            const tile = camera.currentWorld.tiles[testX][testY];
                                            if (tile && tile.owner === kingdom.id) {
                                                targetX = testX;
                                                targetY = testY;
                                                bestDistance = dist;
                                                break; // Found a good spot
                                            }
                                        }
                                    }
                                    
                                    // If we couldn't find a spot in our territory, just move a few tiles
                                    if (bestDistance === 0) {
                                        targetX = Math.floor(requestCapital.x + Math.cos(angle) * 3);
                                        targetY = Math.floor(requestCapital.y + Math.sin(angle) * 3);
                                        targetX = Math.max(0, Math.min(WORLD_SIZE - 1, targetX));
                                        targetY = Math.max(0, Math.min(WORLD_SIZE - 1, targetY));
                                    }
                                } else {
                                    targetX = requestCapital.x + 3;
                                    targetY = requestCapital.y;
                                }
                            } else {
                                // BLESS REQUEST: Stand below the capital and point up
                                targetX = requestCapital.x;
                                targetY = requestCapital.y + 5; // 5 tiles below capital
                                
                                // Make sure position is valid and in our territory
                                if (targetY >= WORLD_SIZE || targetX < 0 || targetX >= WORLD_SIZE) {
                                    targetY = requestCapital.y - 5; // Try above if below doesn't work
                                }
                                
                                if (targetY < 0 || targetY >= WORLD_SIZE) {
                                    // Try to the side
                                    targetX = requestCapital.x + 5;
                                    targetY = requestCapital.y;
                                }
                                
                                // Ensure within bounds
                                targetX = Math.max(0, Math.min(WORLD_SIZE - 1, targetX));
                                targetY = Math.max(0, Math.min(WORLD_SIZE - 1, targetY));
                                
                                // Verify it's in our territory
                                if (targetX >= 0 && targetX < WORLD_SIZE && targetY >= 0 && targetY < WORLD_SIZE) {
                                    const tile = camera.currentWorld.tiles[targetX][targetY];
                                    if (!tile || tile.owner !== kingdom.id) {
                                        // Not in our territory, stay close to capital
                                        targetX = requestCapital.x + 2;
                                        targetY = requestCapital.y + 2;
                                        targetX = Math.max(0, Math.min(WORLD_SIZE - 1, targetX));
                                        targetY = Math.max(0, Math.min(WORLD_SIZE - 1, targetY));
                                    }
                                }

                                targetX = army.targetX;
                                targetY = army.targetY;
                            }
                            
                            army.targetX = targetX;
                            army.targetY = targetY;
                            army.path = army.calculatePath();
                            army.pathIndex = 0;
                            army.moveProgress = 0;
                            console.log('Redirecting returning messenger back to show location');
                        }
                        // If messenger is already going out or pointing, do nothing
                    } else {
                        // No messenger exists or it's dead, spawn a new one
                        // Clean up dead messenger reference
                        if (clickedRequest.messengerArmy && !clickedRequest.messengerArmy.alive) {
                            console.log('Cleaning up dead messenger reference');
                            clickedRequest.messengerArmy = null;
                        }
                        
                        if (!clickedRequest.messengerArmy) {
                        try {
                            const kingdom = camera.currentWorld.kingdoms.find(k => k.templeRequests.includes(clickedRequest));
                            console.log('Found kingdom:', kingdom);
                            console.log('Kingdom capital:', kingdom ? {x: kingdom.capitalX, y: kingdom.capitalY} : 'no kingdom');
                            console.log('Clicked request:', clickedRequest);
                            if (kingdom && clickedRequest.capital) {
                            // Use the capital that generated the request
                            const requestCapital = { 
                                x: clickedRequest.capital.x, 
                                y: clickedRequest.capital.y, 
                                isMainCapital: clickedRequest.capital.x === kingdom.capitalX && clickedRequest.capital.y === kingdom.capitalY
                            };
                            console.log('Using capital:', requestCapital);
                            
                            // Determine destination based on request type
                            let targetX, targetY;
                            if (clickedRequest.target && clickedRequest.target !== kingdom) {
                                // ATTACK REQUEST: Move towards enemy kingdom
                                const targetKingdom = clickedRequest.target;
                                if (targetKingdom.capitalX !== undefined && targetKingdom.capitalY !== undefined) {
                                    // Calculate direction from our capital to their capital
                                    const dx = targetKingdom.capitalX - requestCapital.x;
                                    const dy = targetKingdom.capitalY - requestCapital.y;
                                    const angle = Math.atan2(dy, dx);
                                    
                                    // Move 5-10 tiles in that direction (staying in our territory)
                                    let bestDistance = 0;
                                    targetX = requestCapital.x;
                                    targetY = requestCapital.y;
                                    
                                    // Try different distances to find a good spot
                                    for (let dist = 10; dist >= 5; dist--) {
                                        const testX = Math.floor(requestCapital.x + Math.cos(angle) * dist);
                                        const testY = Math.floor(requestCapital.y + Math.sin(angle) * dist);
                                        
                                        // Check if this position is valid and in our territory
                                        if (testX >= 0 && testX < WORLD_SIZE && testY >= 0 && testY < WORLD_SIZE) {
                                            const tile = camera.currentWorld.tiles[testX][testY];
                                            if (tile && tile.owner === kingdom.id) {
                                                targetX = testX;
                                                targetY = testY;
                                                bestDistance = dist;
                                                break; // Found a good spot
                                            }
                                        }
                                    }
                                    
                                    // If we couldn't find a spot in our territory, just move a few tiles
                                    if (bestDistance === 0) {
                                        targetX = Math.floor(requestCapital.x + Math.cos(angle) * 3);
                                        targetY = Math.floor(requestCapital.y + Math.sin(angle) * 3);
                                        targetX = Math.max(0, Math.min(WORLD_SIZE - 1, targetX));
                                        targetY = Math.max(0, Math.min(WORLD_SIZE - 1, targetY));
                                    }
                                } else {
                                    targetX = requestCapital.x + 3;
                                    targetY = requestCapital.y;
                                }
                            } else {
                                // BLESS REQUEST: Stand below the capital and point up
                                targetX = requestCapital.x;
                                targetY = requestCapital.y + 5; // 5 tiles below capital
                                
                                // Make sure position is valid and in our territory
                                if (targetY >= WORLD_SIZE || targetX < 0 || targetX >= WORLD_SIZE) {
                                    targetY = requestCapital.y - 5; // Try above if below doesn't work
                                }
                                
                                if (targetY < 0 || targetY >= WORLD_SIZE) {
                                    // Try to the side
                                    targetX = requestCapital.x + 5;
                                    targetY = requestCapital.y;
                                }
                                
                                // Ensure within bounds
                                targetX = Math.max(0, Math.min(WORLD_SIZE - 1, targetX));
                                targetY = Math.max(0, Math.min(WORLD_SIZE - 1, targetY));
                                
                                // Verify it's in our territory
                                if (targetX >= 0 && targetX < WORLD_SIZE && targetY >= 0 && targetY < WORLD_SIZE) {
                                    const tile = camera.currentWorld.tiles[targetX][targetY];
                                    if (!tile || tile.owner !== kingdom.id) {
                                        // Not in our territory, stay close to capital
                                        targetX = requestCapital.x + 2;
                                        targetY = requestCapital.y + 2;
                                        targetX = Math.max(0, Math.min(WORLD_SIZE - 1, targetX));
                                        targetY = Math.max(0, Math.min(WORLD_SIZE - 1, targetY));
                                    }
                                }
                            }
                            
                            // Create the messenger army
                            console.log('Creating army with params:', kingdom, 3, requestCapital.x, requestCapital.y, targetX, targetY, camera.currentWorld.id);
                            const messengerArmy = new Army(kingdom, 3, requestCapital.x, requestCapital.y, targetX, targetY, camera.currentWorld.id);
                            
                            // Check if path was calculated successfully
                            if (!messengerArmy.path || messengerArmy.path.length === 0) {
                                console.error('Failed to calculate path for messenger');
                                console.log('From:', requestCapital.x, requestCapital.y, 'To:', targetX, targetY);
                                // Try a closer destination
                                targetX = Math.floor(requestCapital.x + (targetX > requestCapital.x ? 5 : -5));
                                targetY = Math.floor(requestCapital.y + (targetY > requestCapital.y ? 5 : -5));
                                targetX = Math.max(0, Math.min(WORLD_SIZE - 1, targetX));
                                targetY = Math.max(0, Math.min(WORLD_SIZE - 1, targetY));
                                messengerArmy.targetX = targetX;
                                messengerArmy.targetY = targetY;
                                messengerArmy.path = messengerArmy.calculatePath();
                            }
                            
                            messengerArmy.task = 'messenger';
                            messengerArmy.isKing = requestCapital.isMainCapital;
                            console.log(`Creating ${messengerArmy.isKing ? 'KING' : 'BARON'} messenger from capital at (${requestCapital.x}, ${requestCapital.y}), isMainCapital: ${requestCapital.isMainCapital}`);
                            messengerArmy.request = clickedRequest;
                            messengerArmy.returnTarget = { x: requestCapital.x, y: requestCapital.y };
                            messengerArmy.pointingTimer = 0;
                            messengerArmy.maxPointingTime = 300; // Point for 300 ticks (~10 seconds at 30 fps)
                            messengerArmy.isReturning = false;
                            
                            kingdom.armies.push(messengerArmy);
                            clickedRequest.messengerArmy = messengerArmy;
                            console.log('Created messenger army:', messengerArmy);
                            console.log('Kingdom armies count:', kingdom.armies.length);
                            console.log('Messenger path length:', messengerArmy.path ? messengerArmy.path.length : 'no path');
                            }
                        } catch (error) {
                            console.error('Error creating messenger army:', error);
                        }
                        }
                    }
                    
                    return; // Don't process other clicks
                }
            }
            
            // Handle normal world view clicks
            if (camera.viewMode === 'world' && camera.currentWorld) {
                var worldPos = screenToWorld(clickX, clickY);
                var tilePos = isometricToTile(worldPos.x, worldPos.y);
                
                // Handle Sculpt ability
                if (game.abilities.sculpt.active) {
                    // Find the actual tile under cursor accounting for elevation
                    var bestTile = null;
                    var bestDistance = Infinity;
                    
                    const checkRadius = game.abilities.sculpt.radius;
                    const baseTilePos = tilePos;
                    
                    for (let dx = -checkRadius; dx <= checkRadius; dx++) {
                        for (let dy = -checkRadius; dy <= checkRadius; dy++) {
                            const x = baseTilePos.x + dx;
                            const y = baseTilePos.y + dy;
                            
                            if (x >= 0 && x < WORLD_SIZE && y >= 0 && y < WORLD_SIZE) {
                                const tile = camera.currentWorld.tiles[x][y];
                                
                                // Calculate the screen position of this tile including elevation
                                let tileScreenX, tileScreenY;
                                if (tile.isoX !== undefined && tile.isoY !== undefined) {
                                    tileScreenX = tile.isoX;
                                    tileScreenY = tile.active ? tile.renderY : tile.isoY;
                                } else {
                                    const iso = worldToIsometric(x, y);
                                    tileScreenX = iso.x;
                                    tileScreenY = iso.y;
                                }
                                
                                // Check if cursor is within the tile's diamond shape
                                const relX = worldPos.x - tileScreenX;
                                const relY = worldPos.y - tileScreenY;
                                
                                // Diamond hit test
                                if (Math.abs(relX / 33) + Math.abs(relY / 17) <= 1) {
                                    const distance = Math.abs(relX) + Math.abs(relY);
                                    if (distance < bestDistance) {
                                        bestDistance = distance;
                                        bestTile = {x, y};
                                    }
                                }
                            }
                        }
                    }
                    
                    if (bestTile) {
                        // Check if we have enough power
                        if (game.power >= game.abilities.sculpt.cost) {
                            const tile = camera.currentWorld.tiles[bestTile.x][bestTile.y];
                            const mode = tile.active ? 'remove' : 'add';
                            applySculptChanges(camera.currentWorld, bestTile.x, bestTile.y, mode);
                            
                            // Consume power
                            game.power -= game.abilities.sculpt.cost;
                            updatePowerDisplay();
                        } else {
                            // Create sweat particles for insufficient power
                            const particleX = clickX;
                            const particleY = clickY - 40;
                            for (let i = 0; i < 8; i++) {
                                game.sweatParticles.push(new SweatParticle(particleX + (Math.random() - 0.5) * 30, particleY + Math.random() * 15));
                            }
                        }
                    }
                }
                
                // Handle Smite ability
                else if (game.abilities.smite.active) {
                    // Find the actual tile under cursor accounting for elevation
                    var bestTile = null;
                    var bestDistance = Infinity;
                    
                    const checkRadius = 3;
                    const baseTilePos = tilePos;
                    
                    for (let dx = -checkRadius; dx <= checkRadius; dx++) {
                        for (let dy = -checkRadius; dy <= checkRadius; dy++) {
                            const x = baseTilePos.x + dx;
                            const y = baseTilePos.y + dy;
                            
                            if (x >= 0 && x < WORLD_SIZE && y >= 0 && y < WORLD_SIZE) {
                                const tile = camera.currentWorld.tiles[x][y];
                                
                                // Calculate the screen position of this tile including elevation
                                let tileScreenX, tileScreenY;
                                if (tile.isoX !== undefined && tile.isoY !== undefined) {
                                    tileScreenX = tile.isoX;
                                    tileScreenY = tile.active ? tile.renderY : tile.isoY;
                                } else {
                                    const iso = worldToIsometric(x, y);
                                    tileScreenX = iso.x;
                                    tileScreenY = iso.y;
                                }
                                
                                // Check if cursor is within the tile's diamond shape
                                const relX = worldPos.x - tileScreenX;
                                const relY = worldPos.y - tileScreenY;
                                
                                // Diamond hit test
                                if (Math.abs(relX / 33) + Math.abs(relY / 17) <= 1) {
                                    const distance = Math.abs(relX) + Math.abs(relY);
                                    if (distance < bestDistance) {
                                        bestDistance = distance;
                                        bestTile = {x, y};
                                    }
                                }
                            }
                        }
                    }
                    
                    if (bestTile) {
                        // Check if we have enough power
                        if (game.power >= game.abilities.smite.cost) {
                            const hitTargets = useSmite(camera.currentWorld, bestTile.x, bestTile.y);
                            // Keep power selected after use
                        } else {
                            // Create sweat particles for insufficient power
                            const particleX = clickX;
                            const particleY = clickY - 20; // Above the cursor
                            for (let i = 0; i < 8; i++) {
                                game.sweatParticles.push(new SweatParticle(particleX + (Math.random() - 0.5) * 30, particleY));
                            }
                        }
                    }
                }
                
                // Handle Bless ability
                else if (game.abilities.bless.active && tilePos.x >= 0 && tilePos.x < WORLD_SIZE && 
                    tilePos.y >= 0 && tilePos.y < WORLD_SIZE) {
                    const tile = camera.currentWorld.tiles[tilePos.x][tilePos.y];
                    if (tile.owner !== null) {
                        // Check if we have enough power
                        const actualCost = getBlessingCost(tile.owner);
                        if (game.power >= actualCost) {
                            useBless(tile.owner);
                            
                            // Check for request completion
                            const kingdom = findKingdomById(tile.owner);
                            if (kingdom) {
                                checkRequestCompletion('blessing', { kingdom }, camera.currentWorld);
                            }
                            // Keep power selected after use
                        } else {
                            // Create sweat particles for insufficient power
                            const particleX = clickX;
                            const particleY = clickY - 40; // Above the cursor
                            for (let i = 0; i < 8; i++) {
                                game.sweatParticles.push(new SweatParticle(particleX + (Math.random() - 0.5) * 30, particleY + Math.random() * 15));
                            }
                        }
                    }
                }
                
                // Handle War ability
                else if (game.abilities.war.active && tilePos.x >= 0 && tilePos.x < WORLD_SIZE && 
                    tilePos.y >= 0 && tilePos.y < WORLD_SIZE) {
                    const tile = camera.currentWorld.tiles[tilePos.x][tilePos.y];
                    if (tile.owner !== null) {
                        if (!game.abilities.war.firstKingdom) {
                            // Select first kingdom (attacker)
                            game.abilities.war.firstKingdom = tile.owner;
                        } else if (tile.owner !== game.abilities.war.firstKingdom) {
                            // Select second kingdom (defender) - must be different
                            const firstKingdom = findKingdomById(game.abilities.war.firstKingdom);
                            const secondKingdom = findKingdomById(tile.owner);
                            
                            if (firstKingdom && secondKingdom) {
                                // Check if they border each other (including through portals)
                                if (checkKingdomsBorder(game.abilities.war.firstKingdom, tile.owner)) {
                                    // Check if we have enough power
                                    if (game.power >= game.abilities.war.cost) {
                                        declareWar(game.abilities.war.firstKingdom, tile.owner);
                                        // Reset selection but keep power active
                                        game.abilities.war.firstKingdom = null;
                                        game.abilities.war.secondKingdom = null;
                                    } else {
                                        // Create sweat particles for insufficient power
                                        const particleX = clickX;
                                        const particleY = clickY - 40;
                                        for (let i = 0; i < 8; i++) {
                                            game.sweatParticles.push(new SweatParticle(particleX + (Math.random() - 0.5) * 30, particleY + Math.random() * 15));
                                        }
                                    }
                                } else {
                                    // Kingdoms don't border - reset selection
                                    game.abilities.war.firstKingdom = null;
                                    game.abilities.war.secondKingdom = null;
                                }
                            }
                        } else {
                            // Clicked same kingdom - reset selection
                            game.abilities.war.firstKingdom = null;
                            game.abilities.war.secondKingdom = null;
                        }
                    } else {
                        // Clicked on empty tile - reset selection
                        game.abilities.war.firstKingdom = null;
                        game.abilities.war.secondKingdom = null;
                    }
                }
                
                // Handle Peace ability
                else if (game.abilities.peace.active && tilePos.x >= 0 && tilePos.x < WORLD_SIZE && 
                    tilePos.y >= 0 && tilePos.y < WORLD_SIZE) {
                    const tile = camera.currentWorld.tiles[tilePos.x][tilePos.y];
                    if (tile.owner !== null) {
                        if (!game.abilities.peace.firstKingdom) {
                            // Select first kingdom
                            game.abilities.peace.firstKingdom = tile.owner;
                        } else if (tile.owner !== game.abilities.peace.firstKingdom) {
                            // Select second kingdom - must be different and at war
                            const firstKingdom = findKingdomById(game.abilities.peace.firstKingdom);
                            const secondKingdom = findKingdomById(tile.owner);
                            
                            if (firstKingdom && secondKingdom) {
                                const atWar = areKingdomsAtWar(game.abilities.peace.firstKingdom, tile.owner);
                                
                                if (atWar) {
                                    // Check if we have enough power
                                    if (game.power >= game.abilities.peace.cost) {
                                        declarePeace(game.abilities.peace.firstKingdom, tile.owner);
                                        // Reset selection but keep power active
                                        game.abilities.peace.firstKingdom = null;
                                        game.abilities.peace.secondKingdom = null;
                                    } else {
                                        // Create sweat particles for insufficient power
                                        const particleX = clickX;
                                        const particleY = clickY - 40;
                                        for (let i = 0; i < 8; i++) {
                                            game.sweatParticles.push(new SweatParticle(particleX + (Math.random() - 0.5) * 30, particleY + Math.random() * 15));
                                        }
                                    }
                                } else {
                                    // Kingdoms not at war - reset selection
                                    game.abilities.peace.firstKingdom = null;
                                    game.abilities.peace.secondKingdom = null;
                                }
                            } else {
                                // One or both kingdoms not found
                                game.abilities.peace.firstKingdom = null;
                                game.abilities.peace.secondKingdom = null;
                            }
                        } else {
                            // Clicked same kingdom - reset selection
                            game.abilities.peace.firstKingdom = null;
                            game.abilities.peace.secondKingdom = null;
                        }
                    } else {
                        // Clicked on empty tile - reset selection
                        game.abilities.peace.firstKingdom = null;
                        game.abilities.peace.secondKingdom = null;
                    }
                }
                
                // Handle Portal ability
                else if (game.abilities.portal.active) {
                    // Find the actual tile under cursor accounting for elevation
                    var bestTile = null;
                    var bestDistance = Infinity;
                    
                    const checkRadius = 3;
                    const baseTilePos = tilePos;
                    
                    for (let dx = -checkRadius; dx <= checkRadius; dx++) {
                        for (let dy = -checkRadius; dy <= checkRadius; dy++) {
                            const x = baseTilePos.x + dx;
                            const y = baseTilePos.y + dy;
                            
                            if (x >= 0 && x < WORLD_SIZE && y >= 0 && y < WORLD_SIZE) {
                                const tile = camera.currentWorld.tiles[x][y];
                                
                                // Calculate the screen position of this tile including elevation
                                let tileScreenX, tileScreenY;
                                if (tile.isoX !== undefined && tile.isoY !== undefined) {
                                    tileScreenX = tile.isoX;
                                    tileScreenY = tile.active ? tile.renderY : tile.isoY;
                                } else {
                                    const iso = worldToIsometric(x, y);
                                    tileScreenX = iso.x;
                                    tileScreenY = iso.y;
                                }
                                
                                // Check if cursor is within the tile's diamond shape
                                const relX = worldPos.x - tileScreenX;
                                const relY = worldPos.y - tileScreenY;
                                
                                // Diamond hit test
                                if (Math.abs(relX / 33) + Math.abs(relY / 17) <= 1) {
                                    const distance = Math.abs(relX) + Math.abs(relY);
                                    if (distance < bestDistance) {
                                        bestDistance = distance;
                                        bestTile = {x, y};
                                    }
                                }
                            }
                        }
                    }
                    
                    if (bestTile) {
                        if (!game.abilities.portal.firstTile) {
                            // Select first tile
                            game.abilities.portal.firstTile = {
                                x: bestTile.x,
                                y: bestTile.y,
                                worldId: camera.currentWorld.id
                            };
                        } else {
                            // Select second tile
                            const firstTile = game.abilities.portal.firstTile;
                            const secondTile = {
                                x: bestTile.x,
                                y: bestTile.y,
                                worldId: camera.currentWorld.id
                            };
                        
                        // Validate portal placement
                        let isValid = true;
                        let errorMessage = "";
                        
                        // Check if same tile
                        if (firstTile.x === secondTile.x && firstTile.y === secondTile.y && 
                            firstTile.worldId === secondTile.worldId) {
                            isValid = false;
                            errorMessage = "Cannot place portal on the same tile";
                        }
                        
                        // Check if both tiles are in the same kingdom's territory in the same world
                        if (isValid && firstTile.worldId === secondTile.worldId) {
                            const world = camera.currentWorld;
                            const tile1 = world.tiles[firstTile.x][firstTile.y];
                            const tile2 = world.tiles[secondTile.x][secondTile.y];
                            
                            if (tile1.owner !== null && tile1.owner === tile2.owner) {
                                isValid = false;
                                errorMessage = "Cannot place both portal ends in the same kingdom";
                            }
                        }
                        
                        if (isValid) {
                            // Check if we have enough power
                            if (game.power >= game.abilities.portal.cost) {
                                createDivinePortal(firstTile, secondTile);
                                // Reset selection but keep power active
                                game.abilities.portal.firstTile = null;
                                game.abilities.portal.secondTile = null;
                            } else {
                                // Create sweat particles for insufficient power
                                const particleX = clickX;
                                const particleY = clickY - 40;
                                for (let i = 0; i < 8; i++) {
                                    game.sweatParticles.push(new SweatParticle(particleX + (Math.random() - 0.5) * 30, particleY + Math.random() * 15));
                                }
                            }
                        } else {
                            // Invalid placement - reset selection
                            game.abilities.portal.firstTile = null;
                            game.abilities.portal.secondTile = null;
                            
                            // Could show error message to player
                            console.log(errorMessage);
                        }
                    }
                    }
                }
                
                // Handle Kingdom ability
                else if (game.abilities.kingdom.active) {
                    // Find the actual tile under cursor accounting for elevation
                    var bestTile = null;
                    var bestDistance = Infinity;
                    
                    const checkRadius = 3;
                    const baseTilePos = tilePos;
                    
                    for (let dx = -checkRadius; dx <= checkRadius; dx++) {
                        for (let dy = -checkRadius; dy <= checkRadius; dy++) {
                            const x = baseTilePos.x + dx;
                            const y = baseTilePos.y + dy;
                            
                            if (x >= 0 && x < WORLD_SIZE && y >= 0 && y < WORLD_SIZE) {
                                const tile = camera.currentWorld.tiles[x][y];
                                
                                // Calculate the screen position of this tile including elevation
                                let tileScreenX, tileScreenY;
                                if (tile.isoX !== undefined && tile.isoY !== undefined) {
                                    tileScreenX = tile.isoX;
                                    tileScreenY = tile.active ? tile.renderY : tile.isoY;
                                } else {
                                    const iso = worldToIsometric(x, y);
                                    tileScreenX = iso.x;
                                    tileScreenY = iso.y;
                                }
                                
                                // Check if cursor is within the tile's diamond shape
                                const relX = worldPos.x - tileScreenX;
                                const relY = worldPos.y - tileScreenY;
                                
                                // Diamond hit test
                                if (Math.abs(relX / 33) + Math.abs(relY / 17) <= 1) {
                                    const distance = Math.abs(relX) + Math.abs(relY);
                                    if (distance < bestDistance) {
                                        bestDistance = distance;
                                        bestTile = {x, y};
                                    }
                                }
                            }
                        }
                    }
                    
                    if (bestTile) {
                        const tile = camera.currentWorld.tiles[bestTile.x][bestTile.y];
                        
                        // Check if tile is empty (no owner)
                        if (tile.owner === null && tile.active) {
                            // Check if we have enough power
                            if (game.power >= game.abilities.kingdom.cost) {
                                createDivineKingdom(camera.currentWorld, bestTile.x, bestTile.y);
                                // Keep power selected after use
                            } else {
                                // Create sweat particles for insufficient power
                                const particleX = clickX;
                                const particleY = clickY - 40;
                                for (let i = 0; i < 8; i++) {
                                    game.sweatParticles.push(new SweatParticle(particleX + (Math.random() - 0.5) * 30, particleY + Math.random() * 15));
                                }
                            }
                        }
                    }
                }
            }
            
        });
        
        var speedButtons = document.querySelectorAll('.speed-btn');
        speedButtons.forEach(function(btn) {
            btn.addEventListener('click', function() {
                var speed = parseFloat(this.getAttribute('data-speed'));
                
                speedButtons.forEach(function(b) { b.classList.remove('active'); });
                this.classList.add('active');
                
                if (speed === 0) {
                    game.isPaused = true;
                    game.timeScale = 0;
                    document.getElementById('currentSpeed').textContent = 'Paused';
                    document.getElementById('currentSpeed').classList.remove('speed-indicator-fast');
                } else {
                    game.isPaused = false;
                    game.timeScale = speed;
                    document.getElementById('currentSpeed').textContent = speed + 'x';
                    
                    if (speed >= 10) {
                        document.getElementById('currentSpeed').classList.add('speed-indicator-fast');
                    } else {
                        document.getElementById('currentSpeed').classList.remove('speed-indicator-fast');
                    }
                }
            });
        });
        
        // Power button event listeners
        document.getElementById('smiteBtn').addEventListener('click', function() {
            const ability = game.abilities.smite;
            
            // Always unlocked, just check power
            if (ability.unlocked && game.power >= ability.cost) {
                if (camera.viewMode === 'world' && camera.currentWorld) {
                    // Toggle smite active state
                    game.abilities.smite.active = !game.abilities.smite.active;
                    // If activating smite, deactivate other abilities
                    if (game.abilities.smite.active) {
                        game.abilities.bless.active = false;
                        game.abilities.war.active = false;
                        game.abilities.peace.active = false;
                        game.abilities.portal.active = false;
                        // Reset selections
                        game.abilities.war.firstKingdom = null;
                        game.abilities.war.secondKingdom = null;
                        game.abilities.peace.firstKingdom = null;
                        game.abilities.peace.secondKingdom = null;
                        game.abilities.portal.firstTile = null;
                        game.abilities.portal.secondTile = null;
                        canvas.style.cursor = 'crosshair';
                    } else {
                        canvas.style.cursor = 'grab';
                    }
                    camera.blockPowerActivation = false; // Clear any block when activated via button
                }
            }
        });
        
        document.getElementById('blessBtn').addEventListener('click', function() {
            const ability = game.abilities.bless;
            
            // Check if unlocked
            if (!ability.unlocked) {
                // Can't use locked abilities
                return;
            }
            
            // For button click, we just toggle the state
            // The actual cost check happens when clicking on a kingdom
            if (camera.viewMode === 'world' && camera.currentWorld) {
                // Toggle bless active state
                game.abilities.bless.active = !game.abilities.bless.active;
                // If activating bless, deactivate other abilities
                if (game.abilities.bless.active) {
                    game.abilities.smite.active = false;
                    game.abilities.war.active = false;
                    game.abilities.peace.active = false;
                    game.abilities.portal.active = false;
                    game.abilities.kingdom.active = false;
                    // Reset selections
                    game.abilities.war.firstKingdom = null;
                    game.abilities.war.secondKingdom = null;
                    game.abilities.peace.firstKingdom = null;
                    game.abilities.peace.secondKingdom = null;
                    game.abilities.portal.firstTile = null;
                    game.abilities.portal.secondTile = null;
                    canvas.style.cursor = 'crosshair';
                } else {
                    canvas.style.cursor = 'grab';
                }
                camera.blockPowerActivation = false; // Clear any block when activated via button
            }
        });
        
        document.getElementById('warBtn').addEventListener('click', function() {
            const ability = game.abilities.war;
            
            // Check if unlocked
            if (!ability.unlocked) {
                // Can't use locked abilities
                return;
            }
            
            if (camera.viewMode === 'world' && camera.currentWorld) {
                // Check power only when activating
                if (!ability.active && game.power < ability.cost) {
                    // Not enough power - create sweat particles
                    const rect = canvas.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    for (let i = 0; i < 5; i++) {
                        game.sweatParticles.push(new SweatParticle(
                            centerX + (Math.random() - 0.5) * 20,
                            centerY - 20
                        ));
                    }
                    return;
                }
                
                // Toggle war active state
                game.abilities.war.active = !game.abilities.war.active;
                // If activating war, deactivate other abilities
                if (game.abilities.war.active) {
                    game.abilities.smite.active = false;
                    game.abilities.bless.active = false;
                    game.abilities.peace.active = false;
                    game.abilities.portal.active = false;
                    game.abilities.kingdom.active = false;
                    // Reset selections
                    game.abilities.war.firstKingdom = null;
                    game.abilities.war.secondKingdom = null;
                    game.abilities.peace.firstKingdom = null;
                    game.abilities.peace.secondKingdom = null;
                    game.abilities.portal.firstTile = null;
                    game.abilities.portal.secondTile = null;
                    canvas.style.cursor = 'crosshair';
                } else {
                    canvas.style.cursor = 'grab';
                }
                camera.blockPowerActivation = false;
            }
        });
        
        document.getElementById('peaceBtn').addEventListener('click', function() {
            const ability = game.abilities.peace;
            
            // Check if unlocked
            if (!ability.unlocked) {
                // Can't use locked abilities
                return;
            }
            
            if (camera.viewMode === 'world' && camera.currentWorld) {
                // Check power only when activating
                if (!ability.active && game.power < ability.cost) {
                    // Not enough power - create sweat particles
                    const rect = canvas.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    for (let i = 0; i < 5; i++) {
                        game.sweatParticles.push(new SweatParticle(
                            centerX + (Math.random() - 0.5) * 20,
                            centerY - 20
                        ));
                    }
                    return;
                }
                
                // Toggle peace active state
                game.abilities.peace.active = !game.abilities.peace.active;
                // If activating peace, deactivate other abilities
                if (game.abilities.peace.active) {
                    game.abilities.smite.active = false;
                    game.abilities.bless.active = false;
                    game.abilities.war.active = false;
                    game.abilities.portal.active = false;
                    game.abilities.kingdom.active = false;
                    // Reset selections
                    game.abilities.war.firstKingdom = null;
                    game.abilities.war.secondKingdom = null;
                    game.abilities.peace.firstKingdom = null;
                    game.abilities.peace.secondKingdom = null;
                    game.abilities.portal.firstTile = null;
                    game.abilities.portal.secondTile = null;
                    canvas.style.cursor = 'crosshair';
                } else {
                    canvas.style.cursor = 'grab';
                }
                camera.blockPowerActivation = false;
            }
        });
        
        document.getElementById('portalBtn').addEventListener('click', function() {
            const ability = game.abilities.portal;
            
            // Check if unlocked
            if (!ability.unlocked) {
                // Can't use locked abilities
                return;
            }
            
            if (camera.viewMode === 'world' && camera.currentWorld) {
                // Check power only when activating
                if (!ability.active && game.power < ability.cost) {
                    // Not enough power - create sweat particles
                    const rect = canvas.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    for (let i = 0; i < 5; i++) {
                        game.sweatParticles.push(new SweatParticle(
                            centerX + (Math.random() - 0.5) * 20,
                            centerY - 20
                        ));
                    }
                    return;
                }
                
                // Toggle portal active state
                game.abilities.portal.active = !game.abilities.portal.active;
                // If activating portal, deactivate other abilities
                if (game.abilities.portal.active) {
                    game.abilities.smite.active = false;
                    game.abilities.bless.active = false;
                    game.abilities.war.active = false;
                    game.abilities.peace.active = false;
                    // Reset selections
                    game.abilities.war.firstKingdom = null;
                    game.abilities.war.secondKingdom = null;
                    game.abilities.peace.firstKingdom = null;
                    game.abilities.peace.secondKingdom = null;
                    game.abilities.portal.firstTile = null;
                    game.abilities.portal.secondTile = null;
                    canvas.style.cursor = 'crosshair';
                } else {
                    canvas.style.cursor = 'grab';
                }
                camera.blockPowerActivation = false;
            }
        });
        
        document.getElementById('kingdomBtn').addEventListener('click', function() {
            if (camera.viewMode === 'world' && camera.currentWorld) {
                // Check if ability is locked
                if (!game.abilities.kingdom.unlocked) {
                    // Can't use locked abilities
                    return;
                }
                
                // Check power only when activating
                if (!game.abilities.kingdom.active && game.power < game.abilities.kingdom.cost) {
                    // Not enough power - create sweat particles
                    const rect = canvas.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    for (let i = 0; i < 5; i++) {
                        game.sweatParticles.push(new SweatParticle(
                            centerX + (Math.random() - 0.5) * 20,
                            centerY - 20
                        ));
                    }
                    return;
                }
                
                // Toggle kingdom active state
                game.abilities.kingdom.active = !game.abilities.kingdom.active;
                // If activating kingdom, deactivate other abilities
                if (game.abilities.kingdom.active) {
                    game.abilities.smite.active = false;
                    game.abilities.bless.active = false;
                    game.abilities.war.active = false;
                    game.abilities.peace.active = false;
                    game.abilities.portal.active = false;
                    // Reset selections
                    game.abilities.war.firstKingdom = null;
                    game.abilities.war.secondKingdom = null;
                    game.abilities.peace.firstKingdom = null;
                    game.abilities.peace.secondKingdom = null;
                    game.abilities.portal.firstTile = null;
                    game.abilities.portal.secondTile = null;
                    canvas.style.cursor = 'crosshair';
                } else {
                    canvas.style.cursor = 'grab';
                }
                camera.blockPowerActivation = false;
            }
        });
        
        document.getElementById('terraformBtn').addEventListener('click', function() {
            if (camera.viewMode === 'world' && camera.currentWorld) {
                // Check if ability is locked
                if (!game.abilities.terraform.unlocked) {
                    // Can't use locked abilities
                    return;
                }
                
                // Check power only when activating
                if (!game.abilities.terraform.active && game.power < game.abilities.terraform.cost) {
                    // Not enough power - create sweat particles
                    const rect = canvas.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    for (let i = 0; i < 5; i++) {
                        game.sweatParticles.push(new SweatParticle(
                            centerX + (Math.random() - 0.5) * 20,
                            centerY - 20
                        ));
                    }
                    return;
                }
                
                // Toggle terraform active state
                game.abilities.terraform.active = !game.abilities.terraform.active;
                // If activating terraform, deactivate other abilities
                if (game.abilities.terraform.active) {
                    game.abilities.smite.active = false;
                    game.abilities.bless.active = false;
                    game.abilities.war.active = false;
                    game.abilities.peace.active = false;
                    game.abilities.portal.active = false;
                    game.abilities.kingdom.active = false;
                    // Reset selections
                    game.abilities.war.firstKingdom = null;
                    game.abilities.war.secondKingdom = null;
                    game.abilities.peace.firstKingdom = null;
                    game.abilities.peace.secondKingdom = null;
                    game.abilities.portal.firstTile = null;
                    game.abilities.portal.secondTile = null;
                    canvas.style.cursor = 'ns-resize';
                } else {
                    canvas.style.cursor = 'grab';
                }
                camera.blockPowerActivation = false;
            }
        });
        
        document.getElementById('sculptBtn').addEventListener('click', function() {
            if (camera.viewMode === 'world' && camera.currentWorld) {
                // Check if ability is locked
                if (!game.abilities.sculpt.unlocked) {
                    // Can't use locked abilities
                    return;
                }
                
                // Check power only when activating
                if (!game.abilities.sculpt.active && game.power < game.abilities.sculpt.cost) {
                    // Not enough power - create sweat particles
                    const rect = canvas.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    for (let i = 0; i < 5; i++) {
                        game.sweatParticles.push(new SweatParticle(
                            centerX + (Math.random() - 0.5) * 20,
                            centerY - 20
                        ));
                    }
                    return;
                }
                
                // Toggle sculpt active state
                game.abilities.sculpt.active = !game.abilities.sculpt.active;
                // If activating sculpt, deactivate other abilities
                if (game.abilities.sculpt.active) {
                    game.abilities.smite.active = false;
                    game.abilities.bless.active = false;
                    game.abilities.war.active = false;
                    game.abilities.peace.active = false;
                    game.abilities.portal.active = false;
                    game.abilities.kingdom.active = false;
                    game.abilities.terraform.active = false;
                    // Reset selections
                    game.abilities.war.firstKingdom = null;
                    game.abilities.war.secondKingdom = null;
                    game.abilities.peace.firstKingdom = null;
                    game.abilities.peace.secondKingdom = null;
                    game.abilities.portal.firstTile = null;
                    game.abilities.portal.secondTile = null;
                    canvas.style.cursor = 'crosshair';
                } else {
                    canvas.style.cursor = 'grab';
                }
                camera.blockPowerActivation = false;
            }
        });
        
        // Add slider handlers for AOE controls
        const smiteAoeSlider = document.getElementById('smiteAoeSlider');
        const smiteAoeDisplay = document.getElementById('smiteAoeDisplay');
        if (smiteAoeSlider && smiteAoeDisplay) {
            smiteAoeSlider.addEventListener('input', function(e) {
                const newRadius = parseInt(e.target.value);
                updateSmiteRadius(newRadius);
                smiteAoeDisplay.textContent = newRadius === 25 ? '∞' : newRadius;
            });
        }
        
        const terraformAoeSlider = document.getElementById('terraformAoeSlider');
        const terraformAoeDisplay = document.getElementById('terraformAoeDisplay');
        if (terraformAoeSlider && terraformAoeDisplay) {
            terraformAoeSlider.addEventListener('input', function(e) {
                const newRadius = parseInt(e.target.value);
                game.abilities.terraform.radius = newRadius;
                terraformAoeDisplay.textContent = newRadius;
            });
        }
        
        const sculptAoeSlider = document.getElementById('sculptAoeSlider');
        const sculptAoeDisplay = document.getElementById('sculptAoeDisplay');
        if (sculptAoeSlider && sculptAoeDisplay) {
            sculptAoeSlider.addEventListener('input', function(e) {
                const newRadius = parseInt(e.target.value);
                game.abilities.sculpt.radius = newRadius;
                sculptAoeDisplay.textContent = newRadius;
            });
        }
        
        canvas.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            // Cancel ability mode on right click
            if (game.abilities.smite.active || game.abilities.bless.active || game.abilities.war.active || game.abilities.peace.active || game.abilities.portal.active || game.abilities.kingdom.active || game.abilities.terraform.active || game.abilities.sculpt.active) {
                game.abilities.smite.active = false;
                game.abilities.bless.active = false;
                game.abilities.war.active = false;
                game.abilities.peace.active = false;
                game.abilities.portal.active = false;
                game.abilities.kingdom.active = false;
                game.abilities.terraform.active = false;
                game.abilities.sculpt.active = false;
                // Reset selections
                game.abilities.war.firstKingdom = null;
                game.abilities.war.secondKingdom = null;
                game.abilities.peace.firstKingdom = null;
                game.abilities.peace.secondKingdom = null;
                game.abilities.portal.firstTile = null;
                game.abilities.portal.secondTile = null;
                canvas.style.cursor = 'grab';
            }
        });
        
        document.addEventListener('keydown', function(e) {
            switch(e.key) {
                case 'Escape':
                    // Cancel ability mode
                    if (game.abilities.smite.active || game.abilities.bless.active || game.abilities.war.active || game.abilities.peace.active) {
                        game.abilities.smite.active = false;
                        game.abilities.bless.active = false;
                        game.abilities.war.active = false;
                        game.abilities.peace.active = false;
                        // Reset selections
                        game.abilities.war.firstKingdom = null;
                        game.abilities.war.secondKingdom = null;
                        game.abilities.peace.firstKingdom = null;
                        game.abilities.peace.secondKingdom = null;
                        canvas.style.cursor = 'grab';
                    }
                    // Also reset drag state
                    camera.isDragging = false;
                    camera.hasDraggedSignificantly = false;
                    camera.blockPowerActivation = false;
                    break;
                case ' ': e.preventDefault(); document.querySelector('.pause-btn').click(); break;
                case '1': document.querySelector('.speed-btn[data-speed="1"]').click(); break;
                case 'c':
                case 'C':
                    // Cheat: Add 100 temples
                    console.log('CHEAT: Adding 100 temples');
                    // Create 100 fake temples
                    for (let i = 0; i < 100; i++) {
                        const fakeTemple = {
                            x: 0,
                            y: 0,
                            kingdomId: -1, // Fake kingdom ID
                            worldId: 0,
                            health: 100,
                            maxHealth: 100,
                            powerGeneration: 0.02,
                            glowPhase: 0,
                            active: true,
                            update: function() {
                                // Generate power
                                if (this.active && game.power < game.maxPower) {
                                    game.power = game.power + this.powerGeneration;
                                    if (game.power >= game.maxPower) {
                                        game.power = game.maxPower;
                                    }
                                }
                                this.glowPhase += 0.02;
                            }
                        };
                        game.temples.push(fakeTemple);
                    }
                    
                    // Update max power
                    game.maxPower += 1000; // 100 temples * 10 power each
                    updatePowerDisplay();
                    
                    // Check for ability unlocks
                    checkAbilityUnlocks();
                    
                    console.log(`Temple count now: ${game.temples.length}`);
                    console.log(`Max power now: ${game.maxPower}`);
                    break;
                case '2': document.querySelector('.speed-btn[data-speed="2"]').click(); break;
                case '3': document.querySelector('.speed-btn[data-speed="5"]').click(); break;
                case '4': document.querySelector('.speed-btn[data-speed="10"]').click(); break;
                case '5': document.querySelector('.speed-btn[data-speed="25"]').click(); break;
                case '6': document.querySelector('.speed-btn[data-speed="50"]').click(); break;
                case '7': document.querySelector('.speed-btn[data-speed="100"]').click(); break;
                case '8': document.querySelector('.speed-btn[data-speed="200"]').click(); break;
            }
        });
        
        function gameTick() {
            game.currentTick++;
            game.tickCount++;
            
            // Process batched chunk updates every few ticks at high speeds
            if (game.timeScale >= 10 && game.currentTick % 5 === 0) {
                processBatchChunkUpdates();
            }
            
            // Check for ability unlocks every 10 ticks
            if (game.currentTick % 10 === 0) {
                checkAbilityUnlocks();
            }
            
            // Update blessed kingdoms
            for (const kingdomId in game.blessedKingdoms) {
                if (game.blessedKingdoms[kingdomId] <= game.currentTick) {
                    delete game.blessedKingdoms[kingdomId];
                }
            }
            
            // Update active wars
            game.activeWars = game.activeWars.filter(war => {
                if (war.endTick <= game.currentTick) {
                    // War has ended - reset target kingdom
                    const attacker = findKingdomById(war.attacker);
                    if (attacker && attacker.targetKingdom === war.defender) {
                        attacker.targetKingdom = null;
                    }
                    return false;
                }
                return true;
            });
            
            // Update active truces
            game.truces = game.truces.filter(truce => {
                if (truce.endTick <= game.currentTick) {
                    // Truce has ended - remove from kingdoms' truces
                    const kingdom1 = findKingdomById(truce.kingdom1);
                    const kingdom2 = findKingdomById(truce.kingdom2);
                    if (kingdom1) {
                        delete kingdom1.truces[truce.kingdom2];
                    }
                    if (kingdom2) {
                        delete kingdom2.truces[truce.kingdom1];
                    }
                    return false;
                }
                return true;
            });
            
            // Update burned structures
            for (const key in game.burnedCapitals) {
                if (game.burnedCapitals[key] <= game.currentTick) {
                    delete game.burnedCapitals[key];
                }
            }
            for (const key in game.burnedVillages) {
                if (game.burnedVillages[key] <= game.currentTick) {
                    delete game.burnedVillages[key];
                }
            }
            
            // Update divine effects
            game.divineEffects = game.divineEffects.filter(effect => effect.update());
            
            // Update sweat particles
            game.sweatParticles = game.sweatParticles.filter(particle => particle.update());
            
            // Base power generation (0.02 per tick, even without temples)
            const powerBefore = game.power;
            if (game.power < game.maxPower) {
                game.power = game.power + 0.02;
            }
            
            // Always ensure we don't exceed max and handle floating point issues
            if (game.power > game.maxPower || Math.abs(game.power - game.maxPower) < 0.001) {
                game.power = game.maxPower;
            }
            
            // Update display if power changed
            if (powerBefore !== game.power || game.currentTick % 10 === 0) {
                updatePowerDisplay();
            }
            
            // Update temples
            game.temples.forEach(temple => {
                temple.update();
            });
            
            // Update Giant Fish for Aqua world
            updateGiantFish();
            
            // Update Terra Witch
            updateTerraWitch();
            
            // Update Terra darkness effect
            if (game.terraDarkness.active) {
                // Update timer
                game.terraDarkness.timer++;
                
                // Smooth transition to darkness
                if (game.terraDarkness.transitionProgress < 1) {
                    game.terraDarkness.transitionProgress = Math.min(1, game.terraDarkness.transitionProgress + game.terraDarkness.transitionSpeed);
                }
                
                // Check if darkness period is over
                if (game.terraDarkness.timer >= game.terraDarkness.duration) {
                    game.terraDarkness.active = false;
                    // Reset bone collection tracking
                    if (game.terraWitch.active) {
                        game.terraWitch.bonesDuringDarkPeriod = 0;
                    }
                }
            } else if (game.terraDarkness.transitionProgress > 0) {
                // Smooth transition back to normal
                game.terraDarkness.transitionProgress = Math.max(0, game.terraDarkness.transitionProgress - game.terraDarkness.transitionSpeed);
            }
            
            // World witches update removed - only Terra has a witch
            
            // Update dark clouds
            game.darkClouds = game.darkClouds.filter(cloud => {
                cloud.timer++;
                
                // Fade in
                if (cloud.opacity < cloud.targetOpacity) {
                    cloud.opacity = Math.min(cloud.targetOpacity, cloud.opacity + cloud.fadeSpeed);
                }
                
                // Check if cloud should dissipate
                if (cloud.timer >= cloud.duration || !game.terraDarkness.active) {
                    // Fade out
                    cloud.opacity = Math.max(0, cloud.opacity - cloud.fadeSpeed * 2);
                    return cloud.opacity > 0;
                }
                
                return true;
            });
            
            // Update Aether world nomad tribe
            for (var w = 0; w < worlds.length; w++) {
                var world = worlds[w];
                if (world && world.name === 'Aether' && world.nomadTribe) {
                    updateNomadTribePosition(world.nomadTribe);
                }
            }
            
            // Update Umbra world ghosts
            for (var w = 0; w < worlds.length; w++) {
                var world = worlds[w];
                if (world && world.name === 'Umbra' && world.effect && world.effect.updateGhosts) {
                    world.effect.updateGhosts(world, game.currentTick);
                }
            }
            
            // Update Ignis world shadows
            for (var w = 0; w < worlds.length; w++) {
                var world = worlds[w];
                if (world && world.name === 'Ignis' && world.effect && world.effect.updateShadows) {
                    world.effect.updateShadows(world, game.currentTick);
                }
            }
            
            // Update Vita world effects
            for (var w = 0; w < worlds.length; w++) {
                var world = worlds[w];
                if (world && world.name === 'Lux' && world.effect && world.effect.updateBeams) {
                    world.effect.updateBeams(world, game.currentTick);
                }
                
                if (world && world.name === 'Vita' && world.effect && world.effect.updateVita) {
                    world.effect.updateVita(game.currentTick);
                }
            }
            
            game.portals = game.portals.filter(p => p.expiresTick > game.currentTick);
            
            var totalTemples = 0;
            worlds.forEach(world => {
                if(world.kingdoms) {
                    world.kingdoms.forEach(kingdom => {
                        if (kingdom.hasTemple && kingdom.alive && kingdom.templeLevel > 0) {
                            totalTemples += kingdom.templeLevel;
                        }
                    });
                }
            });
            game.templeCount = totalTemples;
            
            if (game.currentTick % 30 === 0 && totalTemples > 0) {
                // Power generation now handled by individual temples
                updatePowerDisplay();
            }
            
            if (game.currentTick % 600 === 0) {
                var year = Math.floor(game.currentTick / 600) + 1;
                var yearElement = document.getElementById('gameYear');
                yearElement.textContent = year;
                yearElement.classList.add('year-change');
                setTimeout(() => yearElement.classList.remove('year-change'), 500);
            }
            
            // Slowly restore tile wear every 60 ticks (0.1 year) and spread lava
            if (game.currentTick % 60 === 0) {
                worlds.forEach(world => {
                    // Track tiles that will become lava this tick
                    const newLavaTiles = [];
                    
                    for (var x = 0; x < WORLD_SIZE; x++) {
                        for (var y = 0; y < WORLD_SIZE; y++) {
                            var tile = world.tiles[x][y];
                            if (tile.active) {
                                // Reduce wear very slowly (50% slower than before)
                                if (tile.wear > 0) {
                                    tile.wear = Math.max(0, tile.wear - 0.0025);
                                }
                                
                                // Check if lava should spread to this tile
                                if (!tile.isLava && tile.active) {
                                    // Check all adjacent tiles for lava
                                    const neighbors = [
                                        {dx: -1, dy: 0}, {dx: 1, dy: 0},
                                        {dx: 0, dy: -1}, {dx: 0, dy: 1}
                                    ];
                                    
                                    for (const {dx, dy} of neighbors) {
                                        const nx = x + dx;
                                        const ny = y + dy;
                                        if (nx >= 0 && nx < WORLD_SIZE && ny >= 0 && ny < WORLD_SIZE) {
                                            const neighbor = world.tiles[nx][ny];
                                            // Lava spreads to lower adjacent tiles
                                            if (neighbor.isLava && neighbor.height > tile.height) {
                                                newLavaTiles.push({x, y, tile});
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // Apply lava spread
                    newLavaTiles.forEach(({x, y, tile}) => {
                        tile.isLava = true;
                        markTileDirty(world.id, x, y);
                        
                        // Deactivate temples if this tile belongs to a kingdom
                        if (tile.owner !== null) {
                            game.temples.forEach(temple => {
                                if (temple.kingdomId === tile.owner) {
                                    temple.active = false;
                                }
                            });
                        }
                        
                        // Destroy any building on this tile
                        if (tile.hasBuilding) {
                            // Check if it's a village - remove it entirely
                            const villageIndex = world.villages.findIndex(v => v.x === x && v.y === y);
                            if (villageIndex !== -1) {
                                world.villages.splice(villageIndex, 1);
                                console.log(`Village completely destroyed by lava spread at ${x}, ${y}`);
                            }
                            
                            // Check if it's a capital - remove it entirely
                            const capitalIndex = world.capitals.findIndex(c => c.x === x && c.y === y);
                            if (capitalIndex !== -1) {
                                const capital = world.capitals[capitalIndex];
                                world.capitals.splice(capitalIndex, 1);
                                
                                // Also remove from kingdom's controlled capitals
                                worlds.forEach(w => {
                                    w.kingdoms.forEach(kingdom => {
                                        if (kingdom.id === tile.owner) {
                                            const controlIndex = kingdom.controlledCapitals.findIndex(c => c.x === x && c.y === y);
                                            if (controlIndex !== -1) {
                                                kingdom.controlledCapitals.splice(controlIndex, 1);
                                                
                                                // Remove any temple requests from this capital
                                                kingdom.templeRequests = kingdom.templeRequests.filter(req => 
                                                    !(req.capital.x === x && req.capital.y === y)
                                                );
                                                
                                                // Check if kingdom has no capitals left
                                                if (kingdom.controlledCapitals.length === 0) {
                                                    kingdom.alive = false;
                                                    kingdom.deathTick = game.currentTick;
                                                    console.log(`Kingdom ${kingdom.name} destroyed - no capitals remaining after lava spread`);
                                                    
                                                    // Immediately clear tile ownership
                                                    for (let clearX = 0; clearX < WORLD_SIZE; clearX++) {
                                                        for (let clearY = 0; clearY < WORLD_SIZE; clearY++) {
                                                            if (world.tiles[clearX][clearY].owner === kingdom.id) {
                                                                world.tiles[clearX][clearY].owner = null;
                                                                markTileDirty(world.id, clearX, clearY);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    });
                                });
                                console.log(`Capital completely destroyed by lava spread at ${x}, ${y}`);
                            }
                            
                            // Check if it's a temple - remove it entirely
                            const templeIndex = game.temples.findIndex(t => t.x === x && t.y === y && t.worldId === world.id);
                            if (templeIndex !== -1) {
                                game.temples.splice(templeIndex, 1);
                                // Update max power
                                game.maxPower = Math.max(10, game.maxPower - 10);
                                updatePowerDisplay();
                                console.log(`Temple completely destroyed by lava spread at ${x}, ${y}`);
                            }
                            
                            // Clear building from tile
                            tile.hasBuilding = false;
                            tile.buildingType = null;
                        }
                    });
                    
                    // Check special entities for lava contact
                    // Giant Fish in Aqua world
                    if (world.name === 'Aqua' && game.giantFish.active) {
                        const fishX = Math.floor(game.giantFish.x);
                        const fishY = Math.floor(game.giantFish.y);
                        if (fishX >= 0 && fishX < WORLD_SIZE && fishY >= 0 && fishY < WORLD_SIZE) {
                            const fishTile = world.tiles[fishX][fishY];
                            if (fishTile && fishTile.isLava) {
                                game.giantFish.active = false;
                                console.log(`Giant Fish destroyed by lava at ${fishX}, ${fishY}`);
                            }
                        }
                    }
                    
                    // Terra Witch
                    if (world.name === 'Terra' && game.terraWitch.active) {
                        const witchX = Math.floor(game.terraWitch.x);
                        const witchY = Math.floor(game.terraWitch.y);
                        if (witchX >= 0 && witchX < WORLD_SIZE && witchY >= 0 && witchY < WORLD_SIZE) {
                            const witchTile = world.tiles[witchX][witchY];
                            if (witchTile && witchTile.isLava) {
                                game.terraWitch.active = false;
                                game.terraWitch.deathTime = game.currentTick;
                                game.terraWitch.phase = 'waiting';
                                game.terraWitch.waitTimer = 0;
                                console.log(`Terra Witch destroyed by lava at ${witchX}, ${witchY}`);
                            }
                        }
                        
                        // Also check witch house
                        if (game.terraWitch.hasHouse) {
                            const houseX = Math.floor(game.terraWitch.houseX);
                            const houseY = Math.floor(game.terraWitch.houseY);
                            if (houseX >= 0 && houseX < WORLD_SIZE && houseY >= 0 && houseY < WORLD_SIZE) {
                                const houseTile = world.tiles[houseX][houseY];
                                if (houseTile && houseTile.isLava) {
                                    game.terraWitch.hasHouse = false;
                                    houseTile.hasBuilding = false;
                                    houseTile.buildingType = null;
                                    console.log(`Witch house destroyed by lava at ${houseX}, ${houseY}`);
                                }
                            }
                        }
                    }
                    
                    // Nomad Tribe wagons in Aether
                    if (world.name === 'Aether' && world.nomadTribe) {
                        world.nomadTribe.wagons.forEach((wagon, index) => {
                            const wagonX = Math.floor(wagon.x);
                            const wagonY = Math.floor(wagon.y);
                            if (wagonX >= 0 && wagonX < WORLD_SIZE && wagonY >= 0 && wagonY < WORLD_SIZE) {
                                const wagonTile = world.tiles[wagonX][wagonY];
                                if (wagonTile && wagonTile.isLava) {
                                    // Remove wagon
                                    world.nomadTribe.wagons.splice(index, 1);
                                    console.log(`Nomad wagon destroyed by lava at ${wagonX}, ${wagonY}`);
                                }
                            }
                        });
                    }
                    
                    // Check all armies and recruits for lava contact
                    // Destroy armies on lava tiles
                    worlds.forEach(checkWorld => {
                        checkWorld.kingdoms.forEach(kingdom => {
                            if (kingdom.alive) {
                                kingdom.armies.forEach(army => {
                                    if (army.alive && army.worldId === world.id) {
                                        const pos = army.getPosition();
                                        const armyX = Math.floor(pos.x);
                                        const armyY = Math.floor(pos.y);
                                        if (armyX >= 0 && armyX < WORLD_SIZE && armyY >= 0 && armyY < WORLD_SIZE) {
                                            const armyTile = world.tiles[armyX][armyY];
                                            if (armyTile && armyTile.isLava) {
                                                // Army is destroyed by lava
                                                army.alive = false;
                                                army.troops = 0;
                                                console.log(`Army destroyed by lava at ${armyX}, ${armyY}`);
                                            }
                                        }
                                    }
                                });
                            }
                        });
                        
                        // Destroy recruits on lava tiles
                        if (checkWorld.recruits) {
                            checkWorld.recruits.forEach(recruit => {
                                if (recruit.alive && recruit.worldId === world.id) {
                                    const pos = recruit.getPosition();
                                    const recruitX = Math.floor(pos.x);
                                    const recruitY = Math.floor(pos.y);
                                    if (recruitX >= 0 && recruitX < WORLD_SIZE && recruitY >= 0 && recruitY < WORLD_SIZE) {
                                        const recruitTile = world.tiles[recruitX][recruitY];
                                        if (recruitTile && recruitTile.isLava) {
                                            // Recruit group is destroyed by lava
                                            recruit.alive = false;
                                            recruit.size = 0;
                                            console.log(`Recruit group destroyed by lava at ${recruitX}, ${recruitY}`);
                                        }
                                    }
                                }
                            });
                        }
                    });
                });
            }
            
            for (var w = 0; w < worlds.length; w++) {
                var world = worlds[w];
                if (!world) continue;
                
                if (!world.kingdoms) continue;
                
                // Update spatial index before kingdom updates
                updateSpatialIndex(world);
                
                // Update kingdoms every 12 ticks (once per second at 1x speed)
                if (game.currentTick % 12 === 0) {
                    world.kingdoms.forEach(k => k.update(world, game.currentTick));
                }
                
                // Village recruit spawning
                if (world.villages && game.currentTick % 10 === 0) {
                    world.villages.forEach(village => {
                        // Check if village is burned
                        const villageKey = village.x + ',' + village.y + ',' + world.id;
                        if (game.burnedVillages[villageKey]) {
                            return; // Skip burned villages
                        }
                        
                        const currentOwner = world.tiles[village.x][village.y].owner;
                        if (currentOwner !== null) {
                            // Check if kingdom is blessed
                            const isBlessed = game.blessedKingdoms[currentOwner] && game.blessedKingdoms[currentOwner] > game.currentTick;
                            const spawnChance = isBlessed ? (90 / 2250) : (30 / 2250); // 3x faster generation (was 30/2250 blessed, 10/2250 normal)
                            
                            if (Math.random() < spawnChance) {
                                // Find the kingdom that owns this village
                                let ownerKingdom = null;
                                // First check native kingdoms
                                ownerKingdom = world.kingdoms.find(k => k.id === currentOwner && k.alive);
                                // If not found, check foreign kingdoms
                                if (!ownerKingdom) {
                                    for (let w = 0; w < worlds.length; w++) {
                                        ownerKingdom = worlds[w].kingdoms.find(k => k.id === currentOwner && k.alive);
                                        if (ownerKingdom) break;
                                    }
                                }
                                
                                if (ownerKingdom) {
                                    const closestCapital = ownerKingdom.findClosestStagingPoint(village.x, village.y, world.id);
                                    if (closestCapital) {
                                        // Double-check the capital isn't burned
                                        const capitalKey = closestCapital.x + ',' + closestCapital.y + ',' + world.id;
                                        if (!game.burnedCapitals[capitalKey]) {
                                            // Check if recruits can reach the capital (avoid lava)
                                            if (RecruitGroup.canReachTarget(world, village.x, village.y, closestCapital.x, closestCapital.y)) {
                                                const recruitGroup = new RecruitGroup(ownerKingdom, village.x, village.y, closestCapital.x, closestCapital.y, world.id);
                                                world.recruits.push(recruitGroup);
                                            } else {
                                                console.log(`Recruits cannot reach capital from village (${village.x}, ${village.y}) to (${closestCapital.x}, ${closestCapital.y}) - path blocked by lava`);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                world.recruits = world.recruits.filter(recruit => {
                    if (recruit.alive) {
                        recruit.update(world);
                        if (recruit.hasReachedDestination()) {
                            const troopCap = recruit.kingdom.calculateTroopCap();
                            recruit.kingdom.troops = Math.min(troopCap, recruit.kingdom.troops + recruit.size);
                            recruit.alive = false;
                        }
                    }
                    return recruit.alive;
                });
                
                // Update all armies with dynamic frequency based on game speed
                // At high speeds, update less frequently for performance
                let armyUpdateInterval = 1;
                if (game.timeScale >= 100) {
                    armyUpdateInterval = 4;
                } else if (game.timeScale >= 25) {
                    armyUpdateInterval = 2;
                }
                
                const shouldUpdateArmies = game.currentTick % armyUpdateInterval === 0;
                
                for (const kingdom of world.kingdoms) {
                    if (!kingdom.alive) continue;
                    
                    var aliveArmies = [];
                    for (var i = 0; i < kingdom.armies.length; i++) {
                        var army = kingdom.armies[i];
                        if (army.alive) {
                            // Get the correct world for this army
                            const armyWorld = worlds[army.worldId];
                            if (!armyWorld) {
                                army.alive = false;
                                army.cleanupOnDeath(armyWorld);
                                // Clean up dead army references
                                if (army.targetTileKey) {
                                    delete kingdom.targetedTiles[army.targetTileKey];
                                }
                                continue;
                            }
                            
                            // Only update movement based on interval
                            if (shouldUpdateArmies) {
                                army.update(armyWorld);
                            }
                            
                            if (army.hasReachedDestination() && army.task !== 'messenger') {
                                kingdom.resolveArmyArrival(armyWorld, army);
                            }
                            if (army.alive) {
                                aliveArmies.push(army);
                            } else if (army.targetTileKey) {
                                delete kingdom.targetedTiles[army.targetTileKey];
                            }
                        } else if (army.targetTileKey) {
                            delete kingdom.targetedTiles[army.targetTileKey];
                        }
                    }
                    kingdom.armies = aliveArmies;
                }
            }
            
            // Check all entities for lava contact every tick
            // This ensures units that move onto lava tiles are destroyed
            worlds.forEach(checkWorld => {
                // Check armies on lava
                checkWorld.kingdoms.forEach(kingdom => {
                    if (kingdom.alive) {
                        kingdom.armies.forEach(army => {
                            if (army.alive) {
                                // Get the actual position of the army (interpolated during movement)
                                const pos = army.getPosition();
                                const armyX = Math.floor(pos.x);
                                const armyY = Math.floor(pos.y);
                                const armyWorldId = army.worldId;
                                if (armyWorldId >= 0 && armyWorldId < worlds.length) {
                                    const armyWorld = worlds[armyWorldId];
                                    if (armyX >= 0 && armyX < WORLD_SIZE && armyY >= 0 && armyY < WORLD_SIZE) {
                                        const armyTile = armyWorld.tiles[armyX][armyY];
                                        if (armyTile && armyTile.isLava) {
                                            army.alive = false;
                                            army.troops = 0;
                                            console.log(`Army destroyed by lava at ${armyX}, ${armyY} in world ${armyWorld.name}`);
                                        }
                                    }
                                }
                            }
                        });
                    }
                });
                
                // Check recruits on lava
                if (checkWorld.recruits) {
                    checkWorld.recruits.forEach(recruit => {
                        if (recruit.alive) {
                            const pos = recruit.getPosition();
                            const recruitX = Math.floor(pos.x);
                            const recruitY = Math.floor(pos.y);
                            if (recruitX >= 0 && recruitX < WORLD_SIZE && recruitY >= 0 && recruitY < WORLD_SIZE) {
                                const recruitTile = checkWorld.tiles[recruitX][recruitY];
                                if (recruitTile && recruitTile.isLava) {
                                    recruit.alive = false;
                                    recruit.size = 0;
                                    console.log(`Recruit group destroyed by lava at ${recruitX}, ${recruitY} in world ${checkWorld.name}`);
                                }
                            }
                        }
                    });
                }
                
                // Check special entities
                if (checkWorld.name === 'Aqua' && game.giantFish.active) {
                    const fishX = Math.floor(game.giantFish.x);
                    const fishY = Math.floor(game.giantFish.y);
                    if (fishX >= 0 && fishX < WORLD_SIZE && fishY >= 0 && fishY < WORLD_SIZE) {
                        const fishTile = checkWorld.tiles[fishX][fishY];
                        if (fishTile && fishTile.isLava) {
                            game.giantFish.active = false;
                            console.log(`Giant Fish destroyed by lava at ${fishX}, ${fishY}`);
                        }
                    }
                }
                
                if (checkWorld.name === 'Terra' && game.terraWitch.active) {
                    const witchX = Math.floor(game.terraWitch.x);
                    const witchY = Math.floor(game.terraWitch.y);
                    if (witchX >= 0 && witchX < WORLD_SIZE && witchY >= 0 && witchY < WORLD_SIZE) {
                        const witchTile = checkWorld.tiles[witchX][witchY];
                        if (witchTile && witchTile.isLava) {
                            game.terraWitch.active = false;
                            game.terraWitch.deathTime = game.currentTick;
                            game.terraWitch.phase = 'waiting';
                            game.terraWitch.waitTimer = 0;
                            console.log(`Terra Witch destroyed by lava at ${witchX}, ${witchY}`);
                        }
                    }
                }
                
                if (checkWorld.name === 'Aether' && checkWorld.nomadTribe) {
                    checkWorld.nomadTribe.wagons = checkWorld.nomadTribe.wagons.filter(wagon => {
                        const wagonX = Math.floor(wagon.x);
                        const wagonY = Math.floor(wagon.y);
                        if (wagonX >= 0 && wagonX < WORLD_SIZE && wagonY >= 0 && wagonY < WORLD_SIZE) {
                            const wagonTile = checkWorld.tiles[wagonX][wagonY];
                            if (wagonTile && wagonTile.isLava) {
                                console.log(`Nomad wagon destroyed by lava at ${wagonX}, ${wagonY}`);
                                return false; // Remove wagon
                            }
                        }
                        return true; // Keep wagon
                    });
                }
                
                // Check all buildings for lava contact
                // Check villages - remove them if on lava
                if (checkWorld.villages) {
                    checkWorld.villages = checkWorld.villages.filter(village => {
                        const villageX = village.x;
                        const villageY = village.y;
                        if (villageX >= 0 && villageX < WORLD_SIZE && villageY >= 0 && villageY < WORLD_SIZE) {
                            const villageTile = checkWorld.tiles[villageX][villageY];
                            if (villageTile && villageTile.isLava) {
                                // Clear tile
                                villageTile.hasBuilding = false;
                                villageTile.buildingType = null;
                                console.log(`Village completely destroyed by lava at ${villageX}, ${villageY} in world ${checkWorld.name}`);
                                return false; // Remove village
                            }
                        }
                        return true; // Keep village
                    });
                }
                
                // Check capitals - remove them if on lava
                if (checkWorld.capitals) {
                    checkWorld.capitals = checkWorld.capitals.filter(capital => {
                        const capitalX = capital.x;
                        const capitalY = capital.y;
                        if (capitalX >= 0 && capitalX < WORLD_SIZE && capitalY >= 0 && capitalY < WORLD_SIZE) {
                            const capitalTile = checkWorld.tiles[capitalX][capitalY];
                            if (capitalTile && capitalTile.isLava) {
                                // Clear tile
                                capitalTile.hasBuilding = false;
                                capitalTile.buildingType = null;
                                
                                // Also remove from kingdom's controlled capitals
                                worlds.forEach(w => {
                                    w.kingdoms.forEach(kingdom => {
                                        if (kingdom.id === capitalTile.owner) {
                                            const controlIndex = kingdom.controlledCapitals.findIndex(c => c.x === capitalX && c.y === capitalY);
                                            if (controlIndex !== -1) {
                                                kingdom.controlledCapitals.splice(controlIndex, 1);
                                                
                                                // Remove any temple requests from this capital
                                                kingdom.templeRequests = kingdom.templeRequests.filter(req => 
                                                    !(req.capital.x === capitalX && req.capital.y === capitalY)
                                                );
                                                
                                                // Check if kingdom has no capitals left
                                                if (kingdom.controlledCapitals.length === 0) {
                                                    kingdom.alive = false;
                                                    kingdom.deathTick = game.currentTick;
                                                    console.log(`Kingdom ${kingdom.name} destroyed - no capitals remaining after continuous lava check`);
                                                    
                                                    // Immediately clear tile ownership
                                                    for (let clearX = 0; clearX < WORLD_SIZE; clearX++) {
                                                        for (let clearY = 0; clearY < WORLD_SIZE; clearY++) {
                                                            if (checkWorld.tiles[clearX][clearY].owner === kingdom.id) {
                                                                checkWorld.tiles[clearX][clearY].owner = null;
                                                                markTileDirty(checkWorld.id, clearX, clearY);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    });
                                });
                                
                                console.log(`Capital completely destroyed by lava at ${capitalX}, ${capitalY} in world ${checkWorld.name}`);
                                return false; // Remove capital
                            }
                        }
                        return true; // Keep capital
                    });
                }
                
                // Check temples - remove them if on lava
                const templesBeforeCount = game.temples.length;
                game.temples = game.temples.filter(temple => {
                    if (temple.worldId === checkWorld.id) {
                        const templeX = temple.x;
                        const templeY = temple.y;
                        if (templeX >= 0 && templeX < WORLD_SIZE && templeY >= 0 && templeY < WORLD_SIZE) {
                            const templeTile = checkWorld.tiles[templeX][templeY];
                            if (templeTile && templeTile.isLava) {
                                // Clear tile
                                templeTile.hasBuilding = false;
                                templeTile.buildingType = null;
                                console.log(`Temple completely destroyed by lava at ${templeX}, ${templeY} in world ${checkWorld.name}`);
                                return false; // Remove temple
                            }
                        }
                    }
                    return true; // Keep temple
                });
                
                // Update max power if temples were destroyed
                const templesDestroyed = templesBeforeCount - game.temples.length;
                if (templesDestroyed > 0) {
                    game.maxPower = Math.max(10, game.maxPower - (templesDestroyed * 10));
                    updatePowerDisplay();
                }
                
                // Check witch house in Terra
                if (checkWorld.name === 'Terra' && game.terraWitch.hasHouse) {
                    const houseX = Math.floor(game.terraWitch.houseX);
                    const houseY = Math.floor(game.terraWitch.houseY);
                    if (houseX >= 0 && houseX < WORLD_SIZE && houseY >= 0 && houseY < WORLD_SIZE) {
                        const houseTile = checkWorld.tiles[houseX][houseY];
                        if (houseTile && houseTile.isLava) {
                            game.terraWitch.hasHouse = false;
                            houseTile.hasBuilding = false;
                            houseTile.buildingType = null;
                            console.log(`Witch house destroyed by lava at ${houseX}, ${houseY}`);
                        }
                    }
                }
            });
            
            // Update all battles and remove expired ones
            game.battles = game.battles.filter(battle => battle.update());
            
            game.armySpawns = game.armySpawns.filter(spawn => spawn.update());
            
            // Periodic memory cleanup
            if (game.currentTick % 300 === 0) {
                // Clean up dead kingdoms' references
                for (var w = 0; w < worlds.length; w++) {
                    var world = worlds[w];
                    if (world.kingdoms) {
                        // Clear tile ownership for dead kingdoms
                        world.kingdoms.forEach(k => {
                            if (!k.alive && k.deathTick && game.currentTick - k.deathTick >= 60) {
                                // Clear all tiles owned by this dead kingdom
                                for (let x = 0; x < WORLD_SIZE; x++) {
                                    for (let y = 0; y < WORLD_SIZE; y++) {
                                        if (world.tiles[x][y].owner === k.id) {
                                            world.tiles[x][y].owner = null;
                                            markTileDirty(world.id, x, y);
                                        }
                                    }
                                }
                                console.log(`Cleared tile ownership for dead kingdom ${k.name}`);
                            }
                        });
                        
                        // Remove dead kingdoms from arrays after some time
                        world.kingdoms = world.kingdoms.filter(k => k.alive || game.currentTick - k.deathTick < 600);
                    }
                }
                
                // Clear territory cache
                game.territoryCache.clear();
                game.territoryCacheTick = -1;
            }
        }
        
        function updatePowerDisplay() {
            // Ensure power never goes below 0
            game.power = Math.max(0, game.power);
            
            // Fix floating point issues - if we're very close to max, just set to max
            if (game.maxPower - game.power < 0.1 && game.power < game.maxPower) {
                game.power = game.maxPower;
            }
            
            // Round power for display (use round instead of floor to show accurate values)
            const displayPower = Math.round(game.power);
            
            var powerBar = document.querySelector('.power-fill');
            var percentage = (game.power / game.maxPower) * 100;
            powerBar.style.width = percentage + '%';
            document.getElementById('templeCount').textContent = game.temples ? game.temples.length : 0;
            document.getElementById('powerAmount').textContent = displayPower + '/' + game.maxPower;
            
            // Update ability buttons too
            updateAbilityButtons();
        }
        
        function updateAbilityButtons() {
            const currentTemples = game.temples ? game.temples.filter(t => t.active).length : 0;
            
            // Helper function to update locked ability display
            function updateLockedAbility(btn, ability, costElementId, normalTooltip) {
                const costElement = document.getElementById(costElementId);
                const tooltip = btn.querySelector('.ability-tooltip');
                
                if (!ability.unlocked) {
                    btn.classList.add('locked');
                    btn.classList.remove('active', 'disabled');
                    
                    // Update cost display to show temple requirement
                    if (costElement && ability.templeRequirement !== undefined) {
                        costElement.textContent = '🏛️' + ability.templeRequirement;
                    }
                    
                    // Update tooltip to show temple requirement
                    if (tooltip && ability.templeRequirement !== undefined) {
                        const templesNeeded = ability.templeRequirement - currentTemples;
                        if (templesNeeded > 0) {
                            tooltip.textContent = `Requires ${ability.templeRequirement} temple${ability.templeRequirement > 1 ? 's' : ''} (Need ${templesNeeded} more)`;
                        } else {
                            tooltip.textContent = `Unlocked! ${ability.templeRequirement} temple${ability.templeRequirement > 1 ? 's' : ''} acquired`;
                        }
                    }
                    return true; // Ability is locked
                } else {
                    btn.classList.remove('locked');
                    // Restore normal cost display
                    if (costElement) {
                        // Special case for bless - always show ? when not hovering
                        if (costElementId === 'blessCost') {
                            costElement.textContent = '?';
                        } else {
                            costElement.textContent = ability.cost === undefined || ability.cost === null ? '?' : ability.cost;
                        }
                    }
                    // Restore normal tooltip
                    if (tooltip) {
                        tooltip.textContent = normalTooltip;
                    }
                    return false; // Ability is unlocked
                }
            }
            
            // Update ability button states
            const smiteBtn = document.getElementById('smiteBtn');
            const blessBtn = document.getElementById('blessBtn');
            
            // Smite button (always unlocked)
            if (game.power < game.abilities.smite.cost) {
                smiteBtn.classList.add('disabled');
                smiteBtn.classList.remove('active');
            } else {
                smiteBtn.classList.remove('disabled');
            }
            
            // Update active state for smite
            if (game.abilities.smite.active) {
                smiteBtn.classList.add('active');
            } else {
                smiteBtn.classList.remove('active');
            }
            
            // Bless button
            const blessAbility = game.abilities.bless;
            if (!updateLockedAbility(blessBtn, blessAbility, 'blessCost', 'Triple recruit generation for 5 years (cost = kingdom tiles)')) {
                // Update active state for bless
                if (blessAbility.active) {
                    blessBtn.classList.add('active');
                } else {
                    blessBtn.classList.remove('active');
                }
            }
            
            // War button
            const warBtn = document.getElementById('warBtn');
            const warAbility = game.abilities.war;
            if (!updateLockedAbility(warBtn, warAbility, 'warCost', 'Declare war between two kingdoms for 5 years (50 power)')) {
                if (game.power < warAbility.cost) {
                    warBtn.classList.add('disabled');
                    warBtn.classList.remove('active');
                } else {
                    warBtn.classList.remove('disabled');
                }
                
                // Update active state for war
                if (warAbility.active) {
                    warBtn.classList.add('active');
                } else {
                    warBtn.classList.remove('active');
                }
            }
            
            // Peace button
            const peaceBtn = document.getElementById('peaceBtn');
            const peaceAbility = game.abilities.peace;
            const peaceTooltip = peaceBtn.querySelector('.ability-tooltip');
            if (!peaceAbility.unlocked) {
                peaceBtn.classList.add('locked');
                peaceBtn.classList.remove('active', 'disabled');
                // Update cost display to show unlock cost
                const peaceCost = document.getElementById('peaceCost');
                if (peaceCost) peaceCost.textContent = '🏛️' + peaceAbility.templeRequirement;
                // Update tooltip to show unlock milestone
                if (peaceTooltip) {
                    const templesNeeded = peaceAbility.templeRequirement - currentTemples;
                    if (templesNeeded > 0) {
                        peaceTooltip.textContent = `Requires ${peaceAbility.templeRequirement} temples (Need ${templesNeeded} more)`;
                    } else {
                        peaceTooltip.textContent = `Unlocked! ${peaceAbility.templeRequirement} temples acquired`;
                    }
                }
            } else {
                peaceBtn.classList.remove('locked');
                // Restore normal cost display
                const peaceCost = document.getElementById('peaceCost');
                if (peaceCost) peaceCost.textContent = peaceAbility.cost;
                // Restore normal tooltip
                if (peaceTooltip) peaceTooltip.textContent = 'Create peace between two warring kingdoms (30 power)';
                
                if (game.power < peaceAbility.cost) {
                    peaceBtn.classList.add('disabled');
                    peaceBtn.classList.remove('active');
                } else {
                    peaceBtn.classList.remove('disabled');
                }
                
                // Update active state for peace
                if (peaceAbility.active) {
                    peaceBtn.classList.add('active');
                } else {
                    peaceBtn.classList.remove('active');
                }
            }
            
            // Portal button
            const portalBtn = document.getElementById('portalBtn');
            const portalAbility = game.abilities.portal;
            const portalTooltip = portalBtn.querySelector('.ability-tooltip');
            if (!portalAbility.unlocked) {
                portalBtn.classList.add('locked');
                portalBtn.classList.remove('active', 'disabled');
                // Update cost display to show unlock cost
                const portalCost = document.getElementById('portalCost');
                if (portalCost) portalCost.textContent = '🏛️' + portalAbility.templeRequirement;
                // Update tooltip to show unlock milestone
                if (portalTooltip) {
                    const templesNeeded = portalAbility.templeRequirement - currentTemples;
                    if (templesNeeded > 0) {
                        portalTooltip.textContent = `Requires ${portalAbility.templeRequirement} temples (Need ${templesNeeded} more)`;
                    } else {
                        portalTooltip.textContent = `Unlocked! ${portalAbility.templeRequirement} temples acquired`;
                    }
                }
            } else {
                portalBtn.classList.remove('locked');
                // Restore normal cost display
                const portalCost = document.getElementById('portalCost');
                if (portalCost) portalCost.textContent = portalAbility.cost;
                // Restore normal tooltip
                if (portalTooltip) portalTooltip.textContent = 'Connect two tiles with a divine portal lasting 100 years (40 power)';
                
                if (game.power < portalAbility.cost) {
                    portalBtn.classList.add('disabled');
                    portalBtn.classList.remove('active');
                } else {
                    portalBtn.classList.remove('disabled');
                }
                
                // Update active state for portal
                if (portalAbility.active) {
                    portalBtn.classList.add('active');
                } else {
                    portalBtn.classList.remove('active');
                }
            }
            
            // Kingdom button
            const kingdomBtn = document.getElementById('kingdomBtn');
            const kingdomAbility = game.abilities.kingdom;
            const kingdomTooltip = kingdomBtn.querySelector('.ability-tooltip');
            if (!kingdomAbility.unlocked) {
                kingdomBtn.classList.add('locked');
                kingdomBtn.classList.remove('active', 'disabled');
                // Update cost display to show unlock cost
                const kingdomCost = document.getElementById('kingdomCost');
                if (kingdomCost) kingdomCost.textContent = '🏛️' + kingdomAbility.templeRequirement;
                // Update tooltip to show unlock milestone
                if (kingdomTooltip) {
                    const templesNeeded = kingdomAbility.templeRequirement - currentTemples;
                    if (templesNeeded > 0) {
                        kingdomTooltip.textContent = `Requires ${kingdomAbility.templeRequirement} temples (Need ${templesNeeded} more)`;
                    } else {
                        kingdomTooltip.textContent = `Unlocked! ${kingdomAbility.templeRequirement} temples acquired`;
                    }
                }
            } else {
                kingdomBtn.classList.remove('locked');
                // Restore normal cost display
                const kingdomCost = document.getElementById('kingdomCost');
                if (kingdomCost) kingdomCost.textContent = kingdomAbility.cost;
                // Restore normal tooltip
                if (kingdomTooltip) kingdomTooltip.textContent = 'Create a new kingdom with a capital on an empty tile (50 power)';
                
                if (game.power < kingdomAbility.cost) {
                    kingdomBtn.classList.add('disabled');
                    kingdomBtn.classList.remove('active');
                } else {
                    kingdomBtn.classList.remove('disabled');
                }
                
                // Update active state for kingdom
                if (kingdomAbility.active) {
                    kingdomBtn.classList.add('active');
                } else {
                    kingdomBtn.classList.remove('active');
                }
            }
            
            // Terraform button
            const terraformBtn = document.getElementById('terraformBtn');
            const terraformAbility = game.abilities.terraform;
            const terraformTooltip = terraformBtn.querySelector('.ability-tooltip');
            if (!terraformAbility.unlocked) {
                terraformBtn.classList.add('locked');
                terraformBtn.classList.remove('active', 'disabled');
                // Update cost display to show unlock cost
                const terraformCost = document.getElementById('terraformCost');
                if (terraformCost) terraformCost.textContent = '🏛️' + terraformAbility.templeRequirement;
                // Update tooltip to show unlock milestone
                if (terraformTooltip) {
                    const templesNeeded = terraformAbility.templeRequirement - currentTemples;
                    if (templesNeeded > 0) {
                        terraformTooltip.textContent = `Requires ${terraformAbility.templeRequirement} temples (Need ${templesNeeded} more)`;
                    } else {
                        terraformTooltip.textContent = `Unlocked! ${terraformAbility.templeRequirement} temples acquired`;
                    }
                }
            } else {
                terraformBtn.classList.remove('locked');
                // Restore normal cost display
                const terraformCost = document.getElementById('terraformCost');
                if (terraformCost) terraformCost.textContent = terraformAbility.cost;
                // Restore normal tooltip
                if (terraformTooltip) terraformTooltip.textContent = 'Click and drag to raise or lower terrain (25 power)';
                
                if (game.power < terraformAbility.cost) {
                    terraformBtn.classList.add('disabled');
                    terraformBtn.classList.remove('active');
                } else {
                    terraformBtn.classList.remove('disabled');
                }
                
                // Update active state for terraform
                if (terraformAbility.active) {
                    terraformBtn.classList.add('active');
                } else {
                    terraformBtn.classList.remove('active');
                }
            }
            
            // Sculpt button
            const sculptBtn = document.getElementById('sculptBtn');
            const sculptAbility = game.abilities.sculpt;
            const sculptTooltip = sculptBtn.querySelector('.ability-tooltip');
            if (!sculptAbility.unlocked) {
                sculptBtn.classList.add('locked');
                sculptBtn.classList.remove('active', 'disabled');
                // Update cost display to show unlock cost
                const sculptCost = document.getElementById('sculptCost');
                if (sculptCost) sculptCost.textContent = '🏛️' + sculptAbility.templeRequirement;
                // Update tooltip to show unlock milestone
                if (sculptTooltip) {
                    const templesNeeded = sculptAbility.templeRequirement - currentTemples;
                    if (templesNeeded > 0) {
                        sculptTooltip.textContent = `Requires ${sculptAbility.templeRequirement} temples (Need ${templesNeeded} more)`;
                    } else {
                        sculptTooltip.textContent = `Unlocked! ${sculptAbility.templeRequirement} temples acquired`;
                    }
                }
            } else {
                sculptBtn.classList.remove('locked');
                // Restore normal cost display
                const sculptCost = document.getElementById('sculptCost');
                if (sculptCost) sculptCost.textContent = sculptAbility.cost;
                // Restore normal tooltip
                if (sculptTooltip) sculptTooltip.textContent = 'Click tiles to add (green +) or remove (red -) land mass (15 power)';
                
                if (game.power < sculptAbility.cost) {
                    sculptBtn.classList.add('disabled');
                    sculptBtn.classList.remove('active');
                } else {
                    sculptBtn.classList.remove('disabled');
                }
                
                // Update active state for sculpt
                if (sculptAbility.active) {
                    sculptBtn.classList.add('active');
                } else {
                    sculptBtn.classList.remove('active');
                }
            }
        }

        function updateUI() {
            document.getElementById('zoom').textContent = camera.zoom.toFixed(1) + 'x';

            if (camera.viewMode === 'world' && camera.currentWorld && hoveredTile) {
                const tile = camera.currentWorld.tiles[hoveredTile.x][hoveredTile.y];
                if (tile && tile.owner !== null) {
                    // First check native kingdoms
                    let kingdom = camera.currentWorld.kingdoms.find(k => k.id === tile.owner);
                    
                    // If not found, check foreign kingdoms
                    if (!kingdom || !kingdom.alive) {
                        for (let w = 0; w < worlds.length; w++) {
                            if (w !== camera.currentWorld.id) {
                                kingdom = worlds[w].kingdoms.find(k => k.id === tile.owner && k.alive);
                                if (kingdom) break;
                            }
                        }
                    }
                    
                    if (kingdom && kingdom.alive) {
                        document.getElementById('kingdomInfo').style.display = 'block';
                        
                        var kingdomLabel = kingdom.name;
                        
                        // Add world indicator for foreign kingdoms
                        if (kingdom.worldId !== camera.currentWorld.id) {
                            kingdomLabel += ' (' + worlds[kingdom.worldId].name + ')';
                        }
                        
                        // Add status symbols
                        if (kingdom.worldConqueror) {
                            kingdomLabel += ' 👑';
                        } else if (kingdom.hasTemple) {
                            if (kingdom.templeLevel > 0) {
                                kingdomLabel += ' ⛪';
                            } else {
                                kingdomLabel += ' ☠️';
                            }
                        }
                        
                        // Add blessing indicator
                        if (game.blessedKingdoms[kingdom.id] && game.blessedKingdoms[kingdom.id] > game.currentTick) {
                            kingdomLabel += ' ✨';
                        }
                        
                        document.getElementById('kingdomName').textContent = kingdomLabel;
                        
                        // Calculate total territory across all worlds
                        let totalTerritory = 0;
                        for (let w = 0; w < worlds.length; w++) {
                            for (let y = 0; y < WORLD_SIZE; y++) {
                                for (let x = 0; x < WORLD_SIZE; x++) {
                                    if (worlds[w].tiles[x][y].active && worlds[w].tiles[x][y].owner === kingdom.id) {
                                        totalTerritory++;
                                    }
                                }
                            }
                        }
                        
                        document.getElementById('kingdomTerritory').textContent = totalTerritory;
                        
                        const troopCap = kingdom.calculateTroopCap();
                        document.getElementById('kingdomTroops').textContent = kingdom.troops;
                        document.getElementById('kingdomTroopCap').textContent = troopCap;

                        document.getElementById('kingdomState').textContent = kingdom.state.charAt(0).toUpperCase() + kingdom.state.slice(1);
                        
                        var warWearinessElement = document.getElementById('warWeariness');
                        warWearinessElement.textContent = 'Weariness: ' + Math.floor(kingdom.warWeariness) + '%';
                        if (kingdom.warWeariness > 70) warWearinessElement.style.color = '#ff6b6b';
                        else if (kingdom.warWeariness > 40) warWearinessElement.style.color = '#feca57';
                        else warWearinessElement.style.color = '#aaa';
                        
                        // Blessing cost - only show if bless ability is unlocked
                        const blessCostElement = document.getElementById('blessCostInfo');
                        if (game.abilities.bless.unlocked) {
                            const villageCount = kingdom.villages.length;
                            const blessCost = villageCount * 5;
                            
                            if (game.abilities.bless.active) {
                                if (game.power >= blessCost) {
                                    blessCostElement.textContent = `Blessing Cost: ${blessCost} power (${villageCount} villages × 5) ✓`;
                                    blessCostElement.style.color = '#4ade80';
                                } else {
                                    blessCostElement.textContent = `Blessing Cost: ${blessCost} power (${villageCount} villages × 5) - Need ${blessCost - game.power} more`;
                                    blessCostElement.style.color = '#ef4444';
                                }
                            } else {
                                blessCostElement.textContent = `Blessing Cost: ${blessCost} power (${villageCount} villages × 5)`;
                                blessCostElement.style.color = '#ffd700';
                            }
                            
                            // Update blessing button cost display
                            document.getElementById('blessCost').textContent = blessCost;
                        } else {
                            // Clear blessing cost info when ability is locked
                            blessCostElement.textContent = '';
                        }
                        
                        return;
                    }
                }
            }
            document.getElementById('kingdomInfo').style.display = 'none';
            // Reset blessing cost display when not hovering - only for unlocked abilities
            if (game.abilities.bless.unlocked) {
                document.getElementById('blessCost').textContent = '?';
            }
            // Note: For locked abilities, the display is handled by updateAbilityButtons() and should not be changed here
        }
        
        function getWorldSkyColor(worldName) {
            switch(worldName) {
                case 'Ignis': return '#FF5252';
                case 'Aqua': return '#006994';
                case 'Aether': return '#3b82f6';
                case 'Terra': return '#16a34a';
                case 'Lux': return '#f59e0b';
                case 'Umbra': return '#4c1d95';
                case 'Vita': return '#10b981';
                default: return '#87CEEB';
            }
        }
        
        function renderCrystalBallFogTrail() {
            // Update fog opacity
            if (crystalBall.currentWorld !== null) {
                crystalBall.targetFogOpacity = 1;
            } else {
                crystalBall.targetFogOpacity = 0;
            }
            crystalBall.fogTrailOpacity += (crystalBall.targetFogOpacity - crystalBall.fogTrailOpacity) * 0.1;
            
            if (crystalBall.fogTrailOpacity < 0.01) return;
            
            // Crystal ball world position
            const ballX = 0;
            const ballY = 0;
            const ballScreenX = (ballX + camera.x) * camera.zoom + canvas.width / 2;
            const ballScreenY = (ballY + camera.y) * camera.zoom + canvas.height / 2;
            
            // Get the world position
            if (crystalBall.currentWorld !== null && worlds[crystalBall.currentWorld]) {
                const world = worlds[crystalBall.currentWorld];
                const worldScreenX = (world.x + camera.x) * camera.zoom + canvas.width / 2;
                const worldScreenY = (world.y + camera.y) * camera.zoom + canvas.height / 2;
                
                ctx.save();
                
                // Calculate control points for curved fog trail
                const dx = worldScreenX - ballScreenX;
                const dy = worldScreenY - ballScreenY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Control points for bezier curve
                const cp1x = ballScreenX + dx * 0.3;
                const cp1y = ballScreenY + dy * 0.3 - distance * 0.1;
                const cp2x = worldScreenX - dx * 0.3;
                const cp2y = worldScreenY - dy * 0.3 - distance * 0.1;
                
                // Create gradient along the trail
                const gradient = ctx.createLinearGradient(ballScreenX, ballScreenY, worldScreenX, worldScreenY);
                gradient.addColorStop(0, `rgba(150, 150, 200, ${0.3 * crystalBall.fogTrailOpacity})`);
                gradient.addColorStop(0.5, `rgba(180, 180, 220, ${0.2 * crystalBall.fogTrailOpacity})`);
                gradient.addColorStop(1, `rgba(200, 200, 255, ${0.1 * crystalBall.fogTrailOpacity})`);
                
                // Draw multiple fog layers for depth
                for (let i = 0; i < 3; i++) {
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = (50 - i * 15) * camera.zoom;
                    ctx.globalAlpha = (0.3 - i * 0.1) * crystalBall.fogTrailOpacity;
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(ballScreenX, ballScreenY);
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, worldScreenX, worldScreenY);
                    ctx.stroke();
                }
                
                // Add swirling particles along the trail
                const particleCount = 20;
                const time = performance.now() * 0.001;
                ctx.globalAlpha = crystalBall.fogTrailOpacity * 0.5;
                
                for (let i = 0; i < particleCount; i++) {
                    const t = (i / particleCount + time * 0.1) % 1;
                    
                    // Calculate position along bezier curve
                    const x = Math.pow(1-t, 3) * ballScreenX + 
                             3 * Math.pow(1-t, 2) * t * cp1x +
                             3 * (1-t) * Math.pow(t, 2) * cp2x +
                             Math.pow(t, 3) * worldScreenX;
                    const y = Math.pow(1-t, 3) * ballScreenY + 
                             3 * Math.pow(1-t, 2) * t * cp1y +
                             3 * (1-t) * Math.pow(t, 2) * cp2y +
                             Math.pow(t, 3) * worldScreenY;
                    
                    // Add swirl offset
                    const swirlX = Math.sin(t * Math.PI * 4 + time) * 20;
                    const swirlY = Math.cos(t * Math.PI * 4 + time) * 20;
                    
                    const particleSize = (1 - t) * 3 + 1;
                    const particleOpacity = (1 - t) * 0.3;
                    
                    ctx.fillStyle = `rgba(220, 220, 255, ${particleOpacity})`;
                    ctx.beginPath();
                    ctx.arc(x + swirlX, y + swirlY, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        function renderCrystalBall() {
            // Crystal ball world position (center of the ethereal realm)
            const worldX = 0;
            const worldY = 0;
            const baseRadius = 135; // Base size in world units
            
            // Convert world position to screen position
            const screenX = (worldX + camera.x) * camera.zoom + canvas.width / 2;
            const screenY = (worldY + camera.y) * camera.zoom + canvas.height / 2;
            
            // Scale radius with zoom to maintain constant world size
            const radius = baseRadius * camera.zoom;
            
            // Don't render if crystal ball is off-screen
            if (screenX < -radius || screenX > canvas.width + radius || 
                screenY < -radius || screenY > canvas.height + radius) {
                return;
            }
            
            const centerX = screenX;
            const centerY = screenY;
            
            // Update crystal ball view based on hover or interesting events
            updateCrystalBallView();
            
            // Save context
            ctx.save();
            
            // Create clipping mask for crystal ball
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.clip();
            
            // Draw the world view inside crystal ball
            if (crystalBall.currentWorld !== null && worlds[crystalBall.currentWorld]) {
                const world = worlds[crystalBall.currentWorld];
                
                // Check if we're following an entity
                if (camera.followingEntity && camera.followingEntity.entity) {
                    // Get entity position and update crystal ball target
                    var entity = camera.followingEntity.entity;
                    var pos = null;
                    var entityAlive = false;
                    
                    // Get position based on entity type
                    switch (camera.followingEntity.type) {
                        case 'army':
                        case 'recruit':
                            if (entity.alive && entity.worldId === crystalBall.currentWorld) {
                                pos = entity.getPosition();
                                entityAlive = true;
                            }
                            break;
                            
                        case 'giantFish':
                            if (crystalBall.currentWorld === 1 && game.giantFish.active) { // Aqua is world 1
                                pos = { x: game.giantFish.x, y: game.giantFish.y };
                                entityAlive = true;
                            }
                            break;
                            
                        case 'terraWitch':
                            if (crystalBall.currentWorld === 3 && game.terraWitch.active) { // Terra is world 3
                                pos = { x: game.terraWitch.x, y: game.terraWitch.y };
                                entityAlive = true;
                            }
                            break;
                            
                        case 'nomadWagon':
                            if (crystalBall.currentWorld === 2 && world.nomadTribe && // Aether is world 2
                                world.nomadTribe.wagons[camera.followingEntity.wagonIndex]) {
                                var wagon = world.nomadTribe.wagons[camera.followingEntity.wagonIndex];
                                pos = { x: wagon.x, y: wagon.y };
                                entityAlive = true;
                            }
                            break;
                            
                        case 'umbraGhost':
                            if (crystalBall.currentWorld === 5 && world.effect && // Umbra is world 5
                                world.effect.ghosts && world.effect.ghosts[camera.followingEntity.ghostIndex]) {
                                var ghost = world.effect.ghosts[camera.followingEntity.ghostIndex];
                                pos = { x: ghost.x, y: ghost.y };
                                entityAlive = true;
                            }
                            break;
                            
                        case 'ignisShadow':
                            if (crystalBall.currentWorld === 0 && world.effect && // Ignis is world 0
                                world.effect.shadowArmies && world.effect.shadowArmies[camera.followingEntity.shadowIndex]) {
                                var shadow = world.effect.shadowArmies[camera.followingEntity.shadowIndex];
                                if (shadow.route && shadow.route.length > 0) {
                                    if (shadow.routeIndex < shadow.route.length - 1) {
                                        var from = shadow.route[shadow.routeIndex];
                                        var to = shadow.route[shadow.routeIndex + 1];
                                        pos = {
                                            x: from.x + (to.x - from.x) * (shadow.moveProgress || 0),
                                            y: from.y + (to.y - from.y) * (shadow.moveProgress || 0)
                                        };
                                    } else {
                                        pos = shadow.route[shadow.route.length - 1];
                                    }
                                    entityAlive = true;
                                }
                            }
                            break;
                            
                        case 'vitaLeaf':
                            if (crystalBall.currentWorld === 6 && world.effect && // Vita is world 6
                                world.effect.walkingLeaves && world.effect.walkingLeaves[camera.followingEntity.leafIndex]) {
                                var leaf = world.effect.walkingLeaves[camera.followingEntity.leafIndex];
                                if (leaf.state === 'walking') {
                                    pos = { x: leaf.currentX, y: leaf.currentY };
                                    entityAlive = true;
                                }
                            }
                            break;
                    }
                    
                    // Update crystal ball target if we have a valid position
                    if (pos && entityAlive) {
                        var iso = worldToIsometric(pos.x, pos.y);
                        crystalBall.targetX = iso.x;
                        crystalBall.targetY = iso.y;
                        
                        // Also switch to the entity's world if different
                        if (entity.worldId !== undefined && entity.worldId !== crystalBall.currentWorld) {
                            crystalBall.currentWorld = entity.worldId;
                        }
                        
                        // Clear any death timer since entity is alive
                        camera.entityDiedTime = null;
                    } else if (!entityAlive) {
                        // Entity died - start or check the delay timer
                        if (!camera.entityDiedTime) {
                            camera.entityDiedTime = performance.now();
                        } else if (performance.now() - camera.entityDiedTime > 3000) {
                            // 3 seconds have passed, clear the following
                            camera.followingEntity = null;
                            camera.entityDiedTime = null;
                        }
                    }
                }
                
                // Smooth transition - slower for smoother movement
                const smoothX = crystalBall.viewX + (crystalBall.targetX - crystalBall.viewX) * 0.05;
                const smoothY = crystalBall.viewY + (crystalBall.targetY - crystalBall.viewY) * 0.05;
                crystalBall.viewX = smoothX;
                crystalBall.viewY = smoothY;
                
                // Create temporary canvas for world rendering (larger to ensure full coverage)
                const tempCanvas = document.createElement('canvas');
                const tempSize = radius * 4; // Make it larger to ensure we capture everything
                tempCanvas.width = tempSize;
                tempCanvas.height = tempSize;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Save the main canvas state and current camera
                const savedCtx = ctx;
                const savedCanvas = canvas;
                const savedCamera = {
                    x: camera.x,
                    y: camera.y,
                    zoom: camera.zoom,
                    currentWorld: camera.currentWorld,
                    viewMode: camera.viewMode
                };
                
                // Temporarily redirect rendering to temp canvas
                ctx = tempCtx;
                canvas = tempCanvas;
                
                // Set camera for crystal ball view
                camera.currentWorld = world;
                camera.viewMode = 'world';
                camera.x = -smoothX;
                camera.y = -smoothY;
                camera.zoom = crystalBall.zoom;
                
                // Call the actual world rendering function
                try {
                    renderWorldView();
                    
                    // Add ability preview if active and mouse is over crystal ball
                    if (game.abilities.smite.active || game.abilities.bless.active) {
                        // Check if mouse is over crystal ball
                        const ballScreenX = (0 + savedCamera.x) * savedCamera.zoom + savedCanvas.width / 2;
                        const ballScreenY = (0 + savedCamera.y) * savedCamera.zoom + savedCanvas.height / 2;
                        const ballRadius = baseRadius * savedCamera.zoom;
                        
                        const distFromCenter = Math.sqrt(
                            Math.pow(mouseX - ballScreenX, 2) + 
                            Math.pow(mouseY - ballScreenY, 2)
                        );
                        
                        if (distFromCenter <= ballRadius) {
                            // Convert mouse position to crystal ball coordinates
                            const relX = (mouseX - ballScreenX) / crystalBall.zoom;
                            const relY = (mouseY - ballScreenY) / crystalBall.zoom;
                            const worldX = relX + crystalBall.viewX;
                            const worldY = relY + crystalBall.viewY;
                            const tilePos = isometricToTile(worldX, worldY);
                            
                            if (tilePos.x >= 0 && tilePos.x < WORLD_SIZE && 
                                tilePos.y >= 0 && tilePos.y < WORLD_SIZE && 
                                world.tiles[tilePos.x][tilePos.y].active) {
                                
                                // Render preview on temp canvas
                                tempCtx.save();
                                tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
                                tempCtx.scale(crystalBall.zoom, crystalBall.zoom);
                                tempCtx.translate(-smoothX, -smoothY);
                                
                                if (game.abilities.smite.active) {
                                    // Draw smite preview
                                    const centerIso = worldToIsometric(tilePos.x, tilePos.y);
                                    tempCtx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
                                    tempCtx.lineWidth = 2;
                                    tempCtx.beginPath();
                                    tempCtx.moveTo(centerIso.x - 20, centerIso.y);
                                    tempCtx.lineTo(centerIso.x + 20, centerIso.y);
                                    tempCtx.moveTo(centerIso.x, centerIso.y - 20);
                                    tempCtx.lineTo(centerIso.x, centerIso.y + 20);
                                    tempCtx.stroke();
                                    
                                    // Draw radius indicator
                                    const radius = game.abilities.smite.radius;
                                    tempCtx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                                    tempCtx.lineWidth = 2;
                                    
                                    // Draw affected tiles
                                    for (let dy = -radius; dy <= radius; dy++) {
                                        for (let dx = -radius; dx <= radius; dx++) {
                                            const tx = tilePos.x + dx;
                                            const ty = tilePos.y + dy;
                                            if (tx >= 0 && tx < WORLD_SIZE && ty >= 0 && ty < WORLD_SIZE &&
                                                Math.abs(dx) + Math.abs(dy) <= radius) {
                                                const iso = worldToIsometric(tx, ty);
                                                tempCtx.fillStyle = 'rgba(255, 50, 50, 0.3)';
                                                tempCtx.beginPath();
                                                tempCtx.moveTo(iso.x, iso.y - 17);
                                                tempCtx.lineTo(iso.x + 33, iso.y);
                                                tempCtx.lineTo(iso.x, iso.y + 17);
                                                tempCtx.lineTo(iso.x - 33, iso.y);
                                                tempCtx.closePath();
                                                tempCtx.fill();
                                            }
                                        }
                                    }
                                } else if (game.abilities.bless.active) {
                                    // Highlight hovered kingdom's territory
                                    const tile = world.tiles[tilePos.x][tilePos.y];
                                    if (tile.owner !== null) {
                                        tempCtx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                                        tempCtx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
                                        tempCtx.lineWidth = 2;
                                        
                                        // Fill all tiles of this kingdom
                                        for (let y = 0; y < WORLD_SIZE; y++) {
                                            for (let x = 0; x < WORLD_SIZE; x++) {
                                                if (world.tiles[x][y].owner === tile.owner) {
                                                    const iso = worldToIsometric(x, y);
                                                    tempCtx.beginPath();
                                                    tempCtx.moveTo(iso.x, iso.y - 17);
                                                    tempCtx.lineTo(iso.x + 33, iso.y);
                                                    tempCtx.lineTo(iso.x, iso.y + 17);
                                                    tempCtx.lineTo(iso.x - 33, iso.y);
                                                    tempCtx.closePath();
                                                    tempCtx.fill();
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                tempCtx.restore();
                            }
                        }
                    }
                } catch (e) {
                    console.error('Crystal ball render error:', e);
                }
                
                // Restore original context and camera
                ctx = savedCtx;
                canvas = savedCanvas;
                camera.x = savedCamera.x;
                camera.y = savedCamera.y;
                camera.zoom = savedCamera.zoom;
                camera.currentWorld = savedCamera.currentWorld;
                camera.viewMode = savedCamera.viewMode;
                
                // Draw the temp canvas content to main canvas (centered)
                ctx.save();
                // Draw from center of temp canvas
                const sourceX = tempSize / 2 - radius;
                const sourceY = tempSize / 2 - radius;
                ctx.drawImage(tempCanvas, 
                    sourceX, sourceY, radius * 2, radius * 2,  // source rectangle
                    centerX - radius, centerY - radius, radius * 2, radius * 2); // destination
                ctx.restore();
            } else {
                // Show swirling mist when no world is selected
                const time = performance.now() * 0.0001;
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, 'rgba(150, 150, 255, 0.3)');
                gradient.addColorStop(0.5, 'rgba(100, 100, 200, 0.2)');
                gradient.addColorStop(1, 'rgba(50, 50, 150, 0.1)');
                ctx.fillStyle = gradient;
                ctx.fillRect(centerX - radius, centerY - radius, radius * 2, radius * 2);
            }
            
            ctx.restore();
            
            // Draw crystal ball effect overlay
            ctx.save();
            
            // Glass sphere effect with heavily obscured edges (fog effect)
            const glassGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            glassGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
            glassGradient.addColorStop(0.4, 'rgba(255, 255, 255, 0)');
            glassGradient.addColorStop(0.6, 'rgba(220, 220, 255, 0.1)');
            glassGradient.addColorStop(0.75, 'rgba(180, 180, 220, 0.3)');
            glassGradient.addColorStop(0.85, 'rgba(140, 140, 200, 0.5)');
            glassGradient.addColorStop(0.92, 'rgba(100, 100, 180, 0.7)');
            glassGradient.addColorStop(0.96, 'rgba(80, 80, 160, 0.85)');
            glassGradient.addColorStop(1, 'rgba(60, 60, 140, 0.95)');
            
            ctx.fillStyle = glassGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Additional fog layer for stronger edge obscuring
            const fogGradient = ctx.createRadialGradient(centerX, centerY, radius * 0.5, centerX, centerY, radius);
            fogGradient.addColorStop(0, 'rgba(150, 150, 200, 0)');
            fogGradient.addColorStop(0.7, 'rgba(150, 150, 200, 0)');
            fogGradient.addColorStop(0.85, 'rgba(120, 120, 180, 0.2)');
            fogGradient.addColorStop(0.95, 'rgba(90, 90, 160, 0.4)');
            fogGradient.addColorStop(1, 'rgba(70, 70, 140, 0.6)');
            
            ctx.fillStyle = fogGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Highlight on top-left (properly angled for sphere)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.ellipse(centerX - radius * 0.35, centerY - radius * 0.5, radius * 0.25, radius * 0.15, -Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Secondary smaller highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.beginPath();
            ctx.ellipse(centerX - radius * 0.45, centerY - radius * 0.4, radius * 0.15, radius * 0.1, -Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Crystal ball rim with glass-like sheen
            const rimGradient = ctx.createLinearGradient(
                centerX - radius, centerY - radius,
                centerX + radius, centerY + radius
            );
            rimGradient.addColorStop(0, 'rgba(200, 200, 255, 0.6)');
            rimGradient.addColorStop(0.5, 'rgba(150, 150, 200, 0.4)');
            rimGradient.addColorStop(1, 'rgba(100, 100, 150, 0.6)');
            
            ctx.strokeStyle = rimGradient;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function updateCrystalBallView() {
            const currentTime = performance.now();
            
            // If we're following an entity (or waiting after entity death), don't change crystal ball view
            if (camera.followingEntity || camera.entityDiedTime) {
                return;
            }
            
            // Check for hovered world
            if (camera.viewMode === 'ethereal') {
                const mouseWorld = screenToWorld(mouseX, mouseY);
                crystalBall.hoveredWorld = null;
                
                for (let i = 0; i < worlds.length; i++) {
                    const world = worlds[i];
                    // Don't skip Aether anymore - it has nomad tribe to watch
                    
                    const dist = Math.sqrt(Math.pow(mouseWorld.x - world.x, 2) + Math.pow(mouseWorld.y - world.y, 2));
                    if (dist < 50) {
                        crystalBall.hoveredWorld = i;
                        break;
                    }
                }
            }
            
            // Decide which world to show
            if (crystalBall.hoveredWorld !== null) {
                // Show hovered world
                if (crystalBall.currentWorld !== crystalBall.hoveredWorld) {
                    crystalBall.previousWorld = crystalBall.currentWorld;
                    crystalBall.currentWorld = crystalBall.hoveredWorld;
                    crystalBall.lastSwitch = currentTime;
                    crystalBall.lastLocationSwitch = currentTime;
                    crystalBall.fogTrailOpacity = 0; // Reset fog trail for smooth fade in
                    findInterestingLocation(worlds[crystalBall.currentWorld]);
                } else if (currentTime - crystalBall.lastLocationSwitch > crystalBall.minLocationSwitchInterval * 16.67) {
                    // Same world is still hovered - switch to a new location within it
                    crystalBall.lastLocationSwitch = currentTime;
                    findInterestingLocation(worlds[crystalBall.currentWorld]);
                }
            } else if (currentTime - crystalBall.lastSwitch > crystalBall.minSwitchInterval * 16.67) {
                // Switch to random world with interesting event
                const interestingWorld = findWorldWithEvent();
                if (interestingWorld !== null && interestingWorld !== crystalBall.currentWorld) {
                    crystalBall.previousWorld = crystalBall.currentWorld;
                    crystalBall.currentWorld = interestingWorld;
                    crystalBall.lastSwitch = currentTime;
                    crystalBall.lastLocationSwitch = currentTime;
                    crystalBall.fogTrailOpacity = 0; // Reset fog trail for smooth fade in
                    findInterestingLocation(worlds[crystalBall.currentWorld]);
                } else if (crystalBall.currentWorld !== null && currentTime - crystalBall.lastLocationSwitch > crystalBall.minLocationSwitchInterval * 16.67) {
                    // No world switch but time to switch location within current world
                    crystalBall.lastLocationSwitch = currentTime;
                    findInterestingLocation(worlds[crystalBall.currentWorld]);
                }
            }
        }
        
        function findWorldWithEvent() {
            // Look for worlds with active battles, large armies, or special effects
            const candidates = [];
            
            for (let i = 0; i < worlds.length; i++) {
                const world = worlds[i];
                
                // Don't skip Aether anymore - it has nomad tribe to watch
                
                let score = 0;
                
                // Check for battles
                // if (activeBattles.some(b => b.worldId === i)) score += 3;
                
                // Check for large armies
                if (world.kingdoms) {
                    const armyCount = world.kingdoms.reduce((sum, k) => sum + (k.armies ? k.armies.filter(a => a.alive).length : 0), 0);
                    score += Math.min(armyCount / 10, 2);
                }
                
                // Check for world effects
                if (world.effect && world.effect.intensity > 0.5) score += 2;
                
                // Check for portals
                if (game.portals.some(p => p.worldA === i || p.worldB === i)) score += 1;
                
                if (score > 0) {
                    candidates.push({ worldId: i, score });
                }
            }
            
            if (candidates.length === 0) {
                // No interesting events, pick random world
                return Math.floor(Math.random() * worlds.length);
            }
            
            // Weighted random selection based on score
            const totalScore = candidates.reduce((sum, c) => sum + c.score, 0);
            let random = Math.random() * totalScore;
            
            for (const candidate of candidates) {
                random -= candidate.score;
                if (random <= 0) return candidate.worldId;
            }
            
            return candidates[0].worldId;
        }
        
        function findInterestingLocation(world) {
            // Similar to Giant Fish logic - find interesting armies and events
            const allArmies = [];
            const interestingEvents = [];
            
            // Collect all armies in the world
            if (world.kingdoms) {
                // Native armies
                world.kingdoms.forEach(kingdom => {
                    if (kingdom.alive && kingdom.armies) {
                        kingdom.armies.forEach(army => {
                            if (army.alive && army.worldId === world.id) {
                                allArmies.push({
                                    army: army,
                                    pos: army.getPosition(),
                                    createdAt: army.createdAt || 0,
                                    size: army.size,
                                    isNative: true
                                });
                            }
                        });
                    }
                });
                
                // Foreign armies from other worlds
                worlds.forEach(otherWorld => {
                    if (otherWorld.id !== world.id && otherWorld.kingdoms) {
                        otherWorld.kingdoms.forEach(kingdom => {
                            if (kingdom.alive && kingdom.armies) {
                                kingdom.armies.forEach(army => {
                                    if (army.alive && army.worldId === world.id) {
                                        allArmies.push({
                                            army: army,
                                            pos: army.getPosition(),
                                            createdAt: army.createdAt || 0,
                                            size: army.size,
                                            isNative: false
                                        });
                                    }
                                });
                            }
                        });
                    }
                });
            }
            
            // Prioritize recent armies (created in last 300 ticks)
            const recentArmies = allArmies.filter(a => 
                game.currentTick - a.createdAt < 300
            );
            
            // Add armies to events with priority based on recency and size
            recentArmies.forEach(armyData => {
                interestingEvents.push({
                    x: armyData.pos.x,
                    y: armyData.pos.y,
                    priority: 5 + (armyData.isNative ? 0 : 2), // Foreign armies are more interesting
                    type: 'recentArmy'
                });
            });
            
            // Add large armies
            allArmies.filter(a => a.size > 10).forEach(armyData => {
                interestingEvents.push({
                    x: armyData.pos.x,
                    y: armyData.pos.y,
                    priority: 3 + Math.min(armyData.size / 10, 3),
                    type: 'largeArmy'
                });
            });
            
            // Add capitals with temples
            if (world.kingdoms) {
                world.kingdoms.forEach(kingdom => {
                    if (kingdom.alive && kingdom.hasTemple) {
                        interestingEvents.push({
                            x: kingdom.capitalX,
                            y: kingdom.capitalY,
                            priority: 4 + (kingdom.templeLevel || 1),
                            type: 'temple'
                        });
                    }
                });
            }
            
            // Add active portals
            game.portals.forEach(portal => {
                if (portal.worldA === world.id || portal.worldB === world.id) {
                    const entrance = portal.worldA === world.id ? portal.tileA : portal.tileB;
                    interestingEvents.push({
                        x: entrance.x,
                        y: entrance.y,
                        priority: 6,
                        type: 'portal'
                    });
                }
            });
            
            // Add world-specific interesting locations and entities
            if (world.name === 'Umbra' && world.effect && world.effect.ghosts) {
                // Add Umbra ghosts
                world.effect.ghosts.forEach(ghost => {
                    if (ghost.active) {
                        interestingEvents.push({
                            x: ghost.x,
                            y: ghost.y,
                            priority: 5,
                            type: 'umbraGhost'
                        });
                    }
                });
            }
            
            if (world.name === 'Aether' && world.nomadTribe) {
                // Add Aether nomad tribe
                const tribe = world.nomadTribe;
                const leadWagon = tribe.wagons[0];
                if (leadWagon) {
                    interestingEvents.push({
                        x: leadWagon.x,
                        y: leadWagon.y,
                        priority: 6,
                        type: 'nomadTribe'
                    });
                }
            }
            
            if (world.name === 'Ignis' && world.effect && world.effect.shadowArmies) {
                // Add Ignis shadow armies
                world.effect.shadowArmies.forEach(shadowArmy => {
                    if (shadowArmy.route && shadowArmy.route.length > 0) {
                        const currentPos = shadowArmy.route[Math.min(shadowArmy.routeIndex, shadowArmy.route.length - 1)];
                        interestingEvents.push({
                            x: currentPos.x,
                            y: currentPos.y,
                            priority: 5,
                            type: 'shadowArmy'
                        });
                    }
                });
            }
            
            if (world.name === 'Aqua' && game.giantFish && game.giantFish.active) {
                // Add Giant Fish if it's in this world
                interestingEvents.push({
                    x: game.giantFish.x,
                    y: game.giantFish.y,
                    priority: 7,
                    type: 'giantFish'
                });
            }
            
            if (world.name === 'Vita' && world.effect && world.effect.standingLeaves) {
                // Add clusters of standing leaves
                const leafClusters = {};
                world.effect.standingLeaves.forEach(leaf => {
                    const clusterKey = `${Math.floor(leaf.x / 10)},${Math.floor(leaf.y / 10)}`;
                    if (!leafClusters[clusterKey]) {
                        leafClusters[clusterKey] = { x: 0, y: 0, count: 0 };
                    }
                    leafClusters[clusterKey].x += leaf.x;
                    leafClusters[clusterKey].y += leaf.y;
                    leafClusters[clusterKey].count++;
                });
                
                // Add clusters with at least 3 leaves
                Object.values(leafClusters).forEach(cluster => {
                    if (cluster.count >= 3) {
                        interestingEvents.push({
                            x: cluster.x / cluster.count,
                            y: cluster.y / cluster.count,
                            priority: 4,
                            type: 'leafCluster'
                        });
                    }
                });
            }
            
            // Terra crystals orbit too far outside the world, so we'll focus on other content
            
            if (world.name === 'Lux' && world.effect && world.effect.beams) {
                // Add active light beams
                world.effect.beams.forEach(beam => {
                    if (beam.currentOpacity > 0) {
                        interestingEvents.push({
                            x: beam.tileX,
                            y: beam.tileY,
                            priority: 5,
                            type: 'lightBeam'
                        });
                    }
                });
            }
            
            // Add villages with activity
            if (world.villages) {
                world.villages.forEach(village => {
                    if (village.population > 50) {
                        interestingEvents.push({
                            x: village.x,
                            y: village.y,
                            priority: 3 + Math.min(village.population / 100, 2),
                            type: 'village'
                        });
                    }
                });
            }
            
            if (interestingEvents.length > 0) {
                // Sort by priority and pick from top candidates with some randomness
                interestingEvents.sort((a, b) => b.priority - a.priority);
                
                // Get top tier events (within 2 priority of the highest)
                const maxPriority = interestingEvents[0].priority;
                const topEvents = interestingEvents.filter(e => e.priority >= maxPriority - 2);
                
                // Randomly select from top events
                const selected = topEvents[Math.floor(Math.random() * topEvents.length)];
                
                const iso = worldToIsometric(selected.x, selected.y);
                crystalBall.targetX = iso.x;
                crystalBall.targetY = iso.y;
            } else {
                // Default to center of world (tile 32,32 for a 64x64 world)
                const centerTile = worldToIsometric(32, 32);
                crystalBall.targetX = centerTile.x;
                crystalBall.targetY = centerTile.y;
            }
        }
        
        
        function renderEtherealMap() {
            const animTime = performance.now() * 0.00005;
            
            // Base gradient background
            var gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
            gradient.addColorStop(0, '#0a0a2e');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#0f3460');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Animated nebula clouds
            ctx.save();
            for (let i = 0; i < 3; i++) {
                const cloudX = canvas.width * 0.5 + Math.sin(animTime + i * 2) * 300;
                const cloudY = canvas.height * 0.5 + Math.cos(animTime * 0.7 + i * 3) * 200;
                const cloudRadius = 200 + Math.sin(animTime * 2 + i) * 50;
                
                const nebulaGradient = ctx.createRadialGradient(cloudX, cloudY, 0, cloudX, cloudY, cloudRadius);
                const hue = (animTime * 20 + i * 120) % 360;
                nebulaGradient.addColorStop(0, `hsla(${hue}, 70%, 50%, 0.1)`);
                nebulaGradient.addColorStop(0.5, `hsla(${hue}, 60%, 40%, 0.05)`);
                nebulaGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = nebulaGradient;
                ctx.fillRect(cloudX - cloudRadius, cloudY - cloudRadius, cloudRadius * 2, cloudRadius * 2);
            }
            ctx.restore();
            
            // Aurora waves
            ctx.save();
            ctx.globalAlpha = 0.15;
            for (let wave = 0; wave < 2; wave++) {
                const waveGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                const offset = animTime + wave * 0.5;
                waveGradient.addColorStop(0, `hsla(${180 + Math.sin(offset) * 60}, 70%, 50%, 0)`);
                waveGradient.addColorStop(0.5, `hsla(${200 + Math.sin(offset + 1) * 40}, 80%, 60%, 0.3)`);
                waveGradient.addColorStop(1, `hsla(${220 + Math.sin(offset + 2) * 60}, 70%, 50%, 0)`);
                
                ctx.fillStyle = waveGradient;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height * (0.3 + wave * 0.4));
                for (let x = 0; x <= canvas.width; x += 50) {
                    const y = canvas.height * (0.3 + wave * 0.4) + Math.sin(x * 0.005 + offset * 3) * 100;
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(canvas.width, canvas.height);
                ctx.lineTo(0, canvas.height);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
            
            // Twinkling stars
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (var i = 0; i < 200; i++) {
                var x = (i * 73) % canvas.width;
                var y = (i * 37) % canvas.height;
                var size = (i % 3) + 1;
                // Animated twinkling effect
                const twinkle = Math.sin(animTime * 10 + i * 0.5) * 0.3 + 0.5;
                ctx.globalAlpha = 0.3 + (i % 5) * 0.1 * twinkle;
                ctx.fillRect(x, y, size, size);
            }
            
            // Cosmic dust particles - faster and all over screen
            ctx.globalAlpha = 0.6;
            for (let i = 0; i < 100; i++) {
                // Much faster movement (increased speed multiplier)
                const dustX = (animTime * 150 * (1 + i * 0.2) + i * 237) % (canvas.width + 100) - 50;
                const dustY = (animTime * 80 * (0.5 + i * 0.15) + i * 313) % (canvas.height + 100) - 50;
                const dustSize = 0.5 + (i % 3) * 0.5;
                
                ctx.fillStyle = `rgba(200, 200, 255, ${0.3 + (i % 4) * 0.1})`;
                ctx.beginPath();
                ctx.arc(dustX, dustY, dustSize, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(camera.x, camera.y);
            
            for (var i = 0; i < worlds.length; i++) {
                var world = worlds[i];
                
                // Check if this world is hovered
                const isHovered = crystalBall.hoveredWorld === i;
                
                // Draw highlight ring if hovered
                if (isHovered) {
                    const pulseTime = performance.now() * 0.001;
                    const pulseSize = 80 + Math.sin(pulseTime * 3) * 10;
                    
                    // Outer pulsing ring
                    ctx.strokeStyle = 'rgba(255, 255, 255, ' + (0.3 + Math.sin(pulseTime * 3) * 0.2) + ')';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(world.x, world.y, pulseSize, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner bright ring
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(world.x, world.y, 65, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.fillStyle = 'rgba(50, 50, 50, 0.5)';
                ctx.beginPath();
                ctx.moveTo(world.x, world.y - 13);
                ctx.lineTo(world.x + 40, world.y);
                ctx.lineTo(world.x, world.y + 13);
                ctx.lineTo(world.x - 40, world.y);
                ctx.closePath();
                ctx.fill();

                var glowGradient = ctx.createRadialGradient(world.x, world.y, 0, world.x, world.y, 100);
                
                // Apply darkness to Terra glow
                if (world.name === 'Terra' && game.terraDarkness.transitionProgress > 0) {
                    const darknessFactor = 1 - (game.terraDarkness.transitionProgress * 0.7);
                    const r = parseInt(world.color.substring(1, 3), 16);
                    const g = parseInt(world.color.substring(3, 5), 16);
                    const b = parseInt(world.color.substring(5, 7), 16);
                    const darkR = Math.floor(r * darknessFactor);
                    const darkG = Math.floor(g * darknessFactor);
                    const darkB = Math.floor(b * darknessFactor);
                    const darkColor = `#${darkR.toString(16).padStart(2, '0')}${darkG.toString(16).padStart(2, '0')}${darkB.toString(16).padStart(2, '0')}`;
                    glowGradient.addColorStop(0, darkColor + (isHovered ? '60' : '40'));
                    glowGradient.addColorStop(1, darkColor + '00');
                } else {
                    glowGradient.addColorStop(0, world.color + (isHovered ? '60' : '40'));
                    glowGradient.addColorStop(1, world.color + '00');
                }
                
                ctx.fillStyle = glowGradient;
                ctx.fillRect(world.x - 100, world.y - 100, 200, 200);
                
                var sphereGradient = ctx.createRadialGradient(world.x - 20, world.y - 20, 0, world.x, world.y, 60);
                
                // Apply darkness to Terra bubble
                if (world.name === 'Terra' && game.terraDarkness.transitionProgress > 0) {
                    // Convert Terra color to RGB and darken it
                    const darknessFactor = 1 - (game.terraDarkness.transitionProgress * 0.7);
                    const r = parseInt(world.color.substring(1, 3), 16);
                    const g = parseInt(world.color.substring(3, 5), 16);
                    const b = parseInt(world.color.substring(5, 7), 16);
                    const darkR = Math.floor(r * darknessFactor);
                    const darkG = Math.floor(g * darknessFactor);
                    const darkB = Math.floor(b * darknessFactor);
                    const darkColor = `#${darkR.toString(16).padStart(2, '0')}${darkG.toString(16).padStart(2, '0')}${darkB.toString(16).padStart(2, '0')}`;
                    
                    sphereGradient.addColorStop(0, darkColor);
                    sphereGradient.addColorStop(0.7, darkColor + '99');
                    sphereGradient.addColorStop(1, darkColor + '4D');
                } else {
                    sphereGradient.addColorStop(0, world.color);
                    sphereGradient.addColorStop(0.7, world.color + '99');
                    sphereGradient.addColorStop(1, world.color + '4D');
                }
                
                ctx.fillStyle = sphereGradient;
                ctx.beginPath();
                ctx.arc(world.x, world.y, 60, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(world.name, world.x, world.y + 85);
                
                // Count all kingdoms with territory in this world
                let kingdomsInWorld = new Set();
                
                // Add native kingdoms
                world.kingdoms.forEach(k => {
                    if (k.alive) kingdomsInWorld.add(k.id);
                });
                
                // Check for foreign kingdoms with territory
                for (let y = 0; y < WORLD_SIZE; y++) {
                    for (let x = 0; x < WORLD_SIZE; x++) {
                        const ownerId = world.tiles[x][y].owner;
                        if (ownerId !== null) {
                            // Find the kingdom
                            for (let w = 0; w < worlds.length; w++) {
                                const kingdom = worlds[w].kingdoms.find(k => k.id === ownerId && k.alive);
                                if (kingdom) {
                                    kingdomsInWorld.add(kingdom.id);
                                    break;
                                }
                            }
                        }
                    }
                }
                
                var aliveKingdoms = kingdomsInWorld.size;
                ctx.font = '14px Segoe UI';
                ctx.fillText(aliveKingdoms + ' kingdoms', world.x, world.y + 105);
            }

            for (const portal of game.portals) {
                const worldA = worlds[portal.worldA];
                const worldB = worlds[portal.worldB];
                
                // Determine portal color based on owner
                let strokeColor = 'rgba(200, 100, 255, 0.5)'; // Default purple
                
                if (portal.ownerId !== undefined) {
                    // Find owner kingdom
                    let ownerKingdom = null;
                    for (let w = 0; w < worlds.length; w++) {
                        ownerKingdom = worlds[w].kingdoms.find(k => k.id === portal.ownerId);
                        if (ownerKingdom) break;
                    }
                    
                    if (ownerKingdom) {
                        // Use owner's color with transparency
                        const color = ownerKingdom.color;
                        if (color.startsWith('hsl')) {
                            // Extract HSL values and add transparency
                            const hslMatch = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                            if (hslMatch) {
                                strokeColor = `hsla(${hslMatch[1]}, ${hslMatch[2]}%, ${hslMatch[3]}%, 0.7)`;
                            }
                        }
                    }
                }
                
                // Draw portal connection
                ctx.beginPath();
                ctx.moveTo(worldA.x, worldA.y);
                ctx.lineTo(worldB.x, worldB.y);
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Add portal indicators at endpoints
                ctx.fillStyle = strokeColor;
                ctx.beginPath();
                ctx.arc(worldA.x + (worldB.x - worldA.x) * 0.1, worldA.y + (worldB.y - worldA.y) * 0.1, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(worldB.x + (worldA.x - worldB.x) * 0.1, worldB.y + (worldA.y - worldB.y) * 0.1, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function renderWorldView() {
            if (!camera.currentWorld) return;
            
            var world = camera.currentWorld;
            
            // Use cached sky gradient (include darkness in cache key)
            var darknessFactor = 0;
            if (world.name === 'Terra' && game.terraDarkness.transitionProgress > 0) {
                darknessFactor = Math.round(game.terraDarkness.transitionProgress * 100) / 100;
            }
            var skyGradientKey = `${world.name},${canvas.height},${darknessFactor}`;
            var skyGradient = gradientCache.skyGradients[skyGradientKey];
            
            if (!skyGradient) {
                skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                
                switch(world.name) {
                    case 'Ignis':
                        if (darknessFactor > 0) {
                            const darkness = darknessFactor;
                            const topR = Math.floor(255 * (1 - darkness) + 60 * darkness);
                            const topG = Math.floor(107 * (1 - darkness) + 20 * darkness);
                            const topB = Math.floor(107 * (1 - darkness) + 20 * darkness);
                            const bottomR = Math.floor(255 * (1 - darkness) + 40 * darkness);
                            const bottomG = Math.floor(82 * (1 - darkness) + 10 * darkness);
                            const bottomB = Math.floor(82 * (1 - darkness) + 10 * darkness);
                            skyGradient.addColorStop(0, `rgb(${topR}, ${topG}, ${topB})`);
                            skyGradient.addColorStop(1, `rgb(${bottomR}, ${bottomG}, ${bottomB})`);
                        } else {
                            skyGradient.addColorStop(0, '#FF6B6B');
                            skyGradient.addColorStop(1, '#FF5252');
                        }
                        break;
                    case 'Aqua':
                        if (darknessFactor > 0) {
                            const darkness = darknessFactor;
                            const topR = Math.floor(0 * (1 - darkness) + 20 * darkness);
                            const topG = Math.floor(105 * (1 - darkness) + 30 * darkness);
                            const topB = Math.floor(148 * (1 - darkness) + 60 * darkness);
                            const bottomR = Math.floor(22 * (1 - darkness) + 10 * darkness);
                            const bottomG = Math.floor(78 * (1 - darkness) + 20 * darkness);
                            const bottomB = Math.floor(99 * (1 - darkness) + 40 * darkness);
                            skyGradient.addColorStop(0, `rgb(${topR}, ${topG}, ${topB})`);
                            skyGradient.addColorStop(1, `rgb(${bottomR}, ${bottomG}, ${bottomB})`);
                        } else {
                            skyGradient.addColorStop(0, '#006994');
                            skyGradient.addColorStop(1, '#164e63');
                        }
                        break;
                    case 'Aether':
                        if (darknessFactor > 0) {
                            const darkness = darknessFactor;
                            const topR = Math.floor(191 * (1 - darkness) + 60 * darkness);
                            const topG = Math.floor(219 * (1 - darkness) + 40 * darkness);
                            const topB = Math.floor(254 * (1 - darkness) + 80 * darkness);
                            const bottomR = Math.floor(59 * (1 - darkness) + 30 * darkness);
                            const bottomG = Math.floor(130 * (1 - darkness) + 20 * darkness);
                            const bottomB = Math.floor(246 * (1 - darkness) + 60 * darkness);
                            skyGradient.addColorStop(0, `rgb(${topR}, ${topG}, ${topB})`);
                            skyGradient.addColorStop(1, `rgb(${bottomR}, ${bottomG}, ${bottomB})`);
                        } else {
                            skyGradient.addColorStop(0, '#bfdbfe');
                            skyGradient.addColorStop(1, '#3b82f6');
                        }
                        break;
                    case 'Terra': 
                        if (game.terraDarkness.transitionProgress > 0) {
                            // Darken Terra sky based on darkness progress
                            const darkness = game.terraDarkness.transitionProgress;
                            // Interpolate from normal green to dark purple/black
                            const topR = Math.floor(134 * (1 - darkness) + 40 * darkness); // #86 to #28
                            const topG = Math.floor(239 * (1 - darkness) + 20 * darkness); // #ef to #14
                            const topB = Math.floor(172 * (1 - darkness) + 60 * darkness); // #ac to #3c
                            const bottomR = Math.floor(22 * (1 - darkness) + 20 * darkness); // #16 to #14
                            const bottomG = Math.floor(163 * (1 - darkness) + 10 * darkness); // #a3 to #0a
                            const bottomB = Math.floor(74 * (1 - darkness) + 30 * darkness); // #4a to #1e
                            skyGradient.addColorStop(0, `rgb(${topR}, ${topG}, ${topB})`);
                            skyGradient.addColorStop(1, `rgb(${bottomR}, ${bottomG}, ${bottomB})`);
                        } else {
                            skyGradient.addColorStop(0, '#86efac');
                            skyGradient.addColorStop(1, '#16a34a');
                        }
                        break;
                    case 'Lux': skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height); skyGradient.addColorStop(0, '#fef3c7'); skyGradient.addColorStop(1, '#f59e0b'); break;
                    case 'Umbra': skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height); skyGradient.addColorStop(0, '#581c87'); skyGradient.addColorStop(1, '#4c1d95'); break;
                    case 'Vita': skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height); skyGradient.addColorStop(0, '#a7f3d0'); skyGradient.addColorStop(1, '#10b981'); break;
                    default: skyGradient = '#87CEEB';
                }
                gradientCache.skyGradients[skyGradientKey] = skyGradient;
            }
            
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Render Umbra clouds behind the world (but wisps and ghosts on top)
            if (world.name === 'Umbra' && world.effect) {
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(camera.x, camera.y);
                
                const centerIso = worldToIsometric(world.effect.centerX, world.effect.centerY);
                const animTime = performance.now() * 0.0001;
                
                // Only render clouds here (behind world)
                ctx.save();
                ctx.globalAlpha = 0.6;
                
                world.effect.clouds.forEach(cloud => {
                    // Update cloud position (orbiting)
                    cloud.angle += cloud.speed * 0.01;
                    
                    const cloudX = centerIso.x + Math.cos(cloud.angle) * cloud.radius;
                    const cloudY = centerIso.y + Math.sin(cloud.angle) * cloud.radius * 0.5 + cloud.heightOffset;
                    
                    // Create multi-part cloud
                    const cloudParts = [
                        { dx: 0, dy: 0, size: cloud.size },
                        { dx: cloud.size * 0.6, dy: -cloud.size * 0.2, size: cloud.size * 0.8 },
                        { dx: -cloud.size * 0.5, dy: cloud.size * 0.1, size: cloud.size * 0.7 },
                        { dx: cloud.size * 0.3, dy: cloud.size * 0.2, size: cloud.size * 0.6 }
                    ];
                    
                    cloudParts.forEach(part => {
                        const partX = cloudX + part.dx;
                        const partY = cloudY + part.dy;
                        
                        const cloudGradient = ctx.createRadialGradient(
                            partX, partY, part.size * 0.3,
                            partX, partY, part.size
                        );
                        cloudGradient.addColorStop(0, `rgba(100, 50, 150, ${cloud.opacity})`);
                        cloudGradient.addColorStop(0.4, `rgba(80, 30, 120, ${cloud.opacity * 0.7})`);
                        cloudGradient.addColorStop(0.7, `rgba(60, 20, 100, ${cloud.opacity * 0.4})`);
                        cloudGradient.addColorStop(1, 'rgba(40, 10, 80, 0)');
                        
                        ctx.fillStyle = cloudGradient;
                        ctx.beginPath();
                        ctx.arc(partX, partY, part.size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Add inner glow to clouds
                    const glowGradient = ctx.createRadialGradient(
                        cloudX, cloudY, 0,
                        cloudX, cloudY, cloud.size * 0.5
                    );
                    glowGradient.addColorStop(0, `rgba(150, 100, 200, ${cloud.opacity * 0.3})`);
                    glowGradient.addColorStop(1, 'rgba(100, 50, 150, 0)');
                    
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(cloudX, cloudY, cloud.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
                ctx.restore();
            }
            
            // Simple tile rendering without caching for now
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(camera.x, camera.y);
                
            // Render tiles
            var wallHeight = 37.5;
            
            // Batch rendering by layer - collect tile data first
            const tilesToRender = [];
            let visibleTileCount = 0;
            
            // Cache RGB conversion once for the world
            var rgbData = gradientCache.worldRGB.get(world.color);
            if (!rgbData) {
                rgbData = {
                    r: parseInt(world.color.substr(1, 2), 16),
                    g: parseInt(world.color.substr(3, 2), 16),
                    b: parseInt(world.color.substr(5, 2), 16)
                };
                gradientCache.worldRGB.set(world.color, rgbData);
            }
            var r = rgbData.r;
            var g = rgbData.g;
            var b = rgbData.b;
            
            // Get or create border cache for this world and tick
            var borderCacheKey = `${world.id},${Math.floor(game.currentTick / 10)}`;
            var worldBorderCache = gradientCache.borderCache.get(borderCacheKey);
            if (!worldBorderCache) {
                worldBorderCache = new Map();
                gradientCache.borderCache.set(borderCacheKey, worldBorderCache);
                
                // Clean up old caches (keep only last 3)
                if (gradientCache.borderCache.size > 3) {
                    var firstKey = gradientCache.borderCache.keys().next().value;
                    gradientCache.borderCache.delete(firstKey);
                }
            }
            
            // First pass: collect all tiles and calculate their properties
            for (var y = 0; y < WORLD_SIZE; y++) {
                for (var x = 0; x < WORLD_SIZE; x++) {
                    var tile = world.tiles[x][y];
                    if (!tile.active) continue; // Skip inactive tiles
                    
                    visibleTileCount++;
                    
                    // Pre-calculate all tile properties
                    var brightness = tile.elevation;
                    
                    // Check if we need edge walls
                    var needsRightWall = x === WORLD_SIZE - 1 || (x < WORLD_SIZE - 1 && !world.tiles[x + 1][y].active);
                    var needsBottomWall = y === WORLD_SIZE - 1 || (y < WORLD_SIZE - 1 && !world.tiles[x][y + 1].active);
                    
                    // Calculate dynamic wall heights
                    var rightWallHeight = wallHeight;
                    var bottomWallHeight = wallHeight;
                    
                    if (!needsRightWall && x < WORLD_SIZE - 1 && world.tiles[x + 1][y].active) {
                        var rightNeighborHeight = world.tiles[x + 1][y].height;
                        var heightDiff = (tile.height - rightNeighborHeight) * 240;
                        rightWallHeight = wallHeight + heightDiff;
                    }
                    
                    if (!needsBottomWall && y < WORLD_SIZE - 1 && world.tiles[x][y + 1].active) {
                        var bottomNeighborHeight = world.tiles[x][y + 1].height;
                        var heightDiff = (tile.height - bottomNeighborHeight) * 240;
                        bottomWallHeight = wallHeight + heightDiff;
                    }
                    
                    // Cache tile color (except for Vita and Aether which need per-tile variation)
                    var tileColor;
                    if (world.name === 'Aether') {
                        // Checkerboard pattern for Aether (4x4 squares)
                        var checkX = Math.floor(x / 4);
                        var checkY = Math.floor(y / 4);
                        var isBlack = (checkX + checkY) % 2 === 0;
                        tileColor = isBlack ? 'rgb(0, 0, 0)' : 'rgb(204, 204, 204)';
                    } else if (world.name === 'Vita') {
                        // Check if this tile already has a cached color
                        var vitaTileKey = `vita_${x},${y}`;
                        tileColor = gradientCache.tileColors.get(vitaTileKey);
                        if (!tileColor) {
                            // Use the same opalescent color system as the tree leaves
                            // Each tile gets its own random color variation for opalescent effect
                            var opalR = 152 + Math.floor(Math.random() * 40 - 20);
                            var opalG = 216 + Math.floor(Math.random() * 30 - 15);
                            var opalB = 200 + Math.floor(Math.random() * 40 - 20);
                            
                            // Add slight saturation variation
                            var saturationShift = (Math.random() - 0.5) * 0.1; // -0.05 to +0.05
                            var avgColor = (opalR + opalG + opalB) / 3;
                            opalR = Math.floor(opalR + (opalR - avgColor) * saturationShift);
                            opalG = Math.floor(opalG + (opalG - avgColor) * saturationShift);
                            opalB = Math.floor(opalB + (opalB - avgColor) * saturationShift);
                            
                            // Add contrast variation
                            var contrastShift = 0.9 + Math.random() * 0.2; // 0.9 to 1.1
                            opalR = Math.floor((opalR - 128) * contrastShift + 128);
                            opalG = Math.floor((opalG - 128) * contrastShift + 128);
                            opalB = Math.floor((opalB - 128) * contrastShift + 128);
                            
                            // Clamp values to valid range
                            opalR = Math.max(0, Math.min(255, opalR));
                            opalG = Math.max(0, Math.min(255, opalG));
                            opalB = Math.max(0, Math.min(255, opalB));
                            
                            // Apply subtle brightness variation based on elevation
                            var vitaBrightness = 0.85 + tile.elevation * 0.15;
                            // Make colors 15% dimmer (was 25%, now 10% brighter)
                            vitaBrightness *= 0.85;
                            tileColor = `rgb(${Math.floor(opalR * vitaBrightness)}, ${Math.floor(opalG * vitaBrightness)}, ${Math.floor(opalB * vitaBrightness)})`;
                            gradientCache.tileColors.set(vitaTileKey, tileColor);
                        }
                    } else {
                        // Round wear to nearest 0.01 for cache efficiency
                        var roundedWear = Math.round(tile.wear * 100) / 100;
                        // Include darkness in cache key
                        var darknessFactor = 0;
                        if (world.name === 'Terra' && game.terraDarkness.transitionProgress > 0) {
                            darknessFactor = Math.round(game.terraDarkness.transitionProgress * 100) / 100;
                        }
                        var tileColorKey = `${world.color},${tile.elevation.toFixed(2)},${roundedWear},${darknessFactor}`;
                        tileColor = gradientCache.tileColors.get(tileColorKey);
                        if (!tileColor) {
                            // Apply wear darkening (wear goes from 0 to 1, darkening up to 30%)
                            var wearDarkening = 1 - (tile.wear * 0.3);
                            // Apply darkness effect
                            var terraDarkening = 1;
                            if (world.name === 'Terra' && game.terraDarkness.transitionProgress > 0) {
                                // Darken Terra based on transition progress (up to 70% darker)
                                terraDarkening = 1 - (game.terraDarkness.transitionProgress * 0.7);
                            }
                            tileColor = `rgb(${Math.floor(r * brightness * wearDarkening * terraDarkening)}, ${Math.floor(g * brightness * wearDarkening * terraDarkening)}, ${Math.floor(b * brightness * wearDarkening * terraDarkening)})`;
                            gradientCache.tileColors.set(tileColorKey, tileColor);
                        }
                    }
                    
                    // Override color if tile is lava
                    if (tile.isLava) {
                        // Create animated lava color
                        const lavaGlow = 0.8 + Math.sin(game.currentTick * 0.05 + x * 0.3 + y * 0.2) * 0.2;
                        const r = Math.floor(255 * lavaGlow);
                        const g = Math.floor(100 * lavaGlow * 0.6);
                        const b = 0;
                        tileColor = `rgb(${r}, ${g}, ${b})`;
                    }
                    
                    // Check border status
                    var tileCacheKey = `${x},${y}`;
                    var isBorderTile = false;
                    if (worldBorderCache.has(tileCacheKey)) {
                        isBorderTile = worldBorderCache.get(tileCacheKey);
                    } else {
                        if (tile.owner !== null) {
                            var neighbors = [
                                {x: x + 1, y: y}, {x: x - 1, y: y}, 
                                {x: x, y: y + 1}, {x: x, y: y - 1}
                            ];
                            for (var n = 0; n < neighbors.length; n++) {
                                var nx = neighbors[n].x;
                                var ny = neighbors[n].y;
                                if (nx >= 0 && nx < WORLD_SIZE && ny >= 0 && ny < WORLD_SIZE) {
                                    if (world.tiles[nx][ny].owner !== tile.owner) {
                                        isBorderTile = true;
                                        break;
                                    }
                                }
                            }
                        }
                        worldBorderCache.set(tileCacheKey, isBorderTile);
                    }
                    
                    // Store tile data for batch rendering
                    tilesToRender.push({
                        x: x,
                        y: y,
                        isoX: tile.isoX,
                        renderY: tile.renderY,
                        rightWall: (needsRightWall || rightWallHeight > 0) ? {
                            height: rightWallHeight,
                            color: null // Will be set later
                        } : null,
                        bottomWall: (needsBottomWall || bottomWallHeight > 0) ? {
                            height: bottomWallHeight,
                            color: null // Will be set later
                        } : null,
                        tileColor: tileColor,
                        isBorderTile: isBorderTile || tile.owner === null
                    });
                }
            }
            
            // PROPER ISOMETRIC RENDERING: Render each tile with its walls
            // Render each tile completely before moving to the next
            for (const tileData of tilesToRender) {
                ctx.save();
                ctx.translate(tileData.isoX, tileData.renderY);
                
                // Calculate wall colors based on the tile's actual color
                // Extract RGB values from the tile color
                var tileRgb;
                if (tileData.tileColor.startsWith('rgb(')) {
                    var matches = tileData.tileColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                    if (matches) {
                        tileRgb = {
                            r: parseInt(matches[1]),
                            g: parseInt(matches[2]),
                            b: parseInt(matches[3])
                        };
                    }
                } else {
                    // Fallback to world color if parsing fails
                    tileRgb = { r: r, g: g, b: b };
                }
                
                // 1. Render right wall (if exists)
                if (tileData.rightWall) {
                    // Right walls are darker (60% of tile brightness)
                    ctx.fillStyle = `rgb(${Math.floor(tileRgb.r * 0.6)}, ${Math.floor(tileRgb.g * 0.6)}, ${Math.floor(tileRgb.b * 0.6)})`;
                    ctx.beginPath();
                    ctx.moveTo(32, 0);
                    ctx.lineTo(32, tileData.rightWall.height);
                    ctx.lineTo(0, 16 + tileData.rightWall.height);
                    ctx.lineTo(0, 16);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // 2. Render bottom wall (if exists)
                if (tileData.bottomWall) {
                    // Bottom walls are slightly darker (70% of tile brightness)
                    ctx.fillStyle = `rgb(${Math.floor(tileRgb.r * 0.7)}, ${Math.floor(tileRgb.g * 0.7)}, ${Math.floor(tileRgb.b * 0.7)})`;
                    ctx.beginPath();
                    ctx.moveTo(0, 16);
                    ctx.lineTo(0, 16 + tileData.bottomWall.height);
                    ctx.lineTo(-32, tileData.bottomWall.height);
                    ctx.lineTo(-32, 0);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // 3. Render tile top
                ctx.fillStyle = tileData.tileColor;
                ctx.fill(gradientCache.tilePath);
                
                // 4. Render tile border (if needed) - REMOVED
                // if (tileData.isBorderTile) {
                //     ctx.strokeStyle = tileData.tileColor;
                //     ctx.lineWidth = 0.5;
                //     ctx.stroke(gradientCache.tilePath);
                // }
                
                ctx.restore();
            }
            
            ctx.restore();
            
            // Render world effect (except Terra, Lux and Vita - rendered elsewhere)
            if (world.effect && world.name !== 'Terra' && world.name !== 'Lux' && world.name !== 'Vita') {
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(camera.x, camera.y);
                
                // Get center position in isometric coordinates
                const centerIso = worldToIsometric(world.effect.centerX, world.effect.centerY);
                
                switch(world.name) {
                    case 'Ignis': renderIgnisEffect(ctx, centerIso, world.effect); break;
                    case 'Aqua': renderAquaEffect(ctx, centerIso, world.effect); break;
                    case 'Aether': renderAetherEffect(ctx, centerIso, world.effect); break;
                    case 'Umbra': renderUmbraEffect(ctx, centerIso, world.effect); break;
                }
                
                ctx.restore();
            }
            
            if (world) {
                // Collect all kingdoms that own tiles in this world
                var kingdomsWithTerritory = new Map();
                
                // First add native kingdoms
                if (world.kingdoms) {
                    world.kingdoms.forEach(k => {
                        if (k.alive) kingdomsWithTerritory.set(k.id + '_' + k.worldId, k);
                    });
                }
                
                // Then find foreign kingdoms that own tiles here
                for (var y = 0; y < WORLD_SIZE; y++) {
                    for (var x = 0; x < WORLD_SIZE; x++) {
                        var ownerId = world.tiles[x][y].owner;
                        if (ownerId !== null) {
                            // Check if this is a foreign kingdom
                            var found = false;
                            if (world.kingdoms) {
                                found = world.kingdoms.some(k => k.id === ownerId);
                            }
                            if (!found) {
                                // This is a foreign kingdom, find it
                                for (var w = 0; w < worlds.length; w++) {
                                    if (w !== world.id) {
                                        var foreignKingdom = worlds[w].kingdoms.find(k => k.id === ownerId);
                                        if (foreignKingdom && foreignKingdom.alive) {
                                            kingdomsWithTerritory.set(foreignKingdom.id + '_' + foreignKingdom.worldId, foreignKingdom);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(camera.x, camera.y);
                
                // Render all kingdoms with territory
                kingdomsWithTerritory.forEach(kingdom => {
                    const isBlessed = game.blessedKingdoms[kingdom.id] && game.blessedKingdoms[kingdom.id] > game.currentTick;
                    
                    ctx.strokeStyle = kingdom.color;
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.07425; // Increased opacity by 25% (was 0.0594)
                    ctx.fillStyle = kingdom.color;
                    
                    // Add golden overlay for blessed kingdoms
                    if (isBlessed) {
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.06)';
                    }
                    
                    for (var y = 0; y < WORLD_SIZE; y++) {
                        for (var x = 0; x < WORLD_SIZE; x++) {
                            var tile = world.tiles[x][y];
                            if (tile.active && tile.owner === kingdom.id) {
                                // Special handling for Aether world black tiles
                                if (world.name === 'Aether') {
                                    var checkX = Math.floor(x / 4);
                                    var checkY = Math.floor(y / 4);
                                    var isBlackTile = (checkX + checkY) % 2 === 0;
                                    if (isBlackTile) {
                                        // Draw white outline on black tiles for visibility
                                        ctx.save();
                                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                                        ctx.lineWidth = 1;
                                        ctx.beginPath();
                                        ctx.moveTo(tile.isoX, tile.renderY - 17); 
                                        ctx.lineTo(tile.isoX + 33, tile.renderY); 
                                        ctx.lineTo(tile.isoX, tile.renderY + 17); 
                                        ctx.lineTo(tile.isoX - 33, tile.renderY);
                                        ctx.closePath(); 
                                        ctx.stroke();
                                        ctx.restore();
                                    }
                                }
                                
                                ctx.beginPath();
                                ctx.moveTo(tile.isoX, tile.renderY - 17); 
                                ctx.lineTo(tile.isoX + 33, tile.renderY); 
                                ctx.lineTo(tile.isoX, tile.renderY + 17); 
                                ctx.lineTo(tile.isoX - 33, tile.renderY);
                                ctx.closePath(); 
                                ctx.fill();
                                
                                // Add shimmer effect for blessed territories
                                if (isBlessed && Math.random() < 0.02) {
                                    ctx.save();
                                    const animTime = performance.now() * 0.0001;
                                    const shimmerAlpha = 0.3 + Math.sin(animTime * 10 + x + y) * 0.2;
                                    ctx.fillStyle = `rgba(255, 255, 200, ${shimmerAlpha})`;
                                    ctx.fill();
                                    ctx.restore();
                                }
                            }
                        }
                    }
                    
                    // Draw glowing borders for blessed kingdoms
                    if (isBlessed) {
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = 4;
                        const animTime = performance.now() * 0.0005;
                        ctx.globalAlpha = 0.15 + Math.sin(animTime) * 0.06;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#ffd700';
                    } else {
                        ctx.globalAlpha = 0.21;
                        ctx.shadowBlur = 0;
                    }
                    
                    for (var y = 0; y < WORLD_SIZE; y++) {
                        for (var x = 0; x < WORLD_SIZE; x++) {
                            var tile = world.tiles[x][y];
                            if (tile.active && tile.owner === kingdom.id) {
                                var neighbors = [ {x: x + 1, y: y, edge: 'right'}, {x: x - 1, y: y, edge: 'left'}, {x: x, y: y + 1, edge: 'bottom'}, {x: x, y: y - 1, edge: 'top'} ];
                                for (var n = 0; n < neighbors.length; n++) {
                                    var neighbor = neighbors[n];
                                    if (neighbor.x < 0 || neighbor.x >= WORLD_SIZE || neighbor.y < 0 || neighbor.y >= WORLD_SIZE || 
                                        !world.tiles[neighbor.x][neighbor.y].active || 
                                        world.tiles[neighbor.x][neighbor.y].owner !== kingdom.id) {
                                        
                                        // Check if neighbor is a valid active tile
                                        var isNeighborActive = neighbor.x >= 0 && neighbor.x < WORLD_SIZE && 
                                                               neighbor.y >= 0 && neighbor.y < WORLD_SIZE && 
                                                               world.tiles[neighbor.x][neighbor.y].active;
                                        
                                        ctx.beginPath();
                                        switch(neighbor.edge) {
                                            case 'right': 
                                                ctx.moveTo(tile.isoX + 32, tile.renderY); 
                                                ctx.lineTo(tile.isoX, tile.renderY + 16); 
                                                // Only add vertical line if neighbor is active and has elevation difference
                                                if (isNeighborActive) {
                                                    var neighborHeight = world.tiles[neighbor.x][neighbor.y].height;
                                                    var neighborElevationOffset = (neighborHeight - 0.65) * 240;
                                                    if (Math.abs(tile.renderY - (tile.isoY - neighborElevationOffset)) > 5) {
                                                        ctx.lineTo(tile.isoX, tile.isoY - neighborElevationOffset + 16);
                                                    }
                                                }
                                                break;
                                            case 'left': 
                                                ctx.moveTo(tile.isoX - 32, tile.renderY); 
                                                ctx.lineTo(tile.isoX, tile.renderY - 16); 
                                                // Only add vertical line if neighbor is active and has elevation difference
                                                if (isNeighborActive) {
                                                    var neighborHeight = world.tiles[neighbor.x][neighbor.y].height;
                                                    var neighborElevationOffset = (neighborHeight - 0.65) * 240;
                                                    if (Math.abs(tile.renderY - (tile.isoY - neighborElevationOffset)) > 5) {
                                                        ctx.lineTo(tile.isoX, tile.isoY - neighborElevationOffset - 16);
                                                    }
                                                }
                                                break;
                                            case 'bottom': 
                                                ctx.moveTo(tile.isoX, tile.renderY + 16); 
                                                ctx.lineTo(tile.isoX - 32, tile.renderY); 
                                                // Only add vertical line if neighbor is active and has elevation difference
                                                if (isNeighborActive) {
                                                    var neighborHeight = world.tiles[neighbor.x][neighbor.y].height;
                                                    var neighborElevationOffset = (neighborHeight - 0.65) * 240;
                                                    if (Math.abs(tile.renderY - (tile.isoY - neighborElevationOffset)) > 5) {
                                                        ctx.lineTo(tile.isoX - 32, tile.isoY - neighborElevationOffset);
                                                    }
                                                }
                                                break;
                                            case 'top': 
                                                ctx.moveTo(tile.isoX, tile.renderY - 16); 
                                                ctx.lineTo(tile.isoX + 32, tile.renderY); 
                                                // Only add vertical line if neighbor is active and has elevation difference
                                                if (isNeighborActive) {
                                                    var neighborHeight = world.tiles[neighbor.x][neighbor.y].height;
                                                    var neighborElevationOffset = (neighborHeight - 0.65) * 240;
                                                    if (Math.abs(tile.renderY - (tile.isoY - neighborElevationOffset)) > 5) {
                                                        ctx.lineTo(tile.isoX + 32, tile.isoY - neighborElevationOffset);
                                                    }
                                                }
                                                break;
                                        }
                                        ctx.stroke();
                                    }
                                }
                            }
                        }
                    }
                    
                    // Reset shadow for next kingdom
                    ctx.shadowBlur = 0;
                });
                ctx.globalAlpha = 1;
                ctx.restore();
            }
            
            if (world) {
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(camera.x, camera.y);

                // Collect all kingdoms that have territory in this world
                const kingdomsWithTerritory = new Map();
                
                // First add native kingdoms
                if (world.kingdoms) {
                    world.kingdoms.forEach(k => {
                        if (k.alive) kingdomsWithTerritory.set(k.id, k);
                    });
                }
                
                // Then find foreign kingdoms that own tiles here
                for (let y = 0; y < WORLD_SIZE; y++) {
                    for (let x = 0; x < WORLD_SIZE; x++) {
                        const ownerId = world.tiles[x][y].owner;
                        if (ownerId !== null && !kingdomsWithTerritory.has(ownerId)) {
                            // This is a foreign kingdom, find it
                            for (let w = 0; w < worlds.length; w++) {
                                const foreignKingdom = worlds[w].kingdoms.find(k => k.id === ownerId && k.alive);
                                if (foreignKingdom) {
                                    kingdomsWithTerritory.set(ownerId, foreignKingdom);
                                    break;
                                }
                            }
                        }
                    }
                }

                // Render Nomad Tribe for Aether world (before villages and capitals so they appear behind)
                if (world.name === 'Aether' && world.nomadTribe) {
                    renderNomadTribe(ctx, world.nomadTribe);
                }
                
                // Render fields for all villages
                if (world.villages) {
                    world.villages.forEach(village => {
                        // Check if village is burned
                        const villageKey = village.x + ',' + village.y + ',' + world.id;
                        const isBurned = game.burnedVillages[villageKey] && game.burnedVillages[villageKey] > game.currentTick;
                        
                        if (!isBurned) { // Only render fields if not burned
                            const tile = world.tiles[village.x][village.y];
                            renderFields(ctx, tile.isoX, tile.renderY, world.color, world);
                        }
                    });
                }
                
                // Render all villages
                if (world.villages) {
                    world.villages.forEach(village => {
                        const tile = world.tiles[village.x][village.y];
                        
                        // Find the current owner of this village tile
                        const currentOwner = tile.owner;
                        if (currentOwner !== null) {
                            // Find the kingdom that currently owns this tile
                            let ownerKingdom = kingdomsWithTerritory.get(currentOwner);
                            if (ownerKingdom && ownerKingdom.alive) {
                                // Check if village is burned
                                const villageKey = village.x + ',' + village.y + ',' + world.id;
                                const isBurned = game.burnedVillages[villageKey] && game.burnedVillages[villageKey] > game.currentTick;
                                renderVillage(ctx, tile.isoX, tile.renderY, ownerKingdom, isBurned, village, world);
                            }
                        }
                    });
                }

                ctx.restore();
            }
            
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(camera.x, camera.y);
            game.portals.forEach(portal => {
                if (portal.worldA === world.id) renderPortal(ctx, worldToIsometric(portal.tileA.x, portal.tileA.y), portal, world);
                if (portal.worldB === world.id) renderPortal(ctx, worldToIsometric(portal.tileB.x, portal.tileB.y), portal, world);
            });
            
            // Render burned bodies before armies so they appear on the ground
            game.divineEffects.forEach(effect => {
                if (effect.worldId === world.id && effect instanceof BurnedBody) {
                    renderBurnedBody(ctx, effect);
                }
            });
            
            // Render war kingdom highlights
            renderWarKingdomHighlights(ctx, world);
            
            // Render peace kingdom highlights
            renderPeaceKingdomHighlights(ctx, world);
            
            // Render portal highlights
            renderPortalHighlights(ctx, world);
            
            // Render kingdom creation highlights
            renderKingdomHighlights(ctx, world);
            
            // Render terraform highlights
            renderTerraformHighlights(ctx, world);
            
            // Render sculpt highlights
            renderSculptHighlights(ctx, world);
            
            // Render armies from all kingdoms (both native and foreign)
            var allArmies = [];
            
            // Collect armies from native kingdoms
            world.kingdoms.forEach(kingdom => {
                if (kingdom.alive) {
                    kingdom.armies.forEach(army => {
                        if (army.alive && army.worldId === world.id) {
                            allArmies.push(army);
                        }
                    });
                }
            });
            
            // Collect armies from foreign kingdoms
            for (var w = 0; w < worlds.length; w++) {
                if (w !== world.id) {
                    worlds[w].kingdoms.forEach(kingdom => {
                        if (kingdom.alive) {
                            kingdom.armies.forEach(army => {
                                if (army.alive && army.worldId === world.id) {
                                    allArmies.push(army);
                                }
                            });
                        }
                    });
                }
            }
            
            // Render all armies
            allArmies.forEach(army => {
                var pos = army.getPosition();
                var iso = worldToIsometric(pos.x, pos.y);
                // Get tile height at army position
                var tileX = Math.floor(pos.x);
                var tileY = Math.floor(pos.y);
                if (tileX >= 0 && tileX < WORLD_SIZE && tileY >= 0 && tileY < WORLD_SIZE) {
                    var tile = world.tiles[tileX][tileY];
                    var elevationOffset = (tile.height - 0.65) * 240;
                    renderArmy(ctx, iso.x, iso.y - elevationOffset, army, world);
                } else {
                    renderArmy(ctx, iso.x, iso.y, army, world);
                }
            });
            if (world.recruits && world.recruits.length > 0) {
                world.recruits.forEach(recruit => {
                    var pos = recruit.getPosition();
                    var iso = worldToIsometric(pos.x, pos.y);
                    // Get tile height at recruit position
                    var tileX = Math.floor(pos.x);
                    var tileY = Math.floor(pos.y);
                    if (tileX >= 0 && tileX < WORLD_SIZE && tileY >= 0 && tileY < WORLD_SIZE) {
                        var tile = world.tiles[tileX][tileY];
                        var elevationOffset = (tile.height - 0.65) * 240;
                        renderRecruitGroup(ctx, iso.x, iso.y - elevationOffset, recruit, world);
                    } else {
                        renderRecruitGroup(ctx, iso.x, iso.y, recruit, world);
                    }
                });
            }
            
            // Render all capitals AFTER armies and recruits
            const kingdomsWithTerritory2 = new Map();
            
            // First add native kingdoms
            if (world.kingdoms) {
                world.kingdoms.forEach(k => {
                    if (k.alive) kingdomsWithTerritory2.set(k.id, k);
                });
            }
            
            // Then find foreign kingdoms that own tiles here
            for (let y = 0; y < WORLD_SIZE; y++) {
                for (let x = 0; x < WORLD_SIZE; x++) {
                    const ownerId = world.tiles[x][y].owner;
                    if (ownerId !== null && !kingdomsWithTerritory2.has(ownerId)) {
                        // This is a foreign kingdom, find it
                        for (let w = 0; w < worlds.length; w++) {
                            const foreignKingdom = worlds[w].kingdoms.find(k => k.id === ownerId && k.alive);
                            if (foreignKingdom) {
                                kingdomsWithTerritory2.set(ownerId, foreignKingdom);
                                break;
                            }
                        }
                    }
                }
            }
            
            // Render ALL controlled capitals from all kingdoms (fixes invisible capital bug)
            const allCapitalsToRender = new Map(); // Use map to avoid duplicates
            
            // First, add all original capital positions from world.capitals
            // This ensures we never miss a capital position
            world.capitals.forEach(capitalPos => {
                const ownerId = world.tiles[capitalPos.x][capitalPos.y].owner;
                if (ownerId !== null) {
                    const ownerKingdom = kingdomsWithTerritory2.get(ownerId);
                    if (ownerKingdom && ownerKingdom.alive) {
                        const key = capitalPos.x + ',' + capitalPos.y;
                        const isOriginal = capitalPos.x === ownerKingdom.capitalX && capitalPos.y === ownerKingdom.capitalY;
                        allCapitalsToRender.set(key, {
                            pos: capitalPos,
                            kingdom: ownerKingdom,
                            isOriginal: isOriginal
                        });
                    }
                }
            });
            
            // Then add all controlled capitals from kingdoms that have territory in this world
            kingdomsWithTerritory2.forEach(kingdom => {
                if (kingdom.alive && kingdom.controlledCapitals) {
                    kingdom.controlledCapitals.forEach(capital => {
                        // Verify this capital is in the current world and owned by this kingdom
                        if (world.tiles[capital.x] && world.tiles[capital.x][capital.y] && 
                            world.tiles[capital.x][capital.y].owner === kingdom.id) {
                            const key = capital.x + ',' + capital.y;
                            allCapitalsToRender.set(key, {
                                pos: capital,
                                kingdom: kingdom,
                                isOriginal: capital.x === kingdom.capitalX && capital.y === kingdom.capitalY
                            });
                        }
                    });
                }
            });
            
            // Render all capitals
            allCapitalsToRender.forEach(capitalData => {
                // Use pre-calculated positions
                const tile = world.tiles[capitalData.pos.x][capitalData.pos.y];
                
                // Check if capital is burned
                const capitalKey = capitalData.pos.x + ',' + capitalData.pos.y + ',' + world.id;
                const isBurned = game.burnedCapitals[capitalKey] && game.burnedCapitals[capitalKey] > game.currentTick;
                
                renderCapital(ctx, tile.isoX, tile.renderY, capitalData.kingdom, capitalData.isOriginal, isBurned, capitalData.pos, world);
            });
            
            // Render witch house if it exists
            if (world.name === 'Terra' && game.terraWitch.hasHouse) {
                const houseX = Math.floor(game.terraWitch.houseX);
                const houseY = Math.floor(game.terraWitch.houseY);
                if (houseX >= 0 && houseX < WORLD_SIZE && houseY >= 0 && houseY < WORLD_SIZE) {
                    const tile = world.tiles[houseX][houseY];
                    if (tile && tile.buildingType === 'witch_house') {
                        // Render spire first, then bones on top
                        renderWitchHouse(ctx, tile.isoX, tile.renderY);
                        renderWitchBones(ctx, game.terraWitch, world);
                    }
                }
            }
            
            game.battles.forEach(battle => {
                if (battle.worldId === world.id) {
                    var iso = worldToIsometric(battle.x, battle.y);
                    renderBattle(ctx, iso.x, iso.y, battle);
                }
            });
            game.armySpawns.forEach(spawn => {
                 if (spawn.worldId === world.id) {
                    var iso = worldToIsometric(spawn.x, spawn.y);
                    renderArmySpawn(ctx, iso.x, iso.y, spawn);
                 }
            });
            
            // Render temples
            game.temples.forEach(temple => {
                if (temple.worldId === world.id) {
                    renderTemple(ctx, temple, world);
                }
            });
            
            world.kingdoms.forEach(kingdom => {
                if (kingdom.alive && kingdom.templeRequests.length > 0) {
                    var request = kingdom.templeRequests[0];
                    
                    // Render request only at the capital that generated it
                    const requestCapital = request.capital;
                    if (requestCapital && requestCapital.x !== undefined && requestCapital.y !== undefined) {
                        const capitalTile = world.tiles[requestCapital.x] && world.tiles[requestCapital.x][requestCapital.y];
                        if (capitalTile && capitalTile.owner === kingdom.id) {
                            var capitalIso = worldToIsometric(requestCapital.x, requestCapital.y);
                            
                            // Check if this is the original capital for height calculation
                            const isOriginalCapital = requestCapital.x === kingdom.capitalX && requestCapital.y === kingdom.capitalY;
                            const heightExtension = isOriginalCapital ? (kingdom.controlledCapitals.length - 1) * 8 : 0;
                            const requestYOffset = 90 + heightExtension + (kingdom.worldConqueror ? 10 : 0);
                            
                            renderTempleRequest(ctx, capitalIso.x, capitalIso.y - requestYOffset, request, kingdom, world);
                        }
                    }
                }
            });
            
            // Render divine effects
            game.divineEffects.forEach(effect => {
                if (effect.worldId === world.id) {
                    if (effect instanceof LightningStrike) {
                        renderLightningStrike(ctx, effect);
                    } else if (effect instanceof BlessingEffect) {
                        renderBlessingEffect(ctx, effect);
                    } else if (effect instanceof StructureBurnEffect) {
                        renderStructureBurnEffect(ctx, effect);
                    } else if (effect instanceof KingdomDefeatEffect) {
                        renderKingdomDefeatEffect(ctx, effect);
                    } else if (effect instanceof VictoryEffect) {
                        renderVictoryEffect(ctx, effect);
                    } else if (effect instanceof FishParticle) {
                        renderFishParticle(ctx, effect);
                    } else if (effect instanceof WitchDarkPowerParticle) {
                        renderWitchDarkPowerParticle(ctx, effect);
                    } else if (effect instanceof DarkPowerConsumeParticle) {
                        renderDarkPowerConsumeParticle(ctx, effect);
                    } else if (effect instanceof ArmyDeathSmoke) {
                        renderArmyDeathSmoke(ctx, effect);
                    } else if (effect instanceof TempleSpawnParticle) {
                        renderTempleSpawnParticle(ctx, effect);
                    } else if (effect instanceof TempleDestructionParticle) {
                        renderTempleDestructionParticle(ctx, effect);
                    } else if (effect instanceof RedGodRay) {
                        renderRedGodRay(ctx, effect);
                    } else if (effect instanceof GoldenGodRay) {
                        renderGoldenGodRay(ctx, effect);
                    } else if (effect instanceof PortalCreationEffect) {
                        renderPortalCreationEffect(ctx, effect);
                    } else if (effect instanceof RequestBubbleClickEffect) {
                        renderRequestBubbleClickEffect(ctx, effect);
                    } else if (effect instanceof KingdomCreationEffect) {
                        renderKingdomCreationEffect(ctx, effect);
                    } else if (effect instanceof TerraformEffect) {
                        renderTerraformEffect(ctx, effect);
                    } else if (effect instanceof SculptEffect) {
                        renderSculptEffect(ctx, effect);
                    }
                    // Note: BurnedBody is rendered earlier with ground elements
                }
            });
            
            // Render Giant Fish for Aqua world (above everything else)
            if (world.name === 'Aqua' && game.giantFish.active) {
                renderGiantFish(ctx, world);
            }
            
            ctx.restore();
            
            // Render Ignis shadow armies ABOVE buildings and units
            if (world.effect && world.name === 'Ignis' && world.effect.shadowArmies) {
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(camera.x, camera.y);
                
                const centerIso = worldToIsometric(world.effect.centerX, world.effect.centerY);
                renderIgnisShadows(ctx, centerIso, world.effect);
                
                ctx.restore();
            }
            
            // Render Terra effect ABOVE everything else (crystals and particles above kingdoms)
            if (world.effect && world.name === 'Terra') {
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(camera.x, camera.y);
                
                const centerIso = worldToIsometric(world.effect.centerX, world.effect.centerY);
                renderTerraEffect(ctx, centerIso, world.effect);
                
                ctx.restore();
            }
            
            // Render Terra Witch (above everything else)
            if (world.name === 'Terra' && game.terraWitch.active && game.terraWitch.phase !== 'in_house') {
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(camera.x, camera.y);
                
                renderTerraWitch(ctx, world);
                
                ctx.restore();
            }
            
            // World witch rendering removed - only Terra has a witch
            
            // Render dark clouds for Terra
            if (world && world.name === 'Terra') {
                game.darkClouds.forEach(cloud => {
                    if (cloud.worldId === world.id && cloud.opacity > 0) {
                        ctx.save();
                        ctx.translate(canvas.width / 2, canvas.height / 2);
                        ctx.scale(camera.zoom, camera.zoom);
                        ctx.translate(camera.x, camera.y);
                        
                        // Convert world position to isometric
                        const iso = worldToIsometric(cloud.x, cloud.y);
                        
                        // Draw dark cloud shadow on ground
                        ctx.fillStyle = `rgba(20, 10, 30, ${cloud.opacity * 0.3})`;
                        ctx.beginPath();
                        ctx.ellipse(iso.x, iso.y, cloud.radius * 33, cloud.radius * 16.5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw dark cloud above - one big cloud from curved lines
                        const cloudHeight = 600; // Much higher above ground
                        ctx.translate(iso.x, iso.y - cloudHeight);
                        
                        // Create gradient for cloud - less transparent
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, cloud.radius * 40);
                        gradient.addColorStop(0, `rgba(20, 10, 30, ${cloud.opacity * 1.4})`);
                        gradient.addColorStop(0.3, `rgba(40, 20, 60, ${cloud.opacity * 1.2})`);
                        gradient.addColorStop(0.7, `rgba(50, 25, 80, ${cloud.opacity * 0.9})`);
                        gradient.addColorStop(1, `rgba(60, 30, 90, 0)`);
                        
                        ctx.fillStyle = gradient;
                        const time = game.currentTick * 0.01;
                        const cloudWidth = WORLD_SIZE * 35; // Width of entire tile map in isometric
                        const cloudHeight2 = cloudWidth * 0.3; // Height of the cloud shape
                        
                        // Draw one big cloud using bezier curves
                        ctx.beginPath();
                        
                        // Initialize random seed for this cloud if not exists
                        if (!cloud.randomSeed) {
                            cloud.randomSeed = [];
                            for (let i = 0; i < 20; i++) {
                                cloud.randomSeed.push(Math.random() * 20 - 10);
                            }
                        }
                        
                        // Animate the cloud shape with randomness
                        const wave1 = Math.sin(time) * 5 + cloud.randomSeed[0];
                        const wave2 = Math.sin(time * 1.3) * 3 + cloud.randomSeed[1];
                        const wave3 = Math.sin(time * 0.7) * 4 + cloud.randomSeed[2];
                        
                        // Start from left edge
                        ctx.moveTo(-cloudWidth * 0.5, 0);
                        
                        // Top edge with curved bumps using random variations
                        ctx.bezierCurveTo(
                            -cloudWidth * 0.4 + cloud.randomSeed[3], -cloudHeight2 * 0.5 + wave1 + cloud.randomSeed[4],
                            -cloudWidth * 0.3 + cloud.randomSeed[5], -cloudHeight2 * 0.7 + wave2 + cloud.randomSeed[6],
                            -cloudWidth * 0.2 + cloud.randomSeed[7], -cloudHeight2 * 0.6 + wave3 + cloud.randomSeed[8]
                        );
                        ctx.bezierCurveTo(
                            -cloudWidth * 0.1 + cloud.randomSeed[9], -cloudHeight2 * 0.8 + wave1 + cloud.randomSeed[10],
                            0 + cloud.randomSeed[11], -cloudHeight2 * 0.9 + wave2 + cloud.randomSeed[12],
                            cloudWidth * 0.1 + cloud.randomSeed[13], -cloudHeight2 * 0.8 + wave3 + cloud.randomSeed[14]
                        );
                        ctx.bezierCurveTo(
                            cloudWidth * 0.2 + cloud.randomSeed[15], -cloudHeight2 * 0.7 + wave1 + cloud.randomSeed[16],
                            cloudWidth * 0.3 + cloud.randomSeed[17], -cloudHeight2 * 0.6 + wave2 + cloud.randomSeed[18],
                            cloudWidth * 0.4 + cloud.randomSeed[19], -cloudHeight2 * 0.5 + wave3 + cloud.randomSeed[3]
                        );
                        
                        // Right edge
                        ctx.bezierCurveTo(
                            cloudWidth * 0.45, -cloudHeight2 * 0.3,
                            cloudWidth * 0.5, -cloudHeight2 * 0.1,
                            cloudWidth * 0.5, 0
                        );
                        
                        // Bottom edge with gentle curves
                        ctx.bezierCurveTo(
                            cloudWidth * 0.4, cloudHeight2 * 0.2 + wave3,
                            cloudWidth * 0.3, cloudHeight2 * 0.3 + wave2,
                            cloudWidth * 0.2, cloudHeight2 * 0.25 + wave1
                        );
                        ctx.bezierCurveTo(
                            cloudWidth * 0.1, cloudHeight2 * 0.2 + wave3,
                            0, cloudHeight2 * 0.15 + wave2,
                            -cloudWidth * 0.1, cloudHeight2 * 0.2 + wave1
                        );
                        ctx.bezierCurveTo(
                            -cloudWidth * 0.2, cloudHeight2 * 0.25 + wave3,
                            -cloudWidth * 0.3, cloudHeight2 * 0.3 + wave2,
                            -cloudWidth * 0.4, cloudHeight2 * 0.2 + wave1
                        );
                        
                        // Close path back to start
                        ctx.bezierCurveTo(
                            -cloudWidth * 0.45, cloudHeight2 * 0.1,
                            -cloudWidth * 0.5, 0,
                            -cloudWidth * 0.5, 0
                        );
                        
                        ctx.closePath();
                        ctx.fill();
                        
                        // Add inner darker layer for depth
                        ctx.fillStyle = `rgba(15, 5, 25, ${cloud.opacity * 0.3})`;
                        ctx.beginPath();
                        ctx.moveTo(-cloudWidth * 0.3, 0);
                        ctx.bezierCurveTo(
                            -cloudWidth * 0.2, -cloudHeight2 * 0.4 + wave2,
                            -cloudWidth * 0.1, -cloudHeight2 * 0.5 + wave1,
                            0, -cloudHeight2 * 0.4 + wave3
                        );
                        ctx.bezierCurveTo(
                            cloudWidth * 0.1, -cloudHeight2 * 0.5 + wave2,
                            cloudWidth * 0.2, -cloudHeight2 * 0.4 + wave1,
                            cloudWidth * 0.3, 0
                        );
                        ctx.bezierCurveTo(
                            cloudWidth * 0.2, cloudHeight2 * 0.15 + wave3,
                            cloudWidth * 0.1, cloudHeight2 * 0.1 + wave2,
                            0, cloudHeight2 * 0.05 + wave1
                        );
                        ctx.bezierCurveTo(
                            -cloudWidth * 0.1, cloudHeight2 * 0.1 + wave3,
                            -cloudWidth * 0.2, cloudHeight2 * 0.15 + wave2,
                            -cloudWidth * 0.3, 0
                        );
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.globalAlpha = 1;
                        
                        // Add dark lightning to crystals rarely
                        if (Math.random() < 0.002 && cloud.opacity > 0.3 && world.effect && world.effect.crystals) {
                            // Find a green crystal to strike
                            const greenCrystals = world.effect.crystals.filter(c => c.color === '#00FF00' || c.color === '#50FF50');
                            
                            if (greenCrystals.length > 0) {
                                const targetCrystal = greenCrystals[Math.floor(Math.random() * greenCrystals.length)];
                                
                                // Calculate crystal position
                                const animTime = performance.now() * 0.0001;
                                const angle = targetCrystal.baseAngle + animTime * 0.3;
                                const crystalX = Math.cos(angle) * targetCrystal.orbitRadius;
                                const crystalY = Math.sin(angle) * targetCrystal.orbitRadius * 0.5 + cloudHeight - targetCrystal.height;
                                
                                // Draw lightning from cloud to crystal
                                ctx.strokeStyle = `rgba(120, 60, 180, ${cloud.opacity})`;
                                ctx.lineWidth = 3;
                                ctx.shadowBlur = 20;
                                ctx.shadowColor = 'rgba(120, 60, 180, 1)';
                                
                                const startX = (Math.random() - 0.5) * cloudWidth * 0.3;
                                const startY = cloudHeight2 * 0.05;
                                
                                ctx.beginPath();
                                ctx.moveTo(startX, startY);
                                
                                // Create jagged lightning path
                                let currentX = startX;
                                let currentY = startY;
                                const segments = 6;
                                
                                for (let j = 0; j < segments; j++) {
                                    const progress = (j + 1) / segments;
                                    const targetX = startX + (crystalX - startX) * progress;
                                    const targetY = startY + (crystalY - startY) * progress;
                                    
                                    currentX = targetX + (Math.random() - 0.5) * 40 * (1 - progress);
                                    currentY = targetY + (Math.random() - 0.5) * 20 * (1 - progress);
                                    
                                    ctx.lineTo(currentX, currentY);
                                }
                                
                                // Final segment to crystal
                                ctx.lineTo(crystalX, crystalY);
                                ctx.stroke();
                                
                                // Add bright flash at impact
                                ctx.fillStyle = `rgba(180, 120, 255, ${cloud.opacity * 0.8})`;
                                ctx.beginPath();
                                ctx.arc(crystalX, crystalY, 15, 0, Math.PI * 2);
                                ctx.fill();
                                
                                ctx.shadowBlur = 0;
                                
                                // Turn the crystal purple
                                targetCrystal.color = '#9B59B6'; // Purple color
                                targetCrystal.struckByLightning = true;
                                targetCrystal.lightningTime = game.currentTick;
                            }
                        }
                        
                        ctx.restore();
                    }
                });
            }
            
            // Render Vita Tree of Life ABOVE everything else
            if (world.effect && world.name === 'Vita') {
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(camera.x, camera.y);
                
                const centerIso = worldToIsometric(world.effect.centerX, world.effect.centerY);
                renderVitaEffect(ctx, centerIso, world.effect);
                
                ctx.restore();
            }
            
            // Render ability targeting indicator
            if ((game.abilities.smite.active || game.abilities.bless.active) && hoveredTile) {
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(camera.x, camera.y);
                
                if (game.abilities.smite.active) {
                    // Draw radius indicator for smite
                    const centerIso = worldToIsometric(hoveredTile.x, hoveredTile.y);
                    ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    
                    // Draw rough circle showing dynamic radius
                    ctx.beginPath();
                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                        const tileX = hoveredTile.x + Math.round(Math.cos(angle) * game.abilities.smite.radius);
                        const tileY = hoveredTile.y + Math.round(Math.sin(angle) * game.abilities.smite.radius);
                        
                        // Check if tile is in bounds and get elevation
                        if (tileX >= 0 && tileX < WORLD_SIZE && tileY >= 0 && tileY < WORLD_SIZE) {
                            const tile = world.tiles[tileX][tileY];
                            if (tile && tile.active) {
                                const iso = worldToIsometric(tileX, tileY);
                                const elevationOffset = (tile.height - 0.65) * 240;
                                
                                if (angle === 0) {
                                    ctx.moveTo(iso.x, iso.y - elevationOffset);
                                } else {
                                    ctx.lineTo(iso.x, iso.y - elevationOffset);
                                }
                            }
                        }
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Highlight center tile with elevation
                    const centerTile = world.tiles[hoveredTile.x][hoveredTile.y];
                    const centerElevationOffset = (centerTile.height - 0.65) * 240;
                    ctx.fillStyle = 'rgba(255, 100, 100, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(centerIso.x, centerIso.y - centerElevationOffset - 17);
                    ctx.lineTo(centerIso.x + 33, centerIso.y - centerElevationOffset);
                    ctx.lineTo(centerIso.x, centerIso.y - centerElevationOffset + 17);
                    ctx.lineTo(centerIso.x - 33, centerIso.y - centerElevationOffset);
                    ctx.closePath();
                    ctx.fill();
                } else if (game.abilities.bless.active) {
                    // Highlight hovered kingdom's territory
                    const tile = world.tiles[hoveredTile.x][hoveredTile.y];
                    if (tile.owner !== null) {
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
                        ctx.lineWidth = 2;
                        
                        // Fill all tiles of this kingdom
                        for (let y = 0; y < WORLD_SIZE; y++) {
                            for (let x = 0; x < WORLD_SIZE; x++) {
                                if (world.tiles[x][y].owner === tile.owner) {
                                    const iso = worldToIsometric(x, y);
                                    const tileHeight = world.tiles[x][y].height;
                                    const elevationOffset = (tileHeight - 0.65) * 240;
                                    ctx.beginPath();
                                    ctx.moveTo(iso.x, iso.y - 17 - elevationOffset);
                                    ctx.lineTo(iso.x + 33, iso.y - elevationOffset);
                                    ctx.lineTo(iso.x, iso.y + 17 - elevationOffset);
                                    ctx.lineTo(iso.x - 33, iso.y - elevationOffset);
                                    ctx.closePath();
                                    ctx.fill();
                                }
                            }
                        }
                        
                        // Draw only outer borders
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                        ctx.lineWidth = 3;
                        for (let y = 0; y < WORLD_SIZE; y++) {
                            for (let x = 0; x < WORLD_SIZE; x++) {
                                if (world.tiles[x][y].owner === tile.owner) {
                                    const iso = worldToIsometric(x, y);
                                    const tileHeight = world.tiles[x][y].height;
                                    const elevationOffset = (tileHeight - 0.65) * 240;
                                    
                                    // Check each edge to see if it borders a non-kingdom tile
                                    const neighbors = [
                                        {x: x + 1, y: y, edge: 'right'},
                                        {x: x - 1, y: y, edge: 'left'},
                                        {x: x, y: y + 1, edge: 'bottom'},
                                        {x: x, y: y - 1, edge: 'top'}
                                    ];
                                    
                                    for (const neighbor of neighbors) {
                                        if (neighbor.x < 0 || neighbor.x >= WORLD_SIZE || 
                                            neighbor.y < 0 || neighbor.y >= WORLD_SIZE ||
                                            !world.tiles[neighbor.x][neighbor.y].active ||
                                            world.tiles[neighbor.x][neighbor.y].owner !== tile.owner) {
                                            
                                            // Check if neighbor is a valid active tile
                                            const isNeighborActive = neighbor.x >= 0 && neighbor.x < WORLD_SIZE && 
                                                                   neighbor.y >= 0 && neighbor.y < WORLD_SIZE && 
                                                                   world.tiles[neighbor.x][neighbor.y].active;
                                            
                                            ctx.beginPath();
                                            switch(neighbor.edge) {
                                                case 'right':
                                                    ctx.moveTo(iso.x + 33, iso.y - elevationOffset);
                                                    ctx.lineTo(iso.x, iso.y + 17 - elevationOffset);
                                                    // Only add vertical line if neighbor is active and has elevation difference
                                                    if (isNeighborActive) {
                                                        const neighborHeight = world.tiles[neighbor.x][neighbor.y].height;
                                                        const neighborElevationOffset = (neighborHeight - 0.65) * 240;
                                                        if (Math.abs(elevationOffset - neighborElevationOffset) > 5) {
                                                            ctx.lineTo(iso.x, iso.y + 17 - neighborElevationOffset);
                                                        }
                                                    }
                                                    break;
                                                case 'left':
                                                    ctx.moveTo(iso.x - 33, iso.y - elevationOffset);
                                                    ctx.lineTo(iso.x, iso.y - 17 - elevationOffset);
                                                    // Only add vertical line if neighbor is active and has elevation difference
                                                    if (isNeighborActive) {
                                                        const neighborHeight = world.tiles[neighbor.x][neighbor.y].height;
                                                        const neighborElevationOffset = (neighborHeight - 0.65) * 240;
                                                        if (Math.abs(elevationOffset - neighborElevationOffset) > 5) {
                                                            ctx.lineTo(iso.x, iso.y - 17 - neighborElevationOffset);
                                                        }
                                                    }
                                                    break;
                                                case 'bottom':
                                                    ctx.moveTo(iso.x, iso.y + 17 - elevationOffset);
                                                    ctx.lineTo(iso.x - 33, iso.y - elevationOffset);
                                                    // Only add vertical line if neighbor is active and has elevation difference
                                                    if (isNeighborActive) {
                                                        const neighborHeight = world.tiles[neighbor.x][neighbor.y].height;
                                                        const neighborElevationOffset = (neighborHeight - 0.65) * 240;
                                                        if (Math.abs(elevationOffset - neighborElevationOffset) > 5) {
                                                            ctx.lineTo(iso.x - 33, iso.y - neighborElevationOffset);
                                                        }
                                                    }
                                                    break;
                                                case 'top':
                                                    ctx.moveTo(iso.x, iso.y - 17 - elevationOffset);
                                                    ctx.lineTo(iso.x + 33, iso.y - elevationOffset);
                                                    // Only add vertical line if neighbor is active and has elevation difference
                                                    if (isNeighborActive) {
                                                        const neighborHeight = world.tiles[neighbor.x][neighbor.y].height;
                                                        const neighborElevationOffset = (neighborHeight - 0.65) * 240;
                                                        if (Math.abs(elevationOffset - neighborElevationOffset) > 5) {
                                                            ctx.lineTo(iso.x + 33, iso.y - neighborElevationOffset);
                                                        }
                                                    }
                                                    break;
                                            }
                                            ctx.stroke();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                ctx.restore();
            }
            
            // Render god rays ABOVE everything in the world
            // Check if this is Lux world OR if there's a blessed kingdom in this world
            let shouldRenderGodRays = false;
            let luxEffect = null;
            
            if (world.name === 'Lux' && world.effect) {
                shouldRenderGodRays = true;
                luxEffect = world.effect;
            } else {
                // Check if Lux world has blessing beams for this world
                const luxWorld = worlds.find(w => w.name === 'Lux');
                if (luxWorld && luxWorld.effect && luxWorld.effect.blessedKingdomWorldId === world.id) {
                    shouldRenderGodRays = true;
                    luxEffect = luxWorld.effect;
                }
            }
            
            if (shouldRenderGodRays && luxEffect) {
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(camera.x, camera.y);
                
                // Filter beams to only show ones for this world
                const originalBeams = luxEffect.beams;
                const originalSprites = luxEffect.lightSprites;
                if (world.name !== 'Lux') {
                    // Only show blessing beams for this specific world
                    luxEffect.beams = originalBeams.filter(beam => 
                        beam.isBlessing && beam.blessedWorldId === world.id
                    );
                    // Only show light sprites for this specific world
                    luxEffect.lightSprites = originalSprites.filter(sprite =>
                        sprite.worldId === world.id
                    );
                }
                
                renderLuxEffectFromAbove(ctx, luxEffect);
                
                // Restore original beams and sprites
                luxEffect.beams = originalBeams;
                luxEffect.lightSprites = originalSprites;
                
                ctx.restore();
            }
            
            // Render Aether pillar in front of everything
            if (world.name === 'Aether') {
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(camera.x, camera.y);
                
                const animTime = performance.now() * 0.0001;
                // Position at the center where nomads orbit (world effect center)
                const centerIso = worldToIsometric(world.effect.centerX, world.effect.centerY);
                
                // Huge checkerboard pillar - 60% thinner
                const pillarWidth = 80;  // 60% thinner (was 200)
                const pillarHeight = 480;  // 40% shorter (was 800)
                const pillarX = centerIso.x - pillarWidth / 2 - 150 + 32;  // No X change for top-left movement
                const pillarY = centerIso.y - pillarHeight + 100 - 100 + 16 - 64;  // Moved 2 tiles up-left (-64 pixels)
                const checkerSize = 40; // Low res checkerboard
                
                // Draw isometric shadow on ground - cast to camera's top right
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                // Shadow cast up and to the right (camera's top right direction)
                const shadowLength = pillarHeight * 0.3;
                const shadowX = shadowLength * 0.7; // Right component
                const shadowY = -shadowLength * 0.7; // Up component (negative for up)
                ctx.moveTo(pillarX, pillarY + pillarHeight);
                ctx.lineTo(pillarX + pillarWidth, pillarY + pillarHeight);
                ctx.lineTo(pillarX + pillarWidth + shadowX, pillarY + pillarHeight + shadowY);
                ctx.lineTo(pillarX + shadowX, pillarY + pillarHeight + shadowY);
                ctx.closePath();
                ctx.fill();
                
                // Set transparency for the pillar
                ctx.globalAlpha = 0.7;
                
                // Draw checkerboard pattern with transparency
                for (let row = 0; row < Math.ceil(pillarHeight / checkerSize); row++) {
                    for (let col = 0; col < Math.ceil(pillarWidth / checkerSize); col++) {
                        const isLight = (row + col) % 2 === 0;
                        const yPos = pillarY + row * checkerSize;
                        const xPos = pillarX + col * checkerSize;
                        
                        // Add slight animation to the colors
                        const colorShift = Math.sin(animTime * 2 + row * 0.1) * 20;
                        
                        if (isLight) {
                            const lightness = 240 + colorShift;
                            ctx.fillStyle = `rgba(${lightness}, ${lightness}, ${lightness}, 0.8)`;
                        } else {
                            const darkness = 60 + colorShift;
                            ctx.fillStyle = `rgba(${darkness}, ${darkness}, ${darkness}, 0.8)`;
                        }
                        
                        // Clip to pillar bounds
                        const width = Math.min(checkerSize, pillarX + pillarWidth - xPos);
                        const height = Math.min(checkerSize, pillarY + pillarHeight - yPos);
                        if (width > 0 && height > 0) {
                            ctx.fillRect(xPos, yPos, width, height);
                        }
                    }
                }
                
                // Reset alpha
                ctx.globalAlpha = 1;
                
                // Add ethereal glow around the pillar
                const glowGradient = ctx.createRadialGradient(
                    centerIso.x, centerIso.y - pillarHeight / 2, 0,
                    centerIso.x, centerIso.y - pillarHeight / 2, pillarWidth * 2
                );
                glowGradient.addColorStop(0, 'rgba(220, 240, 255, 0.2)');
                glowGradient.addColorStop(0.5, 'rgba(200, 220, 255, 0.1)');
                glowGradient.addColorStop(1, 'rgba(180, 200, 255, 0)');
                
                ctx.fillStyle = glowGradient;
                ctx.fillRect(pillarX - 50, pillarY - 50, pillarWidth + 100, pillarHeight + 100);
                
                // Add top cap to the pillar with transparency
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.moveTo(pillarX, pillarY);
                ctx.lineTo(pillarX + pillarWidth / 2, pillarY - 30);
                ctx.lineTo(pillarX + pillarWidth, pillarY);
                ctx.closePath();
                ctx.fill();
                
                // Add edge highlights for depth
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(pillarX, pillarY);
                ctx.lineTo(pillarX, pillarY + pillarHeight);
                ctx.stroke();
                
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.moveTo(pillarX + pillarWidth, pillarY);
                ctx.lineTo(pillarX + pillarWidth, pillarY + pillarHeight);
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        function renderBanner(ctx, x, y, kingdom, isBurned, world) {
            const banner = kingdom.bannerDesign;
            const bannerWidth = 8; // Half the tower width
            const bannerHeight = 25;
            
            // Check cache for pre-rendered banner
            const cacheKey = `${kingdom.id}_${isBurned}`;
            let cachedBanner = gradientCache.bannerDesigns.get(cacheKey);
            
            if (cachedBanner) {
                // Use cached banner
                ctx.drawImage(cachedBanner, x - bannerWidth/2, y);
                return;
            }
            
            // Static banner - no wind physics
            const segments = 4;
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const segmentY = y + (bannerHeight / segments) * i;
                
                points.push({
                    x: x,
                    y: segmentY
                });
            }
            
            // Draw banner shadow
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.moveTo(points[0].x + 2, points[0].y + 2);
            for (let i = 0; i <= segments; i++) {
                ctx.lineTo(points[i].x - bannerWidth/2 + 2, points[i].y + 2);
            }
            for (let i = segments; i >= 0; i--) {
                ctx.lineTo(points[i].x + bannerWidth/2 + 2, points[i].y + 2);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // Create banner shape path
            ctx.save();
            ctx.beginPath();
            
            // Top edge - straight horizontal line
            ctx.moveTo(x - bannerWidth/2, y);
            ctx.lineTo(x + bannerWidth/2, y);
            
            // Right edge - straight down
            ctx.lineTo(x + bannerWidth/2, y + bannerHeight);
            
            // Bottom edge with decorative cuts
            ctx.lineTo(x + bannerWidth/4, y + bannerHeight - 2);
            ctx.lineTo(x, y + bannerHeight + 2);
            ctx.lineTo(x - bannerWidth/4, y + bannerHeight - 2);
            ctx.lineTo(x - bannerWidth/2, y + bannerHeight);
            
            // Left edge - straight up
            ctx.lineTo(x - bannerWidth/2, y);
            
            ctx.closePath();
            
            // Store the path for filling
            const bannerPath = new Path2D();
            bannerPath.moveTo(x - bannerWidth/2, y);
            bannerPath.lineTo(x + bannerWidth/2, y);
            bannerPath.lineTo(x + bannerWidth/2, y + bannerHeight);
            bannerPath.lineTo(x + bannerWidth/4, y + bannerHeight - 2);
            bannerPath.lineTo(x, y + bannerHeight + 2);
            bannerPath.lineTo(x - bannerWidth/4, y + bannerHeight - 2);
            bannerPath.lineTo(x - bannerWidth/2, y + bannerHeight);
            bannerPath.closePath();
            
            ctx.clip();
            
            // Fill banner with primary color - no darkness applied
            ctx.fillStyle = isBurned ? '#1a1a1a' : banner.primaryColor;
            ctx.fill(bannerPath);
            
            // Add border if needed
            if (banner.hasBorder) {
                ctx.strokeStyle = banner.borderColor;
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
            
            
            // Draw symbol - no darkness applied
            if (banner.symbol !== 'none') {
                ctx.fillStyle = isBurned ? '#0a0a0a' : banner.symbolColor;
                ctx.strokeStyle = isBurned ? '#0a0a0a' : banner.symbolColor;
                ctx.lineWidth = 0.5;
                const symbolY = y + bannerHeight * 0.4;
                const symbolSize = 3;
                
                switch (banner.symbol) {
                    case 'crown':
                        ctx.beginPath();
                        ctx.moveTo(x - symbolSize, symbolY + symbolSize/2);
                        ctx.lineTo(x - symbolSize/2, symbolY - symbolSize/2);
                        ctx.lineTo(x, symbolY);
                        ctx.lineTo(x + symbolSize/2, symbolY - symbolSize/2);
                        ctx.lineTo(x + symbolSize, symbolY + symbolSize/2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    case 'sword':
                        ctx.beginPath();
                        ctx.moveTo(x, symbolY - symbolSize);
                        ctx.lineTo(x, symbolY + symbolSize);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x - symbolSize/2, symbolY - symbolSize/2);
                        ctx.lineTo(x + symbolSize/2, symbolY - symbolSize/2);
                        ctx.stroke();
                        break;
                        
                    case 'shield':
                        ctx.beginPath();
                        ctx.moveTo(x, symbolY - symbolSize);
                        ctx.lineTo(x - symbolSize/2, symbolY - symbolSize/2);
                        ctx.lineTo(x - symbolSize/2, symbolY + symbolSize/3);
                        ctx.lineTo(x, symbolY + symbolSize);
                        ctx.lineTo(x + symbolSize/2, symbolY + symbolSize/3);
                        ctx.lineTo(x + symbolSize/2, symbolY - symbolSize/2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    case 'star':
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 144 - 90) * Math.PI / 180;
                            const innerAngle = ((i * 144 + 36) - 90) * Math.PI / 180;
                            const outerX = x + Math.cos(angle) * symbolSize;
                            const outerY = symbolY + Math.sin(angle) * symbolSize;
                            const innerX = x + Math.cos(innerAngle) * symbolSize/2;
                            const innerY = symbolY + Math.sin(innerAngle) * symbolSize/2;
                            
                            if (i === 0) {
                                ctx.moveTo(outerX, outerY);
                            } else {
                                ctx.lineTo(outerX, outerY);
                            }
                            ctx.lineTo(innerX, innerY);
                        }
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    case 'dragon':
                    case 'lion':
                    case 'eagle':
                        // Simplified animal shapes
                        ctx.beginPath();
                        ctx.arc(x, symbolY, symbolSize * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'tree':
                        ctx.fillRect(x - 0.5, symbolY, 1, symbolSize);
                        ctx.beginPath();
                        ctx.moveTo(x - symbolSize, symbolY);
                        ctx.lineTo(x, symbolY - symbolSize);
                        ctx.lineTo(x + symbolSize, symbolY);
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    case 'sun':
                        ctx.beginPath();
                        ctx.arc(x, symbolY, symbolSize/2, 0, Math.PI * 2);
                        ctx.fill();
                        for (let i = 0; i < 8; i++) {
                            const angle = i * Math.PI / 4;
                            ctx.beginPath();
                            ctx.moveTo(x + Math.cos(angle) * symbolSize/2, symbolY + Math.sin(angle) * symbolSize/2);
                            ctx.lineTo(x + Math.cos(angle) * symbolSize, symbolY + Math.sin(angle) * symbolSize);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'moon':
                        ctx.beginPath();
                        ctx.arc(x, symbolY, symbolSize/2, 0.5, Math.PI * 2 - 0.5);
                        ctx.fill();
                        break;
                        
                    case 'crossed_swords':
                        ctx.strokeStyle = banner.symbolColor;
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(x - symbolSize, symbolY - symbolSize);
                        ctx.lineTo(x + symbolSize, symbolY + symbolSize);
                        ctx.moveTo(x + symbolSize, symbolY - symbolSize);
                        ctx.lineTo(x - symbolSize, symbolY + symbolSize);
                        ctx.stroke();
                        // Add guards
                        ctx.beginPath();
                        ctx.moveTo(x - symbolSize/2, symbolY - symbolSize/2);
                        ctx.lineTo(x - symbolSize/3, symbolY - symbolSize/3);
                        ctx.moveTo(x + symbolSize/2, symbolY - symbolSize/2);
                        ctx.lineTo(x + symbolSize/3, symbolY - symbolSize/3);
                        ctx.stroke();
                        break;
                        
                    case 'hammer':
                        ctx.fillStyle = banner.symbolColor;
                        ctx.fillRect(x - 0.3, symbolY - symbolSize, 0.6, symbolSize * 1.5);
                        ctx.fillRect(x - symbolSize/2, symbolY - symbolSize, symbolSize, symbolSize/2);
                        break;
                        
                    case 'anchor':
                        ctx.strokeStyle = banner.symbolColor;
                        ctx.fillStyle = banner.symbolColor;
                        ctx.lineWidth = 0.5;
                        // Vertical shaft
                        ctx.beginPath();
                        ctx.moveTo(x, symbolY - symbolSize);
                        ctx.lineTo(x, symbolY + symbolSize/2);
                        ctx.stroke();
                        // Crossbar
                        ctx.beginPath();
                        ctx.moveTo(x - symbolSize/2, symbolY - symbolSize/2);
                        ctx.lineTo(x + symbolSize/2, symbolY - symbolSize/2);
                        ctx.stroke();
                        // Arc
                        ctx.beginPath();
                        ctx.arc(x, symbolY + symbolSize/4, symbolSize/2, 0, Math.PI);
                        ctx.stroke();
                        // Flukes
                        ctx.beginPath();
                        ctx.moveTo(x - symbolSize/2, symbolY + symbolSize/4);
                        ctx.lineTo(x - symbolSize/3, symbolY + symbolSize/2);
                        ctx.moveTo(x + symbolSize/2, symbolY + symbolSize/4);
                        ctx.lineTo(x + symbolSize/3, symbolY + symbolSize/2);
                        ctx.stroke();
                        break;
                        
                    case 'key':
                        ctx.fillStyle = banner.symbolColor;
                        ctx.strokeStyle = banner.symbolColor;
                        ctx.lineWidth = 0.5;
                        // Handle
                        ctx.beginPath();
                        ctx.arc(x, symbolY - symbolSize/2, symbolSize/3, 0, Math.PI * 2);
                        ctx.stroke();
                        // Shaft
                        ctx.fillRect(x - 0.3, symbolY - symbolSize/2, 0.6, symbolSize);
                        // Teeth
                        ctx.fillRect(x - 0.3, symbolY + symbolSize/3, symbolSize/3, 0.3);
                        ctx.fillRect(x - 0.3, symbolY + symbolSize/2, symbolSize/4, 0.3);
                        break;
                        
                    case 'rose':
                        ctx.fillStyle = banner.symbolColor;
                        // Center
                        ctx.beginPath();
                        ctx.arc(x, symbolY, symbolSize/4, 0, Math.PI * 2);
                        ctx.fill();
                        // Petals
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 72 - 90) * Math.PI / 180;
                            ctx.beginPath();
                            ctx.arc(x + Math.cos(angle) * symbolSize/2, 
                                  symbolY + Math.sin(angle) * symbolSize/2, 
                                  symbolSize/3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 'fleur_de_lis':
                        ctx.fillStyle = banner.symbolColor;
                        // Center petal
                        ctx.beginPath();
                        ctx.moveTo(x, symbolY - symbolSize);
                        ctx.quadraticCurveTo(x - symbolSize/3, symbolY - symbolSize/2, x, symbolY);
                        ctx.quadraticCurveTo(x + symbolSize/3, symbolY - symbolSize/2, x, symbolY - symbolSize);
                        ctx.fill();
                        // Side petals
                        ctx.beginPath();
                        ctx.moveTo(x - symbolSize/2, symbolY);
                        ctx.quadraticCurveTo(x - symbolSize, symbolY - symbolSize/3, x - symbolSize/2, symbolY - symbolSize/2);
                        ctx.quadraticCurveTo(x - symbolSize/4, symbolY - symbolSize/3, x, symbolY);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(x + symbolSize/2, symbolY);
                        ctx.quadraticCurveTo(x + symbolSize, symbolY - symbolSize/3, x + symbolSize/2, symbolY - symbolSize/2);
                        ctx.quadraticCurveTo(x + symbolSize/4, symbolY - symbolSize/3, x, symbolY);
                        ctx.fill();
                        // Base
                        ctx.fillRect(x - 0.3, symbolY, 0.6, symbolSize/2);
                        break;
                        
                    case 'heart':
                        ctx.fillStyle = banner.symbolColor;
                        ctx.beginPath();
                        ctx.moveTo(x, symbolY + symbolSize/2);
                        ctx.bezierCurveTo(x - symbolSize/2, symbolY, x - symbolSize, symbolY - symbolSize/2, x, symbolY);
                        ctx.bezierCurveTo(x + symbolSize, symbolY - symbolSize/2, x + symbolSize/2, symbolY, x, symbolY + symbolSize/2);
                        ctx.fill();
                        break;
                        
                    case 'diamond':
                        ctx.fillStyle = banner.symbolColor;
                        ctx.beginPath();
                        ctx.moveTo(x, symbolY - symbolSize);
                        ctx.lineTo(x + symbolSize/2, symbolY);
                        ctx.lineTo(x, symbolY + symbolSize);
                        ctx.lineTo(x - symbolSize/2, symbolY);
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    case 'castle':
                        ctx.fillStyle = banner.symbolColor;
                        // Main body
                        ctx.fillRect(x - symbolSize/2, symbolY - symbolSize/3, symbolSize, symbolSize);
                        // Towers
                        ctx.fillRect(x - symbolSize/2, symbolY - symbolSize/2, symbolSize/3, symbolSize/3);
                        ctx.fillRect(x + symbolSize/6, symbolY - symbolSize/2, symbolSize/3, symbolSize/3);
                        // Crenellations
                        ctx.fillRect(x - symbolSize/2, symbolY - symbolSize/2 - 0.3, symbolSize/6, 0.3);
                        ctx.fillRect(x - symbolSize/6, symbolY - symbolSize/2 - 0.3, symbolSize/6, 0.3);
                        ctx.fillRect(x + symbolSize/6, symbolY - symbolSize/2 - 0.3, symbolSize/6, 0.3);
                        ctx.fillRect(x + symbolSize/3, symbolY - symbolSize/2 - 0.3, symbolSize/6, 0.3);
                        // Gate
                        ctx.strokeStyle = banner.symbolColor;
                        ctx.lineWidth = 0.3;
                        ctx.strokeRect(x - symbolSize/6, symbolY + symbolSize/3, symbolSize/3, symbolSize/3);
                        break;
                        
                    case 'star_of_david':
                        ctx.strokeStyle = banner.symbolColor;
                        ctx.lineWidth = 0.8;
                        // Draw two triangles to form Star of David
                        ctx.beginPath();
                        // Upward triangle
                        ctx.moveTo(x, symbolY - symbolSize);
                        ctx.lineTo(x - symbolSize * 0.866, symbolY + symbolSize * 0.5);
                        ctx.lineTo(x + symbolSize * 0.866, symbolY + symbolSize * 0.5);
                        ctx.closePath();
                        ctx.stroke();
                        
                        // Downward triangle
                        ctx.beginPath();
                        ctx.moveTo(x, symbolY + symbolSize);
                        ctx.lineTo(x - symbolSize * 0.866, symbolY - symbolSize * 0.5);
                        ctx.lineTo(x + symbolSize * 0.866, symbolY - symbolSize * 0.5);
                        ctx.closePath();
                        ctx.stroke();
                        break;
                }
            }
            
            // No damage effect for burned banners
            
            ctx.restore();
        }
        
        function renderCapital(ctx, x, y, kingdom, isOriginalCapital, isBurned, capitalPos, world) {
            // Check if kingdom is blessed
            const isBlessed = game.blessedKingdoms[kingdom.id] && game.blessedKingdoms[kingdom.id] > game.currentTick;
            
            // Draw shadow first
            ctx.save();
            // Make shadow darker during dark phase
            const shadowOpacity = world && world.name === 'Terra' && game.terraDarkness.transitionProgress > 0 ? 
                0.2 + (game.terraDarkness.transitionProgress * 0.3) : 0.2;
            ctx.fillStyle = `rgba(0, 0, 0, ${shadowOpacity})`;
            ctx.beginPath();
            ctx.ellipse(x + 14, y - 16, 15, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Draw blessing aura if blessed (even if burned)
            if (isBlessed) {
                ctx.save();
                const animTime = performance.now() * 0.0001;
                const glowRadius = 40 + Math.sin(animTime * 10) * 5;
                const gradient = ctx.createRadialGradient(x, y - 20, 0, x, y - 20, glowRadius);
                gradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.1)');
                gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y - 20, glowRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // Calculate height extension for tower body based on controlled capitals
            const heightExtension = isOriginalCapital ? (kingdom.controlledCapitals.length - 1) * 8 : 0;
            const baseHeight = 40;
            const towerHeight = baseHeight + heightExtension;
            
            // Debug log for tower height issues
            if (isOriginalCapital && kingdom.controlledCapitals.length > 1 && heightExtension === 0) {
                console.error(`Tower height bug for ${kingdom.name}: controlledCapitals.length=${kingdom.controlledCapitals.length}, heightExtension=${heightExtension}`);
            }

            // Get tile color and make it darker for capital
            let wallColor, roofColor, baseWallColor, baseTrimColor;
            
            if (isBurned) {
                // If burned, use darker, damaged colors
                wallColor = '#3a3a3a';
                roofColor = '#2a2a2a';
                baseWallColor = '#333333';
                baseTrimColor = '#222222';
            } else {
                // Get the tile at capital position
                const tile = world.tiles[capitalPos.x][capitalPos.y];
                
                // Special colors for Aether world
                if (world.name === 'Aether') {
                    // Use grayscale colors for Aether buildings
                    wallColor = 'rgb(153, 153, 153)'; // 60% gray
                    roofColor = 'rgb(51, 51, 51)'; // 20% gray
                    baseWallColor = 'rgb(128, 128, 128)'; // 50% gray
                    baseTrimColor = 'rgb(51, 51, 51)'; // 20% gray
                } else {
                    // Get world RGB values
                    let worldRGB = gradientCache.worldRGB.get(world.color);
                    if (!worldRGB) {
                        const hex = world.color.substring(1);
                        worldRGB = {
                            r: parseInt(hex.substring(0, 2), 16),
                            g: parseInt(hex.substring(2, 4), 16),
                            b: parseInt(hex.substring(4, 6), 16)
                        };
                        gradientCache.worldRGB.set(world.color, worldRGB);
                    }
                    
                    // Calculate tile brightness based on elevation
                    const brightness = 0.6 + tile.elevation * 0.4;
                    
                    // Capitals stay lit - no darkness applied
                    
                    // Calculate darker versions for capital (70% brightness for walls, 50% for roofs)
                    const r = Math.floor(worldRGB.r * brightness * 0.7);
                    const g = Math.floor(worldRGB.g * brightness * 0.7);
                    const b = Math.floor(worldRGB.b * brightness * 0.7);
                    
                    const darkR = Math.floor(worldRGB.r * brightness * 0.5);
                    const darkG = Math.floor(worldRGB.g * brightness * 0.5);
                    const darkB = Math.floor(worldRGB.b * brightness * 0.5);
                    
                    wallColor = `rgb(${r}, ${g}, ${b})`;
                    roofColor = `rgb(${darkR}, ${darkG}, ${darkB})`;
                    baseWallColor = `rgb(${Math.floor(r * 0.9)}, ${Math.floor(g * 0.9)}, ${Math.floor(b * 0.9)})`;
                    baseTrimColor = `rgb(${darkR}, ${darkG}, ${darkB})`;
                }
            }

            // Tower body (extended upward)
            ctx.fillStyle = wallColor; 
            ctx.fillRect(x - 8, y - towerHeight, 16, towerHeight - 17); // Adjusted to connect with taller base walls
            
            // No smoke effect for burned capitals
            
            // Tower roof (at the top of the extended tower)
            ctx.fillStyle = roofColor; 
            ctx.beginPath(); 
            ctx.moveTo(x - 10, y - towerHeight); 
            ctx.lineTo(x, y - towerHeight - 10); 
            ctx.lineTo(x + 10, y - towerHeight); 
            ctx.closePath(); 
            ctx.fill();
            
            // Always render banner (black if burned)
            renderBanner(ctx, x, y - towerHeight + 5, kingdom, isBurned, world);
            
            
            // Base walls with curved bottom (10% taller)
            ctx.fillStyle = baseWallColor;
            ctx.beginPath();
            ctx.moveTo(x - 20, y - 17); // Start at top left (10% taller than -15)
            ctx.lineTo(x - 20, y); // Go down left side
            ctx.quadraticCurveTo(x, y + 5, x + 20, y); // Curved bottom edge bulging outward
            ctx.lineTo(x + 20, y - 17); // Go up right side
            ctx.closePath();
            ctx.fill();
            
            // Base trim
            ctx.fillStyle = baseTrimColor; 
            ctx.fillRect(x - 20, y - 17, 40, 3); // Adjusted for taller walls
            
            // Battlements (some missing if burned)
            for (var i = 0; i < 4; i++) { 
                // Use stable random based on position and battlement index
                const battlementExists = !isBurned || (Math.floor(x * 100 + y * 100 + i * 1000) % 10) > 4;
                if (battlementExists) {
                    ctx.fillRect(x - 22 + i * 12, y - 20, 8, 3); // Centered: 4 blocks × 8 wide + 3 gaps × 4 wide = 44 total, so start at -22
                }
            }
            
            // Crown for world conqueror (at the top) - tarnished if burned
            if (kingdom.worldConqueror) {
                // Use stable random based on position
                const crownExists = !isBurned || (Math.floor(x * 1000 + y * 500) % 10) > 5;
                if (crownExists) {
                    ctx.fillStyle = isBurned ? '#B8860B' : '#FFD700'; 
                    ctx.globalAlpha = isBurned ? 0.6 : 1;
                    ctx.beginPath(); 
                    ctx.moveTo(x - 8, y - towerHeight - 30); 
                    ctx.lineTo(x - 6, y - towerHeight - 35); 
                    ctx.lineTo(x - 3, y - towerHeight - 32); 
                    ctx.lineTo(x, y - towerHeight - 37); 
                    ctx.lineTo(x + 3, y - towerHeight - 32); 
                    ctx.lineTo(x + 6, y - towerHeight - 35); 
                    ctx.lineTo(x + 8, y - towerHeight - 30); 
                    ctx.closePath(); 
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }
            
            // Add torches for dark Terra capitals (bigger than village torches)
            if (world.name === 'Terra' && game.terraDarkness.transitionProgress > 0.5 && !isBurned) {
                // Add torch on left side of tower
                const torchX = x - 16;
                const torchY = y - 18;
                
                // Torch stick (thicker and taller)
                ctx.strokeStyle = '#4A2810';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(torchX, torchY);
                ctx.lineTo(torchX, torchY - 16);
                ctx.stroke();
                
                // Flame (bigger) - no sway
                // Outer flame (orange)
                ctx.fillStyle = '#FF6B00';
                ctx.beginPath();
                ctx.ellipse(torchX, torchY - 20, 6, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner flame (yellow)
                ctx.fillStyle = '#FFEB3B';
                ctx.beginPath();
                ctx.ellipse(torchX, torchY - 19, 3, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Glow effect (wider)
                const glowGradient = ctx.createRadialGradient(torchX, torchY - 19, 0, torchX, torchY - 19, 25);
                glowGradient.addColorStop(0, 'rgba(255, 200, 0, 0.4)');
                glowGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                ctx.fillStyle = glowGradient;
                ctx.fillRect(torchX - 25, torchY - 44, 50, 50);
            }
        }
        
        function renderVillage(ctx, x, y, kingdom, isBurned, villagePos, world) {
            var positions = [ {x: x - 10, y: y - 2}, {x: x + 10, y: y - 4}, {x: x, y: y + 3} ];
            
            // Draw shadows for all houses first
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            for (var i = 0; i < positions.length; i++) {
                var pos = positions[i];
                ctx.beginPath();
                ctx.ellipse(pos.x + 4, pos.y - 4, 8, 4, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            // Get tile color and make it darker for village
            let wallColor, roofColor, doorColor;
            
            if (isBurned) {
                // If burned, use darker, damaged colors
                wallColor = '#4a3a2a';
                roofColor = kingdom.color;
                doorColor = '#222222';
            } else {
                // Get the tile at village position
                const tile = world.tiles[villagePos.x][villagePos.y];
                
                // Special colors for Aether world
                if (world.name === 'Aether') {
                    // Use grayscale colors for Aether buildings
                    wallColor = 'rgb(179, 179, 179)'; // 70% gray
                    roofColor = kingdom.color; // Keep kingdom color for variety
                    doorColor = 'rgb(77, 77, 77)'; // 30% gray
                } else {
                    // Get world RGB values
                    let worldRGB = gradientCache.worldRGB.get(world.color);
                    if (!worldRGB) {
                        const hex = world.color.substring(1);
                        worldRGB = {
                            r: parseInt(hex.substring(0, 2), 16),
                            g: parseInt(hex.substring(2, 4), 16),
                            b: parseInt(hex.substring(4, 6), 16)
                        };
                        gradientCache.worldRGB.set(world.color, worldRGB);
                    }
                    
                    // Calculate tile brightness based on elevation
                    const brightness = 0.6 + tile.elevation * 0.4;
                    
                    // Villages stay lit - no darkness applied
                    
                    // Calculate darker versions for village (80% brightness for walls)
                    const r = Math.floor(worldRGB.r * brightness * 0.8);
                    const g = Math.floor(worldRGB.g * brightness * 0.8);
                    const b = Math.floor(worldRGB.b * brightness * 0.8);
                    
                    wallColor = `rgb(${r}, ${g}, ${b})`;
                    
                    // Roof stays normal color - no darkness
                    roofColor = kingdom.color;
                    
                    // Make door darker (50% brightness) - no darkness
                    const doorR = Math.floor(worldRGB.r * brightness * 0.5);
                    const doorG = Math.floor(worldRGB.g * brightness * 0.5);
                    const doorB = Math.floor(worldRGB.b * brightness * 0.5);
                    doorColor = `rgb(${doorR}, ${doorG}, ${doorB})`;
                }
            }
            
            // If burned, add smoke effect
            if (isBurned) {
                ctx.save();
                ctx.globalAlpha = 0.5;
                for (let i = 0; i < 2; i++) {
                    // Use performance.now() for smooth animation instead of game ticks
                    const animTime = performance.now() * 0.00008;
                    const smokeY = y - 15 - i * 8 - (animTime * 15) % 15;
                    const smokeX = x + Math.sin(animTime * 4 + i) * 4;
                    const smokeSize = 6 + i * 2;
                    
                    ctx.fillStyle = '#666666';
                    ctx.beginPath();
                    ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
            
            for (var i = 0; i < positions.length; i++) {
                var pos = positions[i];
                
                // House walls - using tile color
                ctx.fillStyle = wallColor;
                ctx.fillRect(pos.x - 6, pos.y - 6, 12, 10);
                
                // Roof - damaged and darker if burned
                ctx.fillStyle = roofColor; 
                ctx.globalAlpha = isBurned ? 0.3 : 0.7; 
                ctx.beginPath(); 
                ctx.moveTo(pos.x - 8, pos.y - 6); 
                ctx.lineTo(pos.x, pos.y - (isBurned ? 10 : 12)); 
                ctx.lineTo(pos.x + 8, pos.y - 6); 
                ctx.closePath(); 
                ctx.fill(); 
                ctx.globalAlpha = 1;
                
                // Door - using tile-based color
                ctx.fillStyle = doorColor;
                ctx.fillRect(pos.x - 2, pos.y - 2, 4, 6);
                
                // Add scorch marks if burned
                if (isBurned) {
                    ctx.fillStyle = 'rgba(20, 20, 20, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(pos.x, pos.y + 4, 8, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Add torches for dark Terra
            if (world.name === 'Terra' && game.terraDarkness.transitionProgress > 0.5 && !isBurned) {
                // Add torch to middle house
                const torchX = x;
                const torchY = y - 5;
                
                // Torch stick
                ctx.strokeStyle = '#4A2810';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(torchX, torchY);
                ctx.lineTo(torchX, torchY - 10);
                ctx.stroke();
                
                // Flame
                // Outer flame (orange) - no sway
                ctx.fillStyle = '#FF6B00';
                ctx.beginPath();
                ctx.ellipse(torchX, torchY - 13, 3, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner flame (yellow)
                ctx.fillStyle = '#FFEB3B';
                ctx.beginPath();
                ctx.ellipse(torchX, torchY - 12, 1.5, 2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Glow effect
                const glowGradient = ctx.createRadialGradient(torchX, torchY - 12, 0, torchX, torchY - 12, 15);
                glowGradient.addColorStop(0, 'rgba(255, 200, 0, 0.3)');
                glowGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                ctx.fillStyle = glowGradient;
                ctx.fillRect(torchX - 15, torchY - 27, 30, 30);
            }
        }

        function renderFields(ctx, x, y, worldColor, world) {
            ctx.save();
            ctx.globalAlpha = 0.8;
            
            let r = parseInt(worldColor.substr(1, 2), 16) * 0.65;
            let g = parseInt(worldColor.substr(3, 2), 16) * 0.65;
            let b = parseInt(worldColor.substr(5, 2), 16) * 0.65;
            
            // Apply Terra darkness if active
            if (world && world.name === 'Terra' && game.terraDarkness.transitionProgress > 0) {
                const darkening = 1 - (game.terraDarkness.transitionProgress * 0.7);
                r *= darkening;
                g *= darkening;
                b *= darkening;
            }
            
            ctx.fillStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;

            ctx.beginPath(); ctx.roundRect(x - 25, y + 4, 15, 8, 2); ctx.fill();
            ctx.beginPath(); ctx.roundRect(x + 12, y + 2, 15, 8, 2); ctx.fill();
            ctx.beginPath(); ctx.roundRect(x - 8, y + 9, 15, 8, 2); ctx.fill();

            ctx.restore();
        }
        
        function renderOldTemple(ctx, x, y, level) {
            // Validate inputs to prevent non-finite values
            if (!isFinite(x) || !isFinite(y)) {
                console.warn('renderOldTemple called with non-finite coordinates:', x, y);
                return;
            }
            
            level = level || 1;
            var size = 10 + Math.abs(level) * 3;
            var isFalse = level < 0;
            
            // Draw shadow first
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(x + 6, y - size/2 - 3, size + 5, (size + 5)/2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            var gradient = ctx.createLinearGradient(x - size, y - size, x + size, y + size/2);
            if (isFalse) { gradient.addColorStop(0, '#4A4A4A'); gradient.addColorStop(1, '#1A1A1A'); } else { gradient.addColorStop(0, '#F0E68C'); gradient.addColorStop(1, '#FFA500'); }
            ctx.fillStyle = gradient; ctx.fillRect(x - size, y - size/2, size * 2, size);
            ctx.fillStyle = isFalse ? '#666666' : '#FAFAD2';
            for (var i = 0; i < 3; i++) { var colX = x - size + 5 + i * (size - 2.5); ctx.fillRect(colX, y - size/2, 3, size); }
            ctx.fillStyle = isFalse ? '#800000' : '#DAA520'; ctx.beginPath(); ctx.moveTo(x - size - 3, y - size/2); ctx.lineTo(x, y - size - 5); ctx.lineTo(x + size + 3, y - size/2); ctx.closePath(); ctx.fill();
            ctx.strokeStyle = isFalse ? '#FF0000' : '#FFD700'; ctx.lineWidth = 2; 
            const animTime = performance.now() * 0.00005;
            ctx.globalAlpha = 0.3 + Math.sin(animTime * 5) * 0.2; 
            ctx.beginPath(); ctx.arc(x, y, size + 5, 0, Math.PI * 2); ctx.stroke();
            if (isFalse) { ctx.fillStyle = 'rgba(128, 0, 0, 0.3)'; ctx.beginPath(); ctx.arc(x, y, size + 10, 0, Math.PI * 2); ctx.fill(); }
            ctx.globalAlpha = 1;
        }
        
        function renderArmy(ctx, x, y, army, world) {
            // Get the current kingdom color dynamically
            let kingdomColor = '#888888'; // Default gray if kingdom not found
            
            // Find the kingdom across all worlds
            for (let w = 0; w < worlds.length; w++) {
                const kingdom = worlds[w].kingdoms.find(k => k.id === army.kingdom.id && k.alive);
                if (kingdom) {
                    kingdomColor = kingdom.color;
                    break;
                }
            }
            
            // Keep normal colors during Terra darkness - no darkening
            
            // Check if this army is being followed
            var isFollowed = camera.followingEntity && 
                           camera.followingEntity.type === 'army' && 
                           camera.followingEntity.entity === army;
            
            // Draw follow indicator if being followed
            if (isFollowed) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y - 10, 25, 0, Math.PI * 2);
                ctx.stroke();
                
                // Pulsing inner circle
                var pulseSize = 20 + Math.sin(Date.now() * 0.003) * 5;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y - 10, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            
            // Draw shadow for the army formation
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.beginPath();
            ctx.ellipse(x + 4, y - 5, 15, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Special rendering for messenger armies
            if (army.task === 'messenger') {
                // Draw the king/baron in the center
                const isKing = army.isKing;
                
                // Determine if we need to flip based on pointing direction
                let shouldFlip = false;
                if (army.pointingTimer > 0 && !army.isReturning) {
                    // For requests with a different target kingdom
                    if (army.request && army.request.target && army.request.target.capitalX !== undefined) {
                        const targetPos = worldToIsometric(army.request.target.capitalX, army.request.target.capitalY);
                        const currentPos = worldToIsometric(army.currentX, army.currentY);
                        shouldFlip = targetPos.x < currentPos.x; // Flip when pointing LEFT
                    } else {
                        // For self-targeting requests, use the army's destination
                        const targetPos = worldToIsometric(army.targetX, army.targetY);
                        const currentPos = worldToIsometric(army.currentX, army.currentY);
                        shouldFlip = targetPos.x < currentPos.x; // Flip when pointing LEFT
                    }
                }
                
                ctx.save();
                if (shouldFlip) {
                    ctx.scale(-1, 1);
                    ctx.translate(-2 * x, 0);
                }
                
                // King/Baron body (larger than normal soldiers)
                ctx.fillStyle = kingdomColor;
                ctx.fillRect(x - 4, y - 12, 8, 10);
                
                // Head
                ctx.fillStyle = '#FFDAB9';
                ctx.beginPath();
                ctx.arc(x, y - 13, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Crown for king, simple hat for baron
                if (isKing) {
                    // Gold crown
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(x - 4, y - 14);
                    ctx.lineTo(x - 4, y - 17);
                    ctx.lineTo(x - 2, y - 15);
                    ctx.lineTo(x, y - 18);
                    ctx.lineTo(x + 2, y - 15);
                    ctx.lineTo(x + 4, y - 17);
                    ctx.lineTo(x + 4, y - 14);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Crown jewel
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(x, y - 15, 1, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Baron's hat (dark)
                    ctx.fillStyle = '#2C3E50';
                    ctx.beginPath();
                    ctx.moveTo(x - 3, y - 14);
                    ctx.lineTo(x, y - 18);
                    ctx.lineTo(x + 3, y - 14);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Draw guards around the king/baron (render first so arm appears in front)
                const guardPositions = [
                    {x: x - 8, y: y - 2},  // Left guard
                    {x: x + 8, y: y - 2}   // Right guard
                ];
                
                guardPositions.forEach(pos => {
                    // Guard body
                    ctx.fillStyle = kingdomColor;
                    ctx.fillRect(pos.x - 2.5, pos.y - 7.5, 5, 7.5);
                    
                    // Guard head
                    ctx.fillStyle = '#FFDAB9';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y - 8, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Guard helmet
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.moveTo(pos.x - 3, pos.y - 8);
                    ctx.lineTo(pos.x, pos.y - 13);
                    ctx.lineTo(pos.x + 3, pos.y - 8);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Guard spear
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(pos.x + 2, pos.y - 14);
                    ctx.lineTo(pos.x + 2, pos.y);
                    ctx.stroke();
                    
                    // Spear tip
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.moveTo(pos.x + 2, pos.y - 16);
                    ctx.lineTo(pos.x + 2.5, pos.y - 14);
                    ctx.lineTo(pos.x + 2, pos.y - 13.5);
                    ctx.lineTo(pos.x + 1.5, pos.y - 14);
                    ctx.closePath();
                    ctx.fill();
                });
                
                // Pointing arm if at destination (render after guards so it appears in front)
                if (army.pointingTimer > 0 && !army.isReturning) {
                    let pointDirection = 0;
                    
                    if (army.request && army.request.target && army.request.target !== army.kingdom) {
                        // For enemy targeting, point towards the target kingdom's capital
                        const targetKingdom = army.request.target;
                        if (targetKingdom.capitalX !== undefined && targetKingdom.capitalY !== undefined) {
                            const targetCapital = { x: targetKingdom.capitalX, y: targetKingdom.capitalY };
                            const currentWorldPos = { x: army.currentX, y: army.currentY };
                            
                            // Convert both positions to screen space
                            const currentScreen = worldToIsometric(currentWorldPos.x, currentWorldPos.y);
                            const targetScreen = worldToIsometric(targetCapital.x, targetCapital.y);
                            
                            // Calculate screen direction for proper isometric pointing
                            const screenDx = targetScreen.x - currentScreen.x;
                            const screenDy = targetScreen.y - currentScreen.y;
                            pointDirection = Math.atan2(screenDy, screenDx);
                        } else {
                            // Fallback if target has no capital
                            pointDirection = 0;
                        }
                    } else {
                        // For self-targeting (bless), point upward towards own capital
                        const ownCapital = { x: army.kingdom.capitalX, y: army.kingdom.capitalY };
                        const currentWorldPos = { x: army.currentX, y: army.currentY };
                        
                        // Convert both positions to screen space
                        const currentScreen = worldToIsometric(currentWorldPos.x, currentWorldPos.y);
                        const capitalScreen = worldToIsometric(ownCapital.x, ownCapital.y);
                        
                        // Calculate screen direction
                        const screenDx = capitalScreen.x - currentScreen.x;
                        const screenDy = capitalScreen.y - currentScreen.y;
                        pointDirection = Math.atan2(screenDy, screenDx);
                    }
                    
                    // Draw simple pointing arm
                    const baseArmLength = 6;
                    const armStartX = x + 3;
                    const armStartY = y - 8;
                    
                    // If sprite is flipped, reverse the horizontal component of the direction
                    let adjustedDirection = pointDirection;
                    if (shouldFlip) {
                        adjustedDirection = Math.PI - pointDirection;
                    }
                    
                    // Reduce arm length when pointing more vertically to look more natural
                    const verticalComponent = Math.abs(Math.sin(adjustedDirection));
                    const armLength = baseArmLength * (1 - verticalComponent * 0.3);
                    
                    // Calculate arm end position
                    const finalEndX = armStartX + Math.cos(adjustedDirection) * armLength;
                    const finalEndY = armStartY + Math.sin(adjustedDirection) * armLength;
                    
                    // Draw arm
                    ctx.strokeStyle = '#FFDAB9';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(armStartX, armStartY);
                    ctx.lineTo(finalEndX, finalEndY);
                    ctx.stroke();
                    
                    // Draw hand at end
                    ctx.fillStyle = '#FFDAB9';
                    ctx.beginPath();
                    ctx.arc(finalEndX, finalEndY, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore(); // Restore the flip transform
                
                return; // Skip normal army rendering
            }
            
            var rows = 2;
            var spacing = 6;
            // Render rows in reverse order so bottom row (closer to viewer) renders on top
            for (var row = rows - 1; row >= 0; row--) {
                var soldiersInRow = row === 0 ? 3 : 4;
                var startX = x - (soldiersInRow - 1) * spacing / 2;
                var rowY = y - row * 8;
                for (var i = 0; i < soldiersInRow; i++) {
                    var unitX = startX + i * spacing;
                    var unitY = rowY + (i % 2) * 2;
                    // Body in kingdom color (25% bigger)
                    ctx.fillStyle = kingdomColor; 
                    ctx.fillRect(unitX - 2.5, unitY - 7.5, 5, 7.5);
                    // Head in skin tone (mostly covered by helmet)
                    ctx.fillStyle = '#FFDAB9'; // Peach skin tone
                    ctx.beginPath(); 
                    ctx.arc(unitX, unitY - 8, 2.5, 0, Math.PI * 2); 
                    ctx.fill();
                    
                    // Tall pointy metal helmet
                    // Main helmet cone (bright metal)
                    ctx.fillStyle = '#C0C0C0'; 
                    ctx.beginPath();
                    ctx.moveTo(unitX - 3, unitY - 8);  // Left base
                    ctx.lineTo(unitX, unitY - 13);      // Top point
                    ctx.lineTo(unitX + 3, unitY - 8);   // Right base
                    ctx.closePath();
                    ctx.fill();
                    
                    // Darker metal stripe for depth (left side)
                    ctx.fillStyle = '#808080';
                    ctx.beginPath();
                    ctx.moveTo(unitX - 3, unitY - 8);  // Left base
                    ctx.lineTo(unitX, unitY - 13);      // Top point
                    ctx.lineTo(unitX - 1, unitY - 8);   // Slightly inward
                    ctx.closePath();
                    ctx.fill();
                    
                    // Helmet rim (darker line at base)
                    ctx.strokeStyle = '#606060';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(unitX - 3, unitY - 8);
                    ctx.lineTo(unitX + 3, unitY - 8);
                    ctx.stroke();
                    
                    // Weapon
                    ctx.strokeStyle = '#8B4513'; 
                    ctx.lineWidth = 1.5; 
                    ctx.beginPath(); 
                    ctx.moveTo(unitX + 2, unitY - 14); 
                    ctx.lineTo(unitX + 2, unitY); 
                    ctx.stroke();
                    // Weapon tip (above the shaft)
                    ctx.fillStyle = '#C0C0C0'; 
                    ctx.beginPath(); 
                    ctx.moveTo(unitX + 2, unitY - 16);      // Top point of spearhead
                    ctx.lineTo(unitX + 2.5, unitY - 14);    // Right edge at shaft top
                    ctx.lineTo(unitX + 2, unitY - 13.5);    // Bottom point (slightly below shaft top)
                    ctx.lineTo(unitX + 1.5, unitY - 14);    // Left edge at shaft top
                    ctx.closePath(); 
                    ctx.fill();
                }
            }
            
            // Add torch for dark Terra armies
            if (world && world.name === 'Terra' && game.terraDarkness.transitionProgress > 0.5) {
                // Torch position (held by one soldier in the front row)
                const torchHolderX = x - 3; // Left soldier in front row
                const torchHolderY = y - 5;
                
                // Torch stick (tall)
                ctx.strokeStyle = '#4A2810';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(torchHolderX - 3, torchHolderY - 5);
                ctx.lineTo(torchHolderX - 3, torchHolderY - 20);
                ctx.stroke();
                
                // Flame
                // Outer flame (orange) - no sway
                ctx.fillStyle = '#FF6B35';
                ctx.beginPath();
                ctx.moveTo(torchHolderX - 3, torchHolderY - 20);
                ctx.quadraticCurveTo(
                    torchHolderX - 5, torchHolderY - 24,
                    torchHolderX - 3, torchHolderY - 28
                );
                ctx.quadraticCurveTo(
                    torchHolderX - 1, torchHolderY - 24,
                    torchHolderX - 3, torchHolderY - 20
                );
                ctx.fill();
                
                // Inner flame (yellow)
                ctx.fillStyle = '#FFD93D';
                ctx.beginPath();
                ctx.moveTo(torchHolderX - 3, torchHolderY - 21);
                ctx.quadraticCurveTo(
                    torchHolderX - 4, torchHolderY - 23,
                    torchHolderX - 3, torchHolderY - 25
                );
                ctx.quadraticCurveTo(
                    torchHolderX - 2, torchHolderY - 23,
                    torchHolderX - 3, torchHolderY - 21
                );
                ctx.fill();
                
                // Glow effect
                ctx.save();
                const glowGradient = ctx.createRadialGradient(
                    torchHolderX - 3, torchHolderY - 24, 0,
                    torchHolderX - 3, torchHolderY - 24, 15
                );
                glowGradient.addColorStop(0, 'rgba(255, 150, 0, 0.3)');
                glowGradient.addColorStop(1, 'rgba(255, 150, 0, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(torchHolderX - 3, torchHolderY - 24, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // Draw banner if this army carries one
            if (army.hasBanner) {
                // Get kingdom's banner design
                let bannerDesign = null;
                for (let w = 0; w < worlds.length; w++) {
                    const kingdom = worlds[w].kingdoms.find(k => k.id === army.kingdom.id && k.alive);
                    if (kingdom && kingdom.bannerDesign) {
                        bannerDesign = kingdom.bannerDesign;
                        break;
                    }
                }
                
                if (bannerDesign) {
                    // Banner pole position
                    const poleX = x - 12;
                    const poleY = y - 8;
                    const poleHeight = 20;
                    
                    // Random angle for banner (stable based on army ID)
                    const angleRandom = ((army.id * 13337) % 100) / 100;
                    const bannerAngle = -0.2 + angleRandom * 0.4; // -0.2 to 0.2 radians
                    
                    ctx.save();
                    ctx.translate(poleX, poleY - poleHeight);
                    ctx.rotate(bannerAngle);
                    
                    // Banner pole
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(0, poleHeight);
                    ctx.lineTo(0, 0);
                    ctx.stroke();
                    
                    // Render army banner - larger size
                    const bannerWidth = 10;
                    const bannerHeight = 16;
                    
                    // Banner shadow - centered on pole
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                    ctx.fillRect(-bannerWidth/2 + 1, 1, bannerWidth, bannerHeight);
                    
                    // Create clipping path - downward pointing triangle centered on pole
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(-bannerWidth/2, 0);
                    ctx.lineTo(bannerWidth/2, 0);
                    ctx.lineTo(0, bannerHeight);
                    ctx.closePath();
                    ctx.clip();
                    
                    // Banner background - centered on pole
                    ctx.fillStyle = bannerDesign.primaryColor;
                    ctx.fillRect(-bannerWidth/2, 0, bannerWidth, bannerHeight);
                    
                    // Banner pattern (simplified for small size)
                    switch (bannerDesign.pattern) {
                        case 'vertical_stripes':
                            ctx.fillStyle = bannerDesign.secondaryColor;
                            ctx.fillRect(-bannerWidth/6, 0, bannerWidth/3, bannerHeight);
                            break;
                            
                        case 'horizontal_stripes':
                            ctx.fillStyle = bannerDesign.secondaryColor;
                            ctx.fillRect(-bannerWidth/2, bannerHeight/3, bannerWidth, bannerHeight/3);
                            break;
                            
                        case 'chevron':
                            ctx.fillStyle = bannerDesign.secondaryColor;
                            ctx.beginPath();
                            ctx.moveTo(-bannerWidth/2, 0);
                            ctx.lineTo(0, bannerHeight/3);
                            ctx.lineTo(bannerWidth/2, 0);
                            ctx.closePath();
                            ctx.fill();
                            break;
                            
                        case 'cross':
                            ctx.fillStyle = bannerDesign.secondaryColor;
                            ctx.fillRect(-bannerWidth/6, 0, bannerWidth/3, bannerHeight);
                            ctx.fillRect(-bannerWidth/2, bannerHeight/3, bannerWidth, bannerHeight/4);
                            break;
                            
                        case 'quarters':
                            ctx.fillStyle = bannerDesign.secondaryColor;
                            ctx.fillRect(0, 0, bannerWidth/2, bannerHeight/2);
                            ctx.fillRect(-bannerWidth/2, bannerHeight/2, bannerWidth/2, bannerHeight/2);
                            break;
                            
                        case 'diagonal':
                            ctx.fillStyle = bannerDesign.secondaryColor;
                            ctx.beginPath();
                            ctx.moveTo(-bannerWidth/2, 0);
                            ctx.lineTo(bannerWidth/2, bannerHeight);
                            ctx.lineTo(bannerWidth/2, 0);
                            ctx.closePath();
                            ctx.fill();
                            break;
                            
                        case 'star_of_david':
                            ctx.strokeStyle = bannerDesign.secondaryColor;
                            ctx.lineWidth = 0.5;
                            const centerX = bannerWidth/2;
                            const centerY = bannerHeight/2;
                            const size = 2;
                            // Simplified star
                            ctx.beginPath();
                            ctx.moveTo(centerX, centerY - size);
                            ctx.lineTo(centerX - size * 0.866, centerY + size * 0.5);
                            ctx.lineTo(centerX + size * 0.866, centerY + size * 0.5);
                            ctx.closePath();
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(centerX, centerY + size);
                            ctx.lineTo(centerX - size * 0.866, centerY - size * 0.5);
                            ctx.lineTo(centerX + size * 0.866, centerY - size * 0.5);
                            ctx.closePath();
                            ctx.stroke();
                            break;
                            
                        case 'checkerboard':
                            const checkSize = bannerWidth / 4;
                            for (let cy = 0; cy < bannerHeight; cy += checkSize) {
                                for (let cx = 0; cx < bannerWidth; cx += checkSize) {
                                    const isEven = (Math.floor(cx / checkSize) + Math.floor(cy / checkSize)) % 2 === 0;
                                    ctx.fillStyle = isEven ? bannerDesign.primaryColor : bannerDesign.secondaryColor;
                                    ctx.fillRect(cx, cy, checkSize, checkSize);
                                }
                            }
                            break;
                            
                        case 'quadrants_diagonal':
                            // Diagonal quadrants
                            ctx.fillStyle = bannerDesign.secondaryColor;
                            ctx.fillRect(bannerWidth/2, 0, bannerWidth/2, bannerHeight/2);
                            ctx.fillRect(0, bannerHeight/2, bannerWidth/2, bannerHeight/2);
                            break;
                            
                        case 'quadrants_alternating':
                            // Four colors
                            ctx.fillStyle = bannerDesign.secondaryColor;
                            ctx.fillRect(bannerWidth/2, 0, bannerWidth/2, bannerHeight/2);
                            ctx.fillStyle = bannerDesign.tertiaryColor || bannerDesign.primaryColor;
                            ctx.fillRect(0, bannerHeight/2, bannerWidth/2, bannerHeight/2);
                            ctx.fillStyle = bannerDesign.quaternaryColor || bannerDesign.secondaryColor;
                            ctx.fillRect(bannerWidth/2, bannerHeight/2, bannerWidth/2, bannerHeight/2);
                            break;
                            
                        default:
                            // For other complex patterns, just show primary/secondary split
                            ctx.fillStyle = bannerDesign.secondaryColor;
                            ctx.fillRect(0, bannerHeight/2, bannerWidth, bannerHeight/2);
                            break;
                    }
                    
                    // Simple symbol in center (if any)
                    if (bannerDesign.symbol !== 'none') {
                        ctx.fillStyle = bannerDesign.symbolColor;
                        const symbolX = 0; // Center on pole
                        const symbolY = bannerHeight/2;
                        
                        // Very simplified symbols for small banner
                        switch (bannerDesign.symbol) {
                            case 'crown':
                                ctx.beginPath();
                                ctx.moveTo(symbolX - 1.5, symbolY + 1);
                                ctx.lineTo(symbolX - 1, symbolY - 1);
                                ctx.lineTo(symbolX, symbolY);
                                ctx.lineTo(symbolX + 1, symbolY - 1);
                                ctx.lineTo(symbolX + 1.5, symbolY + 1);
                                ctx.closePath();
                                ctx.fill();
                                break;
                                
                            case 'star':
                                ctx.beginPath();
                                for (let i = 0; i < 5; i++) {
                                    const angle = (i * 72 - 90) * Math.PI / 180;
                                    const px = symbolX + Math.cos(angle) * 1.5;
                                    const py = symbolY + Math.sin(angle) * 1.5;
                                    if (i === 0) ctx.moveTo(px, py);
                                    else ctx.lineTo(px, py);
                                }
                                ctx.closePath();
                                ctx.fill();
                                break;
                                
                            default:
                                // Simple dot for other symbols
                                ctx.beginPath();
                                ctx.arc(symbolX, symbolY, 1, 0, Math.PI * 2);
                                ctx.fill();
                                break;
                        }
                    }
                    
                    // Banner border
                    if (bannerDesign.hasBorder) {
                        ctx.strokeStyle = bannerDesign.borderColor;
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(-bannerWidth/2, 0);
                        ctx.lineTo(bannerWidth/2, 0);
                        ctx.lineTo(0, bannerHeight);
                        ctx.lineTo(-bannerWidth/2, 0);
                        ctx.stroke();
                    }
                    
                    ctx.restore(); // Close clipping context
                    
                    ctx.restore(); // Close rotation/translation context
                }
            }
        }

        function renderRecruitGroup(ctx, x, y, group, world) {
            // Get the current kingdom color dynamically
            let kingdomColor = '#888888'; // Default gray if kingdom not found
            
            // Find the kingdom across all worlds
            for (let w = 0; w < worlds.length; w++) {
                const kingdom = worlds[w].kingdoms.find(k => k.id === group.kingdom.id && k.alive);
                if (kingdom) {
                    kingdomColor = kingdom.color;
                    break;
                }
            }
            
            // Keep normal colors during Terra darkness - no darkening
            
            // Check if this recruit group is being followed
            var isFollowed = camera.followingEntity && 
                           camera.followingEntity.type === 'recruit' && 
                           camera.followingEntity.entity === group;
            
            // Draw follow indicator if being followed
            if (isFollowed) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y - 8, 20, 0, Math.PI * 2);
                ctx.stroke();
                
                // Pulsing inner circle
                var pulseSize = 15 + Math.sin(Date.now() * 0.003) * 4;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y - 8, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            
            // Draw shadow for the recruit group
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.beginPath();
            ctx.ellipse(x + 3, y - 4, 12, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            var positions = [ {dx: 0, dy: 0}, {dx: -8, dy: -4}, {dx: 8, dy: -4}, {dx: -4, dy: 5}, {dx: 4, dy: 5} ];
            for(var i = 0; i < 5; i++) {
                var unitX = x + positions[i].dx;
                var unitY = y + positions[i].dy;
                // Body in kingdom color
                ctx.fillStyle = kingdomColor; 
                ctx.fillRect(unitX - 2, unitY - 6, 4, 6);
                // Head in skin tone
                ctx.fillStyle = '#FFDAB9'; 
                ctx.beginPath(); 
                ctx.arc(unitX, unitY - 8, 2.5, 0, Math.PI * 2); 
                ctx.fill();
                
                // Chinese farmer hat (conical straw hat)
                // Main hat cone
                ctx.fillStyle = '#D2B48C'; // Light straw color
                ctx.beginPath();
                ctx.moveTo(unitX - 5, unitY - 8);   // Left edge
                ctx.lineTo(unitX, unitY - 11);       // Top point
                ctx.lineTo(unitX + 5, unitY - 8);    // Right edge
                ctx.closePath();
                ctx.fill();
                
                // Darker shading on left side for depth
                ctx.fillStyle = '#A0826D'; // Darker straw
                ctx.beginPath();
                ctx.moveTo(unitX - 5, unitY - 8);   // Left edge
                ctx.lineTo(unitX, unitY - 11);       // Top point
                ctx.lineTo(unitX - 2, unitY - 8);    // Partway across
                ctx.closePath();
                ctx.fill();
                
                // Hat brim line
                ctx.strokeStyle = '#8B7355';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(unitX - 5, unitY - 8);
                ctx.lineTo(unitX + 5, unitY - 8);
                ctx.stroke();
                
                // Chin strap (thin dark line)
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(unitX - 2, unitY - 7);
                ctx.quadraticCurveTo(unitX, unitY - 5, unitX + 2, unitY - 7);
                ctx.stroke();
            }
            
            // Add torch for dark Terra recruit groups
            if (world && world.name === 'Terra' && game.terraDarkness.transitionProgress > 0.5) {
                // Torch position (held by center recruit)
                const torchHolderX = x;
                const torchHolderY = y;
                
                // Torch stick (tall)
                ctx.strokeStyle = '#4A2810';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(torchHolderX + 3, torchHolderY - 5);
                ctx.lineTo(torchHolderX + 3, torchHolderY - 20);
                ctx.stroke();
                
                // Flame
                
                // Outer flame (orange) - no sway
                ctx.fillStyle = '#FF6B35';
                ctx.beginPath();
                ctx.moveTo(torchHolderX + 3, torchHolderY - 20);
                ctx.quadraticCurveTo(
                    torchHolderX + 1, torchHolderY - 24,
                    torchHolderX + 3, torchHolderY - 28
                );
                ctx.quadraticCurveTo(
                    torchHolderX + 5, torchHolderY - 24,
                    torchHolderX + 3, torchHolderY - 20
                );
                ctx.fill();
                
                // Inner flame (yellow)
                ctx.fillStyle = '#FFD93D';
                ctx.beginPath();
                ctx.moveTo(torchHolderX + 3, torchHolderY - 21);
                ctx.quadraticCurveTo(
                    torchHolderX + 2, torchHolderY - 23,
                    torchHolderX + 3, torchHolderY - 25
                );
                ctx.quadraticCurveTo(
                    torchHolderX + 4, torchHolderY - 23,
                    torchHolderX + 3, torchHolderY - 21
                );
                ctx.fill();
                
                // Glow effect
                ctx.save();
                const glowGradient = ctx.createRadialGradient(
                    torchHolderX + 3, torchHolderY - 24, 0,
                    torchHolderX + 3, torchHolderY - 24, 15
                );
                glowGradient.addColorStop(0, 'rgba(255, 150, 0, 0.3)');
                glowGradient.addColorStop(1, 'rgba(255, 150, 0, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(torchHolderX + 3, torchHolderY - 24, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        function renderBattle(ctx, x, y, battle) {
            var intensity = 1 - (battle.currentTick / battle.duration);
            ctx.globalAlpha = intensity * 0.7; ctx.fillStyle = '#FF6B00'; ctx.beginPath(); ctx.arc(x, y, 20 * (1 - intensity) + 5, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(x, y, 15 * (1 - intensity) + 3, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#666666'; ctx.globalAlpha = intensity * 0.3;
            for (var i = 0; i < 3; i++) {
                var offsetX = Math.sin(i * 2 + performance.now() * 0.0001) * 10;
                var offsetY = -battle.currentTick + i * 5;
                ctx.beginPath(); ctx.arc(x + offsetX, y + offsetY, 8, 0, Math.PI * 2); ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        
        function renderPortal(ctx, iso, portal, world) {
            ctx.save();
            ctx.translate(iso.x, iso.y);
            
            // Draw shadow first - elliptical to match portal base
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
            ctx.beginPath();
            ctx.ellipse(4, 8, 25, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Portal dimensions
            const portalHeight = 50;
            const portalWidth = 25;
            
            // Check if player is within entry range
            let isPlayerInRange = false;
            if (camera.viewMode === 'world' && camera.currentWorld && 
                camera.zoom >= 2.5 && !camera.isPortalTransitioning) {
                const centerWorldPos = screenToWorld(canvas.width / 2, canvas.height / 2);
                const centerTilePos = isometricToTile(centerWorldPos.x, centerWorldPos.y);
                
                if (centerTilePos.x >= 0 && centerTilePos.x < WORLD_SIZE && 
                    centerTilePos.y >= 0 && centerTilePos.y < WORLD_SIZE) {
                    const entrance = portal.worldA === world.id ? portal.tileA : portal.tileB;
                    const dist = Math.abs(entrance.x - centerTilePos.x) + Math.abs(entrance.y - centerTilePos.y);
                    isPlayerInRange = dist <= 8;
                }
            }
            
            // Add entry range indicator
            if (isPlayerInRange) {
                const pulseTime = performance.now() * 0.001;
                const pulseRadius = 35 + Math.sin(pulseTime * 3) * 5;
                ctx.strokeStyle = 'rgba(255, 255, 255, ' + (0.4 + Math.sin(pulseTime * 3) * 0.2) + ')';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, pulseRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Add "Enter Portal" text at top of portal
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(255, 255, 255, ' + (0.8 + Math.sin(pulseTime * 2) * 0.2) + ')';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 3;
                ctx.strokeText('Enter Portal', 0, -portalHeight - 25);
                ctx.fillText('Enter Portal', 0, -portalHeight - 25);
            }
            
            // Calculate expiration percentage
            const remainingTicks = portal.expiresTick - game.currentTick;
            const totalDuration = portal.isDivine ? 60000 : 6000; // Divine portals last 100 years
            const expirationPercentage = Math.max(0, remainingTicks / totalDuration);
            
            // Determine portal owner and color
            let portalColor = portal.isDivine ? 
                { r: 255, g: 200, b: 100 } : // Golden color for divine portals
                { r: 200, g: 100, b: 255 }; // Default purple
            let ownerKingdom = null;
            
            // Check if portal has an owner
            if (portal.ownerId !== undefined) {
                // Find the owner kingdom
                for (let w = 0; w < worlds.length; w++) {
                    ownerKingdom = worlds[w].kingdoms.find(k => k.id === portal.ownerId);
                    if (ownerKingdom) break;
                }
                
                if (ownerKingdom) {
                    // Parse kingdom color
                    const color = ownerKingdom.color;
                    if (color.startsWith('hsl')) {
                        // Convert HSL to RGB (simplified)
                        ctx.fillStyle = color;
                        ctx.fillRect(0, 0, 1, 1);
                        const pixelData = ctx.getImageData(0, 0, 1, 1).data;
                        portalColor = { r: pixelData[0], g: pixelData[1], b: pixelData[2] };
                    }
                }
            }
            
            // Check who controls the portal tile
            const entrance = portal.worldA === world.id ? portal.tileA : portal.tileB;
            const controller = world.tiles[entrance.x][entrance.y].owner;
            
            // Render portal as tall elliptical magical gateway
            const animTime = performance.now() * 0.0005;
            
            // Draw portal base/ground effect
            ctx.save();
            const groundGradient = ctx.createRadialGradient(0, 10, 0, 0, 10, 30);
            groundGradient.addColorStop(0, `rgba(${portalColor.r}, ${portalColor.g}, ${portalColor.b}, 0.3)`);
            groundGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = groundGradient;
            ctx.beginPath();
            ctx.ellipse(0, 10, 30, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Draw magical particles floating around portal
            ctx.save();
            for(let i = 0; i < 12; i++){
                const particleTime = animTime * 2 + i * 0.5;
                const particleY = -portalHeight/2 + (particleTime * 30) % portalHeight;
                const particleX = Math.sin(particleTime * 3 + i) * (portalWidth + 10);
                const particleSize = 2 + Math.sin(particleTime * 5) * 1;
                const particleAlpha = (0.5 + Math.sin(particleTime * 4) * 0.3) * expirationPercentage;
                
                ctx.fillStyle = `rgba(${portalColor.r}, ${portalColor.g}, ${portalColor.b}, ${particleAlpha})`;
                ctx.beginPath();
                ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Add glow
                const glowGradient = ctx.createRadialGradient(particleX, particleY, 0, particleX, particleY, particleSize * 3);
                glowGradient.addColorStop(0, `rgba(${portalColor.r}, ${portalColor.g}, ${portalColor.b}, ${particleAlpha * 0.5})`);
                glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(particleX, particleY, particleSize * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            // Draw portal vortex center
            ctx.save();
            const vortexGradient = ctx.createRadialGradient(0, -portalHeight/2, 0, 0, -portalHeight/2, portalWidth);
            vortexGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
            vortexGradient.addColorStop(0.3, `rgba(${portalColor.r + 50}, ${portalColor.g + 50}, ${portalColor.b + 50}, 0.4)`);
            vortexGradient.addColorStop(0.7, `rgba(${portalColor.r}, ${portalColor.g}, ${portalColor.b}, 0.2)`);
            vortexGradient.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
            ctx.fillStyle = vortexGradient;
            ctx.beginPath();
            ctx.ellipse(0, -portalHeight/2, portalWidth * 0.8, portalHeight * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Draw tall elliptical rings
            for(let i = 0; i < 5; i++){
                const radiusX = (portalWidth - i * 4) * (0.8 + Math.sin(animTime + i) * 0.2);
                const radiusY = (portalHeight - i * 8) * (0.8 + Math.sin(animTime + i) * 0.2);
                
                // Modify opacity based on expiration
                let alpha = (0.3 + i*0.1) * expirationPercentage;
                
                // Use owner color or controller color
                if (controller !== null && controller !== portal.ownerId) {
                    // Portal is contested - show with red tinge
                    ctx.strokeStyle = `rgba(255, ${100 + i*20}, ${100 + i*20}, ${alpha})`;
                } else {
                    // Add red tinge as portal expires
                    const redTinge = 1 - expirationPercentage;
                    ctx.strokeStyle = `rgba(${Math.min(255, portalColor.r + redTinge * 100)}, ${portalColor.g * expirationPercentage}, ${portalColor.b * expirationPercentage}, ${alpha})`;
                }
                
                ctx.lineWidth = 3 + i;
                ctx.save();
                ctx.translate(0, -portalHeight/2);
                ctx.beginPath();
                ctx.ellipse(0, 0, radiusX, radiusY, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // Add inner glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = `rgba(${portalColor.r}, ${portalColor.g}, ${portalColor.b}, 0.5)`;
                ctx.stroke();
                ctx.restore();
            }
            
            // Draw vertical energy beams
            ctx.save();
            ctx.globalAlpha = 0.3 * expirationPercentage;
            const beamGradient = ctx.createLinearGradient(0, 0, 0, -portalHeight);
            beamGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
            beamGradient.addColorStop(0.5, `rgba(${portalColor.r}, ${portalColor.g}, ${portalColor.b}, 0.5)`);
            beamGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = beamGradient;
            
            for(let i = 0; i < 3; i++){
                const beamX = (i - 1) * 15;
                const beamWidth = 3 + Math.sin(animTime * 3 + i) * 1;
                ctx.fillRect(beamX - beamWidth/2, 0, beamWidth, -portalHeight);
            }
            ctx.restore();
            
            // Add ownership indicator at top of portal
            if (ownerKingdom) {
                ctx.fillStyle = ownerKingdom.color;
                ctx.globalAlpha = 0.8 * expirationPercentage;
                ctx.beginPath();
                ctx.arc(0, -portalHeight - 10, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Add glowing crown for owner
                const crownGlow = ctx.createRadialGradient(0, -portalHeight - 10, 0, 0, -portalHeight - 10, 15);
                crownGlow.addColorStop(0, `rgba(${portalColor.r}, ${portalColor.g}, ${portalColor.b}, 0.5)`);
                crownGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = crownGlow;
                ctx.beginPath();
                ctx.arc(0, -portalHeight - 10, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Add expiration timer text
            if (remainingTicks < 1200) { // Show timer in last 40 seconds (at 30 TPS)
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = remainingTicks < 300 ? '#ff6666' : '#ffcc66';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                const secondsLeft = Math.ceil(remainingTicks / 30);
                ctx.strokeText(secondsLeft + 's', 0, 30);
                ctx.fillText(secondsLeft + 's', 0, 30);
            }
            
            ctx.restore();
        }

        function renderArmySpawn(ctx, x, y, spawn) {
            // Get the current kingdom color dynamically
            let kingdomColor = '#888888'; // Default gray if kingdom not found
            
            // Find the kingdom across all worlds
            for (let w = 0; w < worlds.length; w++) {
                const kingdom = worlds[w].kingdoms.find(k => k.id === spawn.kingdom.id && k.alive);
                if (kingdom) {
                    kingdomColor = kingdom.color;
                    break;
                }
            }
            
            var progress = spawn.currentTick / spawn.duration;
            var radius = 10 + progress * 20;
            var alpha = 1 - progress;
            ctx.strokeStyle = kingdomColor; ctx.lineWidth = 3; ctx.globalAlpha = alpha * 0.8;
            ctx.beginPath(); ctx.arc(x, y - 30, radius, 0, Math.PI * 2); ctx.stroke();
            ctx.beginPath(); ctx.arc(x, y - 30, radius * 0.6, 0, Math.PI * 2); ctx.stroke();
            ctx.fillStyle = kingdomColor; ctx.globalAlpha = alpha; ctx.beginPath(); ctx.moveTo(x, y - 40); ctx.lineTo(x - 5, y - 35); ctx.lineTo(x + 5, y - 35); ctx.closePath(); ctx.fill();
            ctx.globalAlpha = 1;
        }
        
        function renderLightningStrike(ctx, strike) {
            const progress = strike.currentTick / strike.duration;
            const fadeOut = 1 - progress;
            
            ctx.save();
            ctx.translate(strike.x, strike.y);
            
            strike.bolts.forEach(bolt => {
                if (strike.currentTick < bolt.delay) return;
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${fadeOut})`;
                ctx.lineWidth = strike.isMain ? 4 : 2;
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'cyan';
                
                ctx.beginPath();
                bolt.segments.forEach((segment, i) => {
                    if (i === 0) {
                        ctx.moveTo(segment.x, segment.y);
                    } else {
                        ctx.lineTo(segment.x, segment.y);
                    }
                });
                ctx.stroke();
                
                // Thinner inner bolt
                ctx.strokeStyle = `rgba(200, 200, 255, ${fadeOut})`;
                ctx.lineWidth = strike.isMain ? 2 : 1;
                ctx.stroke();
            });
            
            // Ground impact
            if (progress > 0.2) {
                const impactRadius = (progress - 0.2) * 40;
                ctx.fillStyle = `rgba(255, 255, 255, ${fadeOut * 0.3})`;
                ctx.beginPath();
                ctx.arc(0, 0, impactRadius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function renderBlessingEffect(ctx, effect) {
            const progress = effect.currentTick / effect.duration;
            const fadeIn = Math.min(progress * 3, 1);
            const fadeOut = progress > 0.7 ? (1 - progress) / 0.3 : 1;
            
            ctx.save();
            ctx.translate(effect.x, effect.y);
            
            // Golden aura
            const animTime = performance.now() * 0.0001;
            const auraRadius = 50 + Math.sin(animTime * 10) * 10;
            const gradient = ctx.createRadialGradient(0, -30, 0, 0, -30, auraRadius);
            gradient.addColorStop(0, `rgba(255, 215, 0, ${fadeIn * fadeOut * 0.3})`);
            gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, -30, auraRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Sparkle particles
            effect.particles.forEach(p => {
                if (effect.currentTick > p.delay) {
                    const particleProgress = (effect.currentTick - p.delay) / (effect.duration - p.delay);
                    const x = Math.cos(p.angle) * p.radius;
                    const y = Math.sin(p.angle) * p.radius - 30;
                    const alpha = (1 - particleProgress) * fadeIn;
                    
                    ctx.fillStyle = `rgba(255, 255, 200, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x, y, p.size * (1 - particleProgress), 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            ctx.restore();
        }
        
        function renderNomadTribe(ctx, tribe) {
            // First pass: Draw wheel trail marks at ground level (optimized rendering)
            ctx.save();
            const world = worlds[2]; // Aether world
            tribe.wheelTrails.forEach(trail => {
                const opacity = 1 - (trail.age / trail.maxAge);
                const size = trail.size || 2;
                
                // Skip very faint trails
                if (opacity > 0.05) {
                    // Get the wagon's position in isometric
                    const wagonIso = worldToIsometric(trail.x, trail.y);
                    
                    // Calculate wheel position in screen space
                    const wagonWidth = 37.96875;
                    const wagonHeight = 16.875 * 1.1;
                    const wheelRadius = 5.0625;
                    
                    // Wheel positions relative to wagon center in screen space
                    const wheelOffsetX = wagonWidth / 3;
                    const wheelOffsetY = wagonHeight / 2 + wheelRadius - 2; // Slightly above ground
                    
                    // Apply side and flip
                    const sideMultiplier = trail.wheelSide === 'left' ? -1 : 1;
                    const flipMultiplier = trail.facingRight ? -1 : 1;
                    
                    // Calculate final screen position
                    const wheelScreenX = wagonIso.x + (wheelOffsetX * sideMultiplier * flipMultiplier);
                    const wheelScreenY = wagonIso.y + wheelOffsetY;
                    
                    // Add small offset down and behind (in screen space)
                    const trailOffsetX = -2; // Behind
                    const trailOffsetY = 0;   // Neutral position (was -2)
                    
                    const finalScreenX = wheelScreenX + trailOffsetX;
                    const finalScreenY = wheelScreenY + trailOffsetY;
                    
                    // Get elevation at wagon position
                    let elevationOffset = 0;
                    const tileX = Math.floor(trail.x);
                    const tileY = Math.floor(trail.y);
                    if (world && world.tiles && world.tiles[tileX] && world.tiles[tileX][tileY]) {
                        const tile = world.tiles[tileX][tileY];
                        elevationOffset = (tile.height - 0.65) * 240;
                    }
                    
                    // Draw trail mark at calculated screen position
                    ctx.fillStyle = `rgba(101, 67, 33, ${opacity * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(finalScreenX, finalScreenY - elevationOffset, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.restore();
            
            // Second pass: Draw all wagons and men
            tribe.wagons.forEach((wagon, index) => {
                const iso = worldToIsometric(wagon.x, wagon.y);
                
                // Check if this wagon is being followed
                var isFollowed = camera.followingEntity && 
                               camera.followingEntity.type === 'nomadWagon' &&
                               camera.followingEntity.wagonIndex === index;
                
                // Get terrain elevation at wagon position
                let elevationOffset = 0;
                const tileX = Math.floor(wagon.x);
                const tileY = Math.floor(wagon.y);
                const world = worlds[2]; // Aether world
                if (world && world.tiles && world.tiles[tileX] && world.tiles[tileX][tileY]) {
                    const tile = world.tiles[tileX][tileY];
                    elevationOffset = (tile.height - 0.65) * 240;
                }
                
                // Draw follow indicator if being followed
                if (isFollowed) {
                    ctx.save();
                    ctx.translate(iso.x, iso.y - elevationOffset);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, 35, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Pulsing inner circle
                    var pulseSize = 30 + Math.sin(Date.now() * 0.003) * 5;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Draw wagon with unique shapes (50% wider, all same size)
                const wagonWidth = 37.96875;
                const wagonHeight = 16.875 * 1.1; // 10% taller
                const wheelRadius = 5.0625;
                
                // Only draw the man pulling if he's in pulling state
                if (wagon.man.state === 'pulling') {
                    const manScale = 0.5;
                    // Position man on the correct side based on wagon direction
                    const manX = wagon.facingRight ? iso.x + 25 : iso.x - 25;
                    // Position man so his boots align with bottom of wheels
                    const manY = iso.y - elevationOffset + (wagonHeight/2 + wheelRadius - 2 * manScale) - 5; // Move up
                    
                    // Draw man's shadow
                    ctx.save();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                    ctx.beginPath();
                    // Shadow relative to man's elevated position (like army units)
                    ctx.ellipse(manX + 2, manY - 2, 6 * manScale, 3 * manScale, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                
                ctx.save();
                ctx.translate(manX, manY);
                ctx.scale(manScale, manScale);
                
                // Draw body (black)
                ctx.fillStyle = wagon.man.color;
                ctx.fillRect(-4, -12, 8, 12);
                
                // Draw head (white)
                ctx.fillStyle = wagon.man.headColor;
                ctx.beginPath();
                ctx.arc(0, -16, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Long pointy ears for pulling man
                ctx.fillStyle = wagon.man.headColor;
                // Left ear
                ctx.beginPath();
                ctx.moveTo(-4, -14);
                ctx.lineTo(-6, -22);
                ctx.lineTo(-2, -18);
                ctx.closePath();
                ctx.fill();
                // Right ear
                ctx.beginPath();
                ctx.moveTo(4, -14);
                ctx.lineTo(6, -22);
                ctx.lineTo(2, -18);
                ctx.closePath();
                ctx.fill();
                
                // Draw pointy hat (black)
                ctx.fillStyle = wagon.man.hatColor;
                ctx.beginPath();
                ctx.moveTo(-3, -18);
                ctx.lineTo(0, -25);
                ctx.lineTo(3, -18);
                ctx.closePath();
                ctx.fill();
                
                // Draw boots (white)
                ctx.fillStyle = wagon.man.bootColor;
                ctx.fillRect(-3, -2, 2, 2);
                ctx.fillRect(1, -2, 2, 2);
                
                ctx.restore();
                
                // Draw pulling beam/rope between man and wagon
                ctx.save();
                ctx.strokeStyle = '#654321'; // Brown color for rope/beam
                ctx.lineWidth = 2;
                ctx.beginPath();
                // Start from man's hands (slightly toward the wagon)
                const beamStartX = wagon.facingRight ? manX - 4 : manX + 4;
                const beamStartY = manY - 6 * manScale; // At chest/arm level
                // End at front of wagon (adjust for facing direction)
                const beamEndX = wagon.facingRight ? iso.x + wagonWidth/2 : iso.x - wagonWidth/2;
                const beamEndY = iso.y - elevationOffset;
                ctx.moveTo(beamStartX, beamStartY);
                ctx.lineTo(beamEndX, beamEndY);
                ctx.stroke();
                
                // Add a second parallel line for depth
                ctx.strokeStyle = '#4A3520'; // Darker brown
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(beamStartX, beamStartY + 2);
                ctx.lineTo(beamEndX, beamEndY + 2);
                ctx.stroke();
                ctx.restore();
                } // End of if (wagon.man.state === 'pulling')
                
                ctx.save();
                ctx.translate(iso.x, iso.y - elevationOffset);
                
                // Draw elliptical shadow at wheel level
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.beginPath();
                // Position shadow at bottom of wagon near wheels
                const shadowY = wagonHeight/2 + wheelRadius/2 - 5;
                ctx.ellipse(6, shadowY, wagonWidth/2 + 5, wagonHeight/3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                // Flip wagon if moving right
                if (wagon.facingRight) {
                    ctx.scale(-1, 1);
                }
                
                // Main wagon body
                if (wagon.isLead) {
                    // Lead wagon with checkerboard pattern
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(-wagonWidth/2, wagonHeight/3);
                    ctx.lineTo(-wagonWidth/2, -wagonHeight/3);
                    ctx.lineTo(-wagonWidth/2.5, -wagonHeight/2);
                    ctx.quadraticCurveTo(-wagonWidth/2.5, -wagonHeight * 0.7, 0, -wagonHeight * 0.75);
                    ctx.quadraticCurveTo(wagonWidth/2.5, -wagonHeight * 0.7, wagonWidth/2.5, -wagonHeight/2);
                    ctx.lineTo(wagonWidth/2, -wagonHeight/3);
                    ctx.lineTo(wagonWidth/2, wagonHeight/3);
                    ctx.closePath();
                    ctx.clip();
                    
                    // Checkerboard pattern rotated 45 degrees
                    ctx.rotate(Math.PI / 4); // Rotate 45 degrees
                    const squareSize = 4;
                    const diagonal = Math.sqrt(wagonWidth * wagonWidth + wagonHeight * wagonHeight);
                    for (let row = -Math.ceil(diagonal/squareSize); row <= Math.ceil(diagonal/squareSize); row++) {
                        for (let col = -Math.ceil(diagonal/squareSize); col <= Math.ceil(diagonal/squareSize); col++) {
                            const isBlack = (row + col) % 2 === 0;
                            ctx.fillStyle = isBlack ? '#000' : '#fff';
                            ctx.fillRect(col * squareSize, row * squareSize, squareSize, squareSize);
                        }
                    }
                    ctx.restore();
                } else {
                    // Regular wagons with solid color
                    ctx.fillStyle = wagon.color;
                    ctx.beginPath();
                    ctx.moveTo(-wagonWidth/2, wagonHeight/3);
                    ctx.lineTo(-wagonWidth/2, -wagonHeight/3);
                    ctx.lineTo(-wagonWidth/2.5, -wagonHeight/2);
                    ctx.quadraticCurveTo(-wagonWidth/2.5, -wagonHeight * 0.7, 0, -wagonHeight * 0.75);
                    ctx.quadraticCurveTo(wagonWidth/2.5, -wagonHeight * 0.7, wagonWidth/2.5, -wagonHeight/2);
                    ctx.lineTo(wagonWidth/2, -wagonHeight/3);
                    ctx.lineTo(wagonWidth/2, wagonHeight/3);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Roof trim
                ctx.strokeStyle = wagon.color === 'black' ? '#666' : '#999';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(-wagonWidth/2.5, -wagonHeight/2);
                ctx.quadraticCurveTo(-wagonWidth/2.5, -wagonHeight * 0.7, 0, -wagonHeight * 0.75);
                ctx.quadraticCurveTo(wagonWidth/2.5, -wagonHeight * 0.7, wagonWidth/2.5, -wagonHeight/2);
                ctx.stroke();
                
                // Side windows
                ctx.fillStyle = wagon.color === 'black' ? '#444' : '#ddd';
                ctx.strokeStyle = wagon.color === 'black' ? '#666' : '#999';
                ctx.lineWidth = 1;
                // Left window
                ctx.beginPath();
                ctx.rect(-wagonWidth/3, -wagonHeight/4, wagonWidth/6, wagonHeight/4);
                ctx.fill();
                ctx.stroke();
                // Right window
                ctx.beginPath();
                ctx.rect(wagonWidth/6, -wagonHeight/4, wagonWidth/6, wagonHeight/4);
                ctx.fill();
                ctx.stroke();
                
                
                // Steps at back
                ctx.fillStyle = wagon.color === 'black' ? '#444' : '#bbb';
                ctx.fillRect(wagonWidth/2 - 3, wagonHeight/6, 3, wagonHeight/6);
                
                // Ornamental curves on side
                ctx.strokeStyle = wagon.color === 'black' ? '#666' : '#999';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-wagonWidth/2.5, -wagonHeight/2.5);
                ctx.quadraticCurveTo(-wagonWidth/3, -wagonHeight/2.2, -wagonWidth/3, -wagonHeight/3);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(wagonWidth/2.5, -wagonHeight/2.5);
                ctx.quadraticCurveTo(wagonWidth/3, -wagonHeight/2.2, wagonWidth/3, -wagonHeight/3);
                ctx.stroke();
                
                // Main border
                ctx.strokeStyle = wagon.color === 'black' ? '#333' : '#ccc';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-wagonWidth/2, wagonHeight/3);
                ctx.lineTo(-wagonWidth/2, -wagonHeight/3);
                ctx.lineTo(-wagonWidth/2.5, -wagonHeight/2);
                ctx.quadraticCurveTo(-wagonWidth/2.5, -wagonHeight * 0.7, 0, -wagonHeight * 0.75);
                ctx.quadraticCurveTo(wagonWidth/2.5, -wagonHeight * 0.7, wagonWidth/2.5, -wagonHeight/2);
                ctx.lineTo(wagonWidth/2, -wagonHeight/3);
                ctx.lineTo(wagonWidth/2, wagonHeight/3);
                ctx.stroke();
                
                // Wagon wheels (2x bigger) with rotation
                // wheelRadius already declared above
                
                // Left wheel
                ctx.save();
                ctx.translate(-wagonWidth/3, wagonHeight/2);
                ctx.rotate(wagon.wheelRotation);
                
                ctx.fillStyle = '#444';
                ctx.beginPath();
                ctx.arc(0, 0, wheelRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Wheel spokes
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                for (let i = 0; i < 4; i++) {
                    const angle = (i * Math.PI) / 2;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * 2, Math.sin(angle) * 2);
                    ctx.lineTo(Math.cos(angle) * wheelRadius, Math.sin(angle) * wheelRadius);
                    ctx.stroke();
                }
                
                // Wheel rim
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.arc(0, 0, wheelRadius - 1, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
                
                // Right wheel
                ctx.save();
                ctx.translate(wagonWidth/3, wagonHeight/2);
                ctx.rotate(wagon.wheelRotation);
                
                ctx.fillStyle = '#444';
                ctx.beginPath();
                ctx.arc(0, 0, wheelRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Wheel spokes
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                for (let i = 0; i < 4; i++) {
                    const angle = (i * Math.PI) / 2;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * 2, Math.sin(angle) * 2);
                    ctx.lineTo(Math.cos(angle) * wheelRadius, Math.sin(angle) * wheelRadius);
                    ctx.stroke();
                }
                
                // Wheel rim
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.arc(0, 0, wheelRadius - 1, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
                
                ctx.restore();
            });
            
            // Third pass: Draw campfire if active
            if (tribe.campfire.active || tribe.campfire.sticks.length > 0) {
                const campfireIso = worldToIsometric(tribe.campfire.x, tribe.campfire.y);
                
                ctx.save();
                ctx.translate(campfireIso.x, campfireIso.y);
                
                // Get terrain elevation at campfire position
                let elevationOffset = 0;
                const tileX = Math.floor(tribe.campfire.x);
                const tileY = Math.floor(tribe.campfire.y);
                const world = worlds[2]; // Aether world
                if (world && world.tiles && world.tiles[tileX] && world.tiles[tileX][tileY]) {
                    const tile = world.tiles[tileX][tileY];
                    elevationOffset = (tile.height - 0.65) * 240;
                }
                ctx.translate(0, -elevationOffset);
                
                // Draw campfire glow on ground (isometric ellipse)
                if (tribe.campfire.active && tribe.campfire.glowRadius > 0) {
                    const glowRadius = tribe.campfire.glowRadius * 0.6; // Smaller
                    const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                    glowGradient.addColorStop(0, `rgba(255, 150, 50, ${0.3 * tribe.campfire.fireIntensity})`);
                    glowGradient.addColorStop(0.5, `rgba(255, 100, 0, ${0.15 * tribe.campfire.fireIntensity})`);
                    glowGradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, glowRadius, glowRadius * 0.5, 0, 0, Math.PI * 2); // Isometric ellipse
                    ctx.fill();
                }
                
                // Draw sticks in isometric view
                ctx.save();
                tribe.campfire.sticks.forEach((stick, idx) => {
                    ctx.save();
                    // Convert stick position to isometric
                    const stickX = (stick.x - tribe.campfire.x) * 20;
                    const stickY = (stick.y - tribe.campfire.y) * 10; // Squash Y for isometric
                    ctx.translate(stickX, stickY);
                    ctx.rotate(stick.angle);
                    
                    // Draw stick with isometric perspective
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.moveTo(-8, -1);
                    ctx.lineTo(8, -1);
                    ctx.lineTo(7, 1);
                    ctx.lineTo(-7, 1);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.strokeStyle = '#4A3520';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                    ctx.restore();
                });
                ctx.restore();
                
                // Draw fire effect
                if (tribe.campfire.active && tribe.campfire.fireIntensity > 0) {
                    // Dynamic flame particles from stored array
                    tribe.campfire.flameParticles.forEach(particle => {
                        const progress = particle.age / particle.maxAge;
                        const opacity = (1 - progress) * tribe.campfire.fireIntensity;
                        const scale = particle.size * (1 + progress);
                        
                        ctx.save();
                        ctx.translate(particle.x * 5, particle.y * 5); // Smaller scale
                        ctx.scale(scale, scale * 1.5);
                        
                        const flameGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 4); // Smaller
                        flameGradient.addColorStop(0, `rgba(255, 255, 150, ${opacity})`);
                        flameGradient.addColorStop(0.3, `rgba(255, 200, 50, ${opacity * 0.8})`);
                        flameGradient.addColorStop(0.6, `rgba(255, 100, 0, ${opacity * 0.5})`);
                        flameGradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                        
                        ctx.fillStyle = flameGradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    });
                    
                    // Base fire glow (smaller and isometric)
                    const baseGlow = ctx.createRadialGradient(0, -3, 0, 0, -3, 8);
                    baseGlow.addColorStop(0, `rgba(255, 200, 100, ${0.8 * tribe.campfire.fireIntensity})`);
                    baseGlow.addColorStop(0.5, `rgba(255, 150, 50, ${0.4 * tribe.campfire.fireIntensity})`);
                    baseGlow.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    ctx.fillStyle = baseGlow;
                    ctx.beginPath();
                    ctx.ellipse(0, -3, 8, 4, 0, 0, Math.PI * 2); // Isometric ellipse
                    ctx.fill();
                }
                
                // Draw smoke particles
                tribe.campfire.smokeParticles.forEach(particle => {
                    const smokeIso = worldToIsometric(particle.x, particle.y);
                    const opacity = (1 - particle.age / particle.maxAge) * 0.3;
                    const size = particle.size * (1 + particle.age / particle.maxAge * 2);
                    
                    ctx.save();
                    ctx.translate(smokeIso.x - campfireIso.x, smokeIso.y - campfireIso.y - particle.age * 0.8);
                    ctx.fillStyle = `rgba(60, 60, 60, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
                
                ctx.restore();
            }
            
            // Fourth pass: Draw people when not in wagons
            tribe.wagons.forEach((wagon, index) => {
                // Draw man if not pulling
                if (wagon.man.state !== 'pulling') {
                    const manIso = worldToIsometric(wagon.man.x, wagon.man.y);
                    
                    // Get terrain elevation
                    let elevationOffset = 0;
                    const tileX = Math.floor(wagon.man.x);
                    const tileY = Math.floor(wagon.man.y);
                    const world = worlds[2];
                    if (world && world.tiles && world.tiles[tileX] && world.tiles[tileX][tileY]) {
                        const tile = world.tiles[tileX][tileY];
                        elevationOffset = (tile.height - 0.65) * 240;
                    }
                    
                    const manScale = 0.5;
                    const manY = manIso.y - elevationOffset - 5;
                    
                    // Draw man
                    ctx.save();
                    ctx.translate(manIso.x, manY);
                    ctx.scale(manScale, manScale);
                    
                    // Draw shadow for standing
                    ctx.save();
                    ctx.translate(0, 2);
                    ctx.scale(1/manScale, 1/manScale);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                    ctx.beginPath();
                    ctx.ellipse(2, -2, 6 * manScale, 3 * manScale, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    // Body
                    ctx.fillStyle = wagon.man.color;
                    ctx.fillRect(-4, -12, 8, 12);
                    
                    // Head
                    ctx.fillStyle = wagon.man.headColor;
                    ctx.beginPath();
                    ctx.arc(0, -16, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Long pointy ears
                    ctx.fillStyle = wagon.man.headColor;
                    // Left ear
                    ctx.beginPath();
                    ctx.moveTo(-4, -14);
                    ctx.lineTo(-6, -22);
                    ctx.lineTo(-2, -18);
                    ctx.closePath();
                    ctx.fill();
                    // Right ear
                    ctx.beginPath();
                    ctx.moveTo(4, -14);
                    ctx.lineTo(6, -22);
                    ctx.lineTo(2, -18);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Hat
                    ctx.fillStyle = wagon.man.hatColor;
                    ctx.beginPath();
                    ctx.moveTo(-3, -18);
                    ctx.lineTo(0, -25);
                    ctx.lineTo(3, -18);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Boots
                    ctx.fillStyle = wagon.man.bootColor;
                    ctx.fillRect(-3, -2, 2, 2);
                    ctx.fillRect(1, -2, 2, 2);
                    
                    ctx.restore();
                }
                
                // Draw woman if visible
                if (wagon.woman.visible) {
                    const womanIso = worldToIsometric(wagon.woman.x, wagon.woman.y);
                    
                    // Get terrain elevation
                    let elevationOffset = 0;
                    const tileX = Math.floor(wagon.woman.x);
                    const tileY = Math.floor(wagon.woman.y);
                    const world = worlds[2];
                    if (world && world.tiles && world.tiles[tileX] && world.tiles[tileX][tileY]) {
                        const tile = world.tiles[tileX][tileY];
                        elevationOffset = (tile.height - 0.65) * 240;
                    }
                    
                    const womanScale = 0.5;
                    const womanY = womanIso.y - elevationOffset - 5;
                    
                    // Draw woman
                    ctx.save();
                    ctx.translate(womanIso.x, womanY);
                    ctx.scale(womanScale, womanScale);
                    
                    // Draw shadow for standing
                    ctx.save();
                    ctx.translate(0, 2);
                    ctx.scale(1/womanScale, 1/womanScale);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                    ctx.beginPath();
                    ctx.ellipse(2, -2, 6 * womanScale, 3 * womanScale, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    // Dress (triangular)
                    ctx.fillStyle = wagon.woman.dressColor;
                    ctx.beginPath();
                    ctx.moveTo(-5, 0);
                    ctx.lineTo(5, 0);
                    ctx.lineTo(3, -12);
                    ctx.lineTo(-3, -12);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Head
                    ctx.fillStyle = wagon.woman.headColor;
                    ctx.beginPath();
                    ctx.arc(0, -16, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Long pointy ears
                    ctx.fillStyle = wagon.woman.headColor;
                    // Left ear
                    ctx.beginPath();
                    ctx.moveTo(-4, -14);
                    ctx.lineTo(-6, -22);
                    ctx.lineTo(-2, -18);
                    ctx.closePath();
                    ctx.fill();
                    // Right ear
                    ctx.beginPath();
                    ctx.moveTo(4, -14);
                    ctx.lineTo(6, -22);
                    ctx.lineTo(2, -18);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Hair (long)
                    ctx.fillStyle = wagon.woman.dressColor === 'black' ? '#333' : '#666';
                    ctx.beginPath();
                    ctx.moveTo(-4, -16);
                    ctx.quadraticCurveTo(-5, -14, -4, -10);
                    ctx.lineTo(-2, -10);
                    ctx.lineTo(-2, -18);
                    ctx.arc(0, -16, 4, Math.PI, 0, true);
                    ctx.lineTo(2, -18);
                    ctx.lineTo(2, -10);
                    ctx.lineTo(4, -10);
                    ctx.quadraticCurveTo(5, -14, 4, -16);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Stick if she has one
                    if (wagon.woman.hasStick) {
                        ctx.strokeStyle = '#654321';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(4, -8);
                        ctx.lineTo(8, -16);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            });
        }

        function renderGiantFish(ctx, world) {
            const fish = game.giantFish;
            const iso = worldToIsometric(fish.x, fish.y);
            
            ctx.save();
            
            // Check if this fish is being followed
            var isFollowed = camera.followingEntity && 
                           camera.followingEntity.type === 'giantFish';
            
            // Draw follow indicator if being followed
            if (isFollowed) {
                ctx.save();
                ctx.translate(iso.x, iso.y - 864); // Same height as fish
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, 120, 0, Math.PI * 2);
                ctx.stroke();
                
                // Pulsing inner circle
                var pulseSize = 100 + Math.sin(Date.now() * 0.003) * 20;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            
            // Draw shadow first (beneath the fish) with fade effect
            const shadowOffset = 150; // How far below the fish the shadow appears (much lower)
            
            // Only draw shadow if opacity > 0
            if (fish.shadowOpacity > 0) {
                ctx.save();
                ctx.translate(iso.x, iso.y + shadowOffset);
                ctx.scale(fish.scale * 0.9, fish.scale * 0.45); // 25% smaller shadow (was 1.2, now 0.9)
                
                // Shadow gradient with dynamic opacity
                const shadowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 75); // 25% smaller radius
                shadowGradient.addColorStop(0, `rgba(0, 0, 0, ${0.3 * fish.shadowOpacity})`);
                shadowGradient.addColorStop(0.7, `rgba(0, 0, 0, ${0.15 * fish.shadowOpacity})`);
                shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = shadowGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, 90, 45, 0, 0, Math.PI * 2); // 25% smaller dimensions
                ctx.fill();
                ctx.restore();
            }
            
            // Now draw the fish much higher up
            ctx.translate(iso.x, iso.y - 864); // Fish floats 864 pixels above its position (20% higher than 720)
            
            // Scale the entire fish and flip if facing left
            if (fish.facingRight) {
                ctx.scale(fish.scale, fish.scale);
            } else {
                ctx.scale(-fish.scale, fish.scale); // Negative X scale flips horizontally
            }
            
            // Body undulation
            const wave1 = Math.sin(fish.bodyWave) * 5;
            const wave2 = Math.sin(fish.bodyWave + Math.PI/3) * 3;
            
            // Create ethereal glow effect
            const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 60);
            glowGradient.addColorStop(0, `rgba(100, 200, 255, ${fish.glowIntensity * 0.5})`);
            glowGradient.addColorStop(0.5, `rgba(80, 150, 255, ${fish.glowIntensity * 0.3})`);
            glowGradient.addColorStop(1, 'rgba(60, 100, 255, 0)');
            
            // Draw outer glow
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.ellipse(0, 0, 80, 40, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw fish body with less transparency
            const bodyGradient = ctx.createLinearGradient(-60, -25, 60, 25);
            bodyGradient.addColorStop(0, 'rgba(150, 200, 255, 0.35)');
            bodyGradient.addColorStop(0.5, 'rgba(180, 220, 255, 0.4)');
            bodyGradient.addColorStop(1, 'rgba(120, 180, 255, 0.35)');
            
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            
            // Fish body shape with undulation - LARGER MAIN BODY
            ctx.moveTo(-50, 0);
            ctx.bezierCurveTo(-38, -20 + wave1, -12, -25 + wave2, 12, -20);
            ctx.bezierCurveTo(25, -16, 38, -10, 50, 0);
            ctx.bezierCurveTo(38, 10, 25, 16, 12, 20);
            ctx.bezierCurveTo(-12, 25 + wave2, -38, 20 + wave1, -50, 0);
            ctx.fill();
            
            // Draw crystalline scales pattern
            ctx.strokeStyle = 'rgba(200, 230, 255, 0.2)';
            ctx.lineWidth = 0.5;
            for (let i = -30; i <= 30; i += 10) {
                ctx.beginPath();
                ctx.moveTo(i, -12);
                ctx.lineTo(i + 5, 0);
                ctx.lineTo(i, 12);
                ctx.stroke();
            }
            
            // Draw the eye
            ctx.save();
            ctx.translate(15, 0); // Closer to center (was 25)
            ctx.rotate(fish.eyeAngle);
            
            // Eye socket
            ctx.fillStyle = 'rgba(30, 50, 80, 0.6)';
            ctx.beginPath();
            ctx.ellipse(0, 0, 18, 18, 0, 0, Math.PI * 2); // Bigger (was 12)
            ctx.fill();
            
            // Eye with tracking
            const eyeGradient = ctx.createRadialGradient(3, -3, 0, 0, 0, 15); // Bigger gradient (was 10)
            eyeGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
            eyeGradient.addColorStop(0.3, 'rgba(150, 200, 255, 0.65)');
            eyeGradient.addColorStop(0.7, 'rgba(80, 120, 200, 0.6)');
            eyeGradient.addColorStop(1, 'rgba(40, 60, 120, 0.5)');
            
            ctx.fillStyle = eyeGradient;
            ctx.beginPath();
            ctx.ellipse(0, 0, 15, 15, 0, 0, Math.PI * 2); // Bigger (was 10)
            ctx.fill();
            
            // Pupil pointing at tracked army
            ctx.fillStyle = 'rgba(20, 30, 60, 0.7)';
            ctx.beginPath();
            ctx.ellipse(6, 0, 6, 9, 0, 0, Math.PI * 2); // Bigger pupil (was 4, 6)
            ctx.fill();
            
            // Eye highlight - counter-rotate to keep it in top-left
            ctx.save();
            ctx.rotate(-fish.eyeAngle); // Counter-rotate to cancel out eye rotation
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(-5, -5, 3, 4.5, 0, 0, Math.PI * 2); // Bigger highlight (was 2, 3)
            ctx.fill();
            ctx.restore();
            
            ctx.restore();
            
            // Draw fins with animation
            const finWave = Math.sin(fish.finWave) * 10;
            
            // Top fin
            ctx.fillStyle = 'rgba(120, 180, 255, 0.25)';
            ctx.beginPath();
            ctx.moveTo(-25, -20);
            ctx.bezierCurveTo(-20, -30 + finWave/2, -5, -33 + finWave, 5, -30);
            ctx.bezierCurveTo(10, -28, 20, -25, 25, -20);
            ctx.lineTo(20, -20);
            ctx.bezierCurveTo(10, -23, 0, -25, -15, -23);
            ctx.lineTo(-25, -20);
            ctx.fill();
            
            // Bottom fin
            ctx.beginPath();
            ctx.moveTo(-25, 20);
            ctx.bezierCurveTo(-20, 30 - finWave/2, -5, 33 - finWave, 5, 30);
            ctx.bezierCurveTo(10, 28, 20, 25, 25, 20);
            ctx.lineTo(20, 20);
            ctx.bezierCurveTo(10, 23, 0, 25, -15, 23);
            ctx.lineTo(-25, 20);
            ctx.fill();
            
            // Tail fin
            ctx.save();
            ctx.translate(-50, 0);
            ctx.rotate(Math.sin(fish.finWave * 1.5) * 0.2);
            
            const tailGradient = ctx.createLinearGradient(-20, 0, 0, 0);
            tailGradient.addColorStop(0, 'rgba(100, 160, 255, 0.15)');
            tailGradient.addColorStop(1, 'rgba(150, 200, 255, 0.3)');
            
            ctx.fillStyle = tailGradient;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.bezierCurveTo(-10, -15, -20, -20, -30, -15);
            ctx.bezierCurveTo(-25, -10, -20, -5, -15, 0);
            ctx.bezierCurveTo(-20, 5, -25, 10, -30, 15);
            ctx.bezierCurveTo(-20, 20, -10, 15, 0, 0);
            ctx.fill();
            
            ctx.restore();
            
            
            ctx.restore();
        }
        
        function renderFishParticle(ctx, particle) {
            const iso = worldToIsometric(particle.x, particle.y);
            
            ctx.save();
            ctx.translate(iso.x, iso.y - 868); // Same height as fish (slightly higher than 864 for particles)
            ctx.globalAlpha = particle.opacity;
            ctx.rotate(particle.rotation);
            
            const size = particle.currentSize || particle.size;
            
            if (particle.type === 'sparkle') {
                // Draw a four-pointed star sparkle
                ctx.strokeStyle = 'rgba(200, 230, 255, 0.8)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                // Vertical line
                ctx.moveTo(0, -size * 2);
                ctx.lineTo(0, size * 2);
                
                // Horizontal line
                ctx.moveTo(-size * 2, 0);
                ctx.lineTo(size * 2, 0);
                
                // Diagonal lines (smaller)
                ctx.moveTo(-size, -size);
                ctx.lineTo(size, size);
                ctx.moveTo(-size, size);
                ctx.lineTo(size, -size);
                
                ctx.stroke();
                
                // Center glow
                const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                glowGradient.addColorStop(0.5, 'rgba(180, 220, 255, 0.4)');
                glowGradient.addColorStop(1, 'rgba(150, 200, 255, 0)');
                
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Draw a ring
                ctx.strokeStyle = 'rgba(150, 200, 255, 0.6)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner smaller ring
                ctx.strokeStyle = 'rgba(200, 230, 255, 0.4)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        // Render witch dark power particle
        function renderWitchDarkPowerParticle(ctx, particle) {
            const centerX = particle.x + Math.cos(particle.angle) * particle.radius;
            const centerY = particle.y + Math.sin(particle.angle) * particle.radius;
            const iso = worldToIsometric(centerX, centerY);
            
            ctx.save();
            ctx.translate(iso.x, iso.y - particle.height);
            ctx.globalAlpha = particle.opacity;
            
            // Dark energy core
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, particle.size);
            gradient.addColorStop(0, particle.color);
            gradient.addColorStop(0.5, particle.color + '80');
            gradient.addColorStop(1, particle.color + '00');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, particle.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Outer glow
            ctx.strokeStyle = particle.color + '60';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, particle.size * 1.5, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        // Render dark power consume particle
        function renderDarkPowerConsumeParticle(ctx, particle) {
            const iso = worldToIsometric(particle.x, particle.y);
            
            ctx.save();
            ctx.translate(iso.x, iso.y);
            ctx.globalAlpha = particle.opacity;
            
            if (particle.flameLike) {
                // Flame-like effect
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.moveTo(0, -particle.size * 2);
                ctx.bezierCurveTo(
                    -particle.size, -particle.size,
                    -particle.size, particle.size,
                    0, particle.size
                );
                ctx.bezierCurveTo(
                    particle.size, particle.size,
                    particle.size, -particle.size,
                    0, -particle.size * 2
                );
                ctx.fill();
            } else {
                // Energy burst
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, particle.size);
                gradient.addColorStop(0, '#FFFFFF');
                gradient.addColorStop(0.3, particle.color);
                gradient.addColorStop(1, particle.color + '00');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, particle.size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // Render witch bones collection
        function renderWitchBones(ctx, witch, world) {
            if ((!witch.bones || witch.bones.length === 0) && (!witch.consumedBones || witch.consumedBones.length === 0)) return;
            
            ctx.save();
            
            // Render static bones
            if (witch.bones) {
                witch.bones.forEach(bone => {
                // Get tile elevation at bone position
                const tileX = Math.floor(bone.x);
                const tileY = Math.floor(bone.y);
                let elevationOffset = 0;
                if (tileX >= 0 && tileX < WORLD_SIZE && tileY >= 0 && tileY < WORLD_SIZE) {
                    const tile = world.tiles[tileX][tileY];
                    if (tile && tile.height) {
                        // Use the same elevation calculation as tiles
                        elevationOffset = (tile.height - 0.65) * 240;
                    }
                }
                
                const iso = worldToIsometric(bone.x, bone.y);
                
                // Draw shadow first
                ctx.save();
                // Shadow offset increases with elevation
                const normalizedElevation = elevationOffset / 240; // Convert back to normalized elevation
                const shadowOffsetX = 2 + normalizedElevation * 0.5;
                const shadowOffsetY = 1 + normalizedElevation * 0.5;
                ctx.translate(iso.x + shadowOffsetX, iso.y - elevationOffset + shadowOffsetY);
                ctx.rotate(bone.rotation);
                ctx.scale(bone.scale, bone.scale);
                ctx.globalAlpha = 0.3 - normalizedElevation * 0.05; // Shadows fade with height
                
                if (bone.type === 'skull') {
                    // Simple skull shadow
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 3, 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Simple bone shadow
                    ctx.fillStyle = '#000';
                    ctx.fillRect(-5, -1, 10, 2);
                }
                ctx.restore();
                
                // Draw bone at elevation
                ctx.save();
                ctx.translate(iso.x, iso.y - elevationOffset);
                ctx.rotate(bone.rotation);
                ctx.scale(bone.scale, bone.scale);
                
                if (bone.type === 'skull') {
                    // Simple abstract skull - dark gray
                    ctx.fillStyle = '#4A4A4A';
                    ctx.strokeStyle = '#2A2A2A';
                    ctx.lineWidth = 1;
                    
                    // Simple round skull
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Two dots for eyes
                    ctx.fillStyle = '#1A1A1A';
                    ctx.beginPath();
                    ctx.arc(-1, -0.5, 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(1, -0.5, 0.5, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Simple abstract bone - dark gray
                    ctx.fillStyle = '#4A4A4A';
                    ctx.strokeStyle = '#2A2A2A';
                    ctx.lineWidth = 1;
                    
                    // Simple stick bone
                    ctx.beginPath();
                    ctx.moveTo(-5, 0);
                    ctx.lineTo(5, 0);
                    ctx.lineTo(4, -1);
                    ctx.lineTo(-4, -1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Rounded ends
                    ctx.beginPath();
                    ctx.arc(-5, -0.5, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(5, -0.5, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
                
                ctx.restore();
                });
            }
            
            // Render consumed bones (being sucked into ritual)
            if (witch.consumedBones) {
                witch.consumedBones.forEach(bone => {
                    // Get tile elevation at bone position
                    const tileX = Math.floor(bone.x);
                    const tileY = Math.floor(bone.y);
                    let elevationOffset = 0;
                    if (tileX >= 0 && tileX < WORLD_SIZE && tileY >= 0 && tileY < WORLD_SIZE) {
                        const tile = world.tiles[tileX][tileY];
                        if (tile && tile.height) {
                            // Use the same elevation calculation as tiles
                            elevationOffset = (tile.height - 0.65) * 240;
                        }
                    }
                    
                    const iso = worldToIsometric(bone.x, bone.y);
                    
                    ctx.save();
                    ctx.translate(iso.x, iso.y - elevationOffset);
                    ctx.rotate(bone.rotation);
                    ctx.scale(bone.scale, bone.scale);
                    ctx.globalAlpha = 1 - bone.progress * 0.5; // Fade as consumed
                    
                    if (bone.type === 'skull') {
                        // Simple skull - dark gray
                        ctx.fillStyle = '#4A4A4A';
                        ctx.beginPath();
                        ctx.arc(0, 0, 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Simple bone - dark gray
                        ctx.fillStyle = '#4A4A4A';
                        ctx.fillRect(-5, -1, 10, 2);
                        ctx.beginPath();
                        ctx.arc(-5, -0.5, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(5, -0.5, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                });
            }
            
            ctx.restore();
        }
        
        // Render witch house/spire
        function renderWitchHouse(ctx, x, y) {
            // Get the Terra world to access tile colors
            const terraWorld = worlds.find(w => w.name === 'Terra');
            if (!terraWorld) return;
            
            // Get tile at witch house location
            const tileX = Math.floor(game.terraWitch.houseX);
            const tileY = Math.floor(game.terraWitch.houseY);
            const tile = terraWorld.tiles[tileX][tileY];
            
            // Get world RGB values
            let worldRGB = gradientCache.worldRGB.get(terraWorld.color);
            if (!worldRGB) {
                const hex = terraWorld.color.substring(1);
                worldRGB = {
                    r: parseInt(hex.substring(0, 2), 16),
                    g: parseInt(hex.substring(2, 4), 16),
                    b: parseInt(hex.substring(4, 6), 16)
                };
                gradientCache.worldRGB.set(terraWorld.color, worldRGB);
            }
            
            // Calculate base tile brightness
            const tileBrightness = 0.6 + tile.elevation * 0.4;
            
            // Apply Terra darkness if active
            let terraDarkening = 1;
            if (game.terraDarkness.transitionProgress > 0) {
                terraDarkening = 1 - (game.terraDarkness.transitionProgress * 0.7);
            }
            
            // Draw shadow (offset to top-right like capital)
            ctx.save();
            // Make shadow darker during dark phase
            const shadowOpacity = game.terraDarkness.transitionProgress > 0 ? 
                0.3 + (game.terraDarkness.transitionProgress * 0.3) : 0.3;
            ctx.fillStyle = `rgba(0, 0, 0, ${shadowOpacity})`;
            ctx.beginPath();
            ctx.ellipse(x + 14, y - 10, 20, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Draw stone spire base (twisted/spiral)
            const spireHeight = 60;
            const spireWidth = 10.5; // 30% thinner than original
            
            ctx.save();
            
            // Draw twisted spire segments from bottom to top so upper floors render above
            for (let i = 0; i < 6; i++) {
                // Floor heights: bottom = 12, middle 4 floors = 10 (average), top = 12
                let segmentHeight;
                if (i === 0) {
                    segmentHeight = 12; // Bottom floor
                } else if (i === 5) {
                    segmentHeight = 12; // Top floor
                } else {
                    segmentHeight = 10; // Middle 4 floors all same height (average)
                }
                let yOffset, yOffsetTop;
                if (i === 0) {
                    yOffset = y;
                    yOffsetTop = y - segmentHeight;
                } else {
                    yOffset = y;
                    for (let j = 0; j < i; j++) {
                        let floorHeight;
                        if (j === 0) {
                            floorHeight = 12;
                        } else if (j === 5) {
                            floorHeight = 12;
                        } else {
                            floorHeight = 10;
                        }
                        yOffset -= floorHeight - 1; // Subtract 1 for overlap
                    }
                    yOffsetTop = yOffset - segmentHeight;
                }
                
                // Calculate twist for bottom and top of segment
                const twistBottom = Math.sin(i * 0.8) * 4;
                const twistTop = Math.sin((i + 1) * 0.8) * 4;
                
                // Make bottom floor wider with curved base
                let bottomWidth = spireWidth;
                let topWidth = spireWidth;
                if (i === 0) {
                    bottomWidth = spireWidth * 1.3; // 30% wider at bottom
                }
                if (i === 5) {
                    topWidth = spireWidth * 1.2; // 20% wider at top
                }
                
                // Use tile color with progressive darkening
                let r, g, b;
                if (i === 0) {
                    // Bottom floor: average of second floor and tile color
                    const secondFloorBrightness = tileBrightness * (1 - (1 * 0.08));
                    const avgBrightness = (tileBrightness + secondFloorBrightness) / 2;
                    r = Math.floor(worldRGB.r * avgBrightness * terraDarkening);
                    g = Math.floor(worldRGB.g * avgBrightness * terraDarkening);
                    b = Math.floor(worldRGB.b * avgBrightness * terraDarkening);
                } else {
                    // Other floors: progressive darkening
                    const segmentBrightness = tileBrightness * (1 - (i * 0.08));
                    r = Math.floor(worldRGB.r * segmentBrightness * terraDarkening);
                    g = Math.floor(worldRGB.g * segmentBrightness * terraDarkening);
                    b = Math.floor(worldRGB.b * segmentBrightness * terraDarkening);
                }
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.beginPath();
                
                // Top 5 floors have curved bottom edge
                if (i > 0) {
                    // Floors 1-5: curved bottom
                    ctx.moveTo(x - bottomWidth + twistBottom, yOffset);
                    ctx.quadraticCurveTo(x + twistBottom, yOffset + 3, x + bottomWidth + twistBottom, yOffset);
                    ctx.lineTo(x + topWidth + twistTop, yOffsetTop);
                    ctx.lineTo(x - topWidth + twistTop, yOffsetTop);
                    ctx.closePath();
                } else {
                    // Floor 0 (bottom): curved bottom
                    ctx.moveTo(x - bottomWidth + twistBottom, yOffset);
                    ctx.quadraticCurveTo(x + twistBottom, yOffset + 3, x + bottomWidth + twistBottom, yOffset);
                    ctx.lineTo(x + topWidth + twistTop, yOffsetTop);
                    ctx.lineTo(x - topWidth + twistTop, yOffsetTop);
                    ctx.closePath();
                }
                ctx.fill();
            }
            
            // Draw horizontal oval cap on top of spire (before house)
            const topSegmentTwist = Math.sin(6 * 0.8) * 4;
            const ovalWidth = spireWidth * 1.2;
            // Calculate actual spire height based on progressive floor heights
            let actualSpireHeight = 0;
            for (let j = 0; j < 6; j++) {
                let floorHeight;
                if (j === 0 || j === 5) {
                    floorHeight = 12;
                } else {
                    floorHeight = 10;
                }
                actualSpireHeight += floorHeight - (j > 0 ? 1 : 0);
            }
            // Make oval slightly brighter than top floor - top floor is at 0.6, so oval at 0.62
            // Apply darkness during dark phase
            const ovalBrightness = 0.62 * terraDarkening;
            ctx.fillStyle = `rgb(${Math.floor(worldRGB.r * tileBrightness * ovalBrightness)}, ${Math.floor(worldRGB.g * tileBrightness * ovalBrightness)}, ${Math.floor(worldRGB.b * tileBrightness * ovalBrightness)})`;
            ctx.beginPath();
            ctx.ellipse(x + topSegmentTwist, y - actualSpireHeight, ovalWidth, ovalWidth * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Wooden house on top (render in front of oval and spire)
            // Keep the same transformation context to ensure proper layering
            const topTwist = Math.sin(6 * 0.8) * 4; // Twist position for the top
            const houseX = x + topTwist; // Align house with top of spire
            // Calculate actual spire height for house placement
            let houseSpireHeight = 0;
            for (let j = 0; j < 6; j++) {
                let floorHeight;
                if (j === 0 || j === 5) {
                    floorHeight = 12;
                } else {
                    floorHeight = 10;
                }
                houseSpireHeight += floorHeight - (j > 0 ? 1 : 0);
            }
            const houseY = y - houseSpireHeight;
            const houseWidth = 16; // Wider for more imposing look
            const houseHeight = 10; // Shorter body
            
            // Crooked house walls (lighter purple-grey wood)
            const wallRGB = {r: 70, g: 50, b: 80}; // Lighter purple-grey
            ctx.fillStyle = `rgb(${Math.floor(wallRGB.r * terraDarkening)}, ${Math.floor(wallRGB.g * terraDarkening)}, ${Math.floor(wallRGB.b * terraDarkening)})`;
            
            // Make house slightly crooked
            ctx.save();
            ctx.translate(houseX, houseY);
            ctx.rotate(-0.05); // Slight tilt
            ctx.translate(-houseX, -houseY);
            
            // Main structure with irregular shape
            ctx.beginPath();
            ctx.moveTo(houseX - houseWidth/2, houseY);
            ctx.lineTo(houseX - houseWidth/2 - 1, houseY - houseHeight * 0.7);
            ctx.lineTo(houseX - houseWidth/2 + 2, houseY - houseHeight);
            ctx.lineTo(houseX + houseWidth/2 - 1, houseY - houseHeight);
            ctx.lineTo(houseX + houseWidth/2 + 1, houseY - houseHeight * 0.8);
            ctx.lineTo(houseX + houseWidth/2, houseY);
            ctx.closePath();
            ctx.fill();
            
            // Twisted wooden planks
            const plankRGB = {r: 50, g: 35, b: 60};
            ctx.strokeStyle = `rgb(${Math.floor(plankRGB.r * terraDarkening)}, ${Math.floor(plankRGB.g * terraDarkening)}, ${Math.floor(plankRGB.b * terraDarkening)})`;
            ctx.lineWidth = 1;
            for (let i = -8; i <= 8; i += 3) {
                ctx.beginPath();
                const wobble = Math.sin(i * 0.5) * 2;
                ctx.moveTo(houseX + i + wobble, houseY - houseHeight);
                ctx.lineTo(houseX + i - wobble, houseY);
                ctx.stroke();
            }
            
            ctx.restore();
            
            // Crooked peaked roof with multiple angles
            const roofRGB = {r: 45, g: 30, b: 50}; // Lighter purple roof
            ctx.fillStyle = `rgb(${Math.floor(roofRGB.r * terraDarkening)}, ${Math.floor(roofRGB.g * terraDarkening)}, ${Math.floor(roofRGB.b * terraDarkening)})`;
            ctx.beginPath();
            ctx.moveTo(houseX - houseWidth/2 - 4, houseY - houseHeight + 1);
            ctx.lineTo(houseX - houseWidth/4, houseY - houseHeight - 9);
            ctx.lineTo(houseX + 2, houseY - houseHeight - 12); // Higher peak off-center
            ctx.lineTo(houseX + houseWidth/3, houseY - houseHeight - 7);
            ctx.lineTo(houseX + houseWidth/2 + 4, houseY - houseHeight + 1);
            ctx.closePath();
            ctx.fill();
            
            // Arched door
            const doorRGB = {r: 30, g: 20, b: 40};
            ctx.fillStyle = `rgb(${Math.floor(doorRGB.r * terraDarkening)}, ${Math.floor(doorRGB.g * terraDarkening)}, ${Math.floor(doorRGB.b * terraDarkening)})`;
            // Door arch
            ctx.beginPath();
            ctx.moveTo(houseX - 4, houseY);
            ctx.lineTo(houseX - 4, houseY - 9);
            ctx.arc(houseX, houseY - 9, 4, Math.PI, 0, true);
            ctx.lineTo(houseX + 4, houseY);
            ctx.closePath();
            ctx.fill();
            
            // Scary windows - triangular/diamond shaped
            if (game.terraWitch.phase === 'in_house') {
                // Glowing eerie green-yellow windows
                ctx.fillStyle = '#BFFF00';
                ctx.globalAlpha = 0.9;
                
                // Left eye-like window
                ctx.beginPath();
                ctx.moveTo(houseX - 6, houseY - houseHeight + 4);
                ctx.lineTo(houseX - 4, houseY - houseHeight + 6);
                ctx.lineTo(houseX - 6, houseY - houseHeight + 8);
                ctx.lineTo(houseX - 8, houseY - houseHeight + 6);
                ctx.closePath();
                ctx.fill();
                
                // Right eye-like window
                ctx.beginPath();
                ctx.moveTo(houseX + 6, houseY - houseHeight + 4);
                ctx.lineTo(houseX + 8, houseY - houseHeight + 6);
                ctx.lineTo(houseX + 6, houseY - houseHeight + 8);
                ctx.lineTo(houseX + 4, houseY - houseHeight + 6);
                ctx.closePath();
                ctx.fill();
                
                // Sinister window glow
                ctx.globalAlpha = 0.3;
                const glowSize = 12 + Math.sin(Date.now() * 0.003) * 3;
                const windowGlow = ctx.createRadialGradient(houseX, houseY - houseHeight + 6, 0, houseX, houseY - houseHeight + 6, glowSize);
                windowGlow.addColorStop(0, '#BFFF00');
                windowGlow.addColorStop(0.5, '#80FF00');
                windowGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = windowGlow;
                ctx.fillRect(houseX - glowSize, houseY - houseHeight + 6 - glowSize, glowSize * 2, glowSize * 2);
                ctx.globalAlpha = 1;
            } else {
                // Dark empty eye sockets when witch is out
                const darkWindowRGB = {r: 20, g: 15, b: 30};
                ctx.fillStyle = `rgb(${Math.floor(darkWindowRGB.r * terraDarkening)}, ${Math.floor(darkWindowRGB.g * terraDarkening)}, ${Math.floor(darkWindowRGB.b * terraDarkening)})`;
                
                // Left window
                ctx.beginPath();
                ctx.moveTo(houseX - 6, houseY - houseHeight + 4);
                ctx.lineTo(houseX - 4, houseY - houseHeight + 6);
                ctx.lineTo(houseX - 6, houseY - houseHeight + 8);
                ctx.lineTo(houseX - 8, houseY - houseHeight + 6);
                ctx.closePath();
                ctx.fill();
                
                // Right window
                ctx.beginPath();
                ctx.moveTo(houseX + 6, houseY - houseHeight + 4);
                ctx.lineTo(houseX + 8, houseY - houseHeight + 6);
                ctx.lineTo(houseX + 6, houseY - houseHeight + 8);
                ctx.lineTo(houseX + 4, houseY - houseHeight + 6);
                ctx.closePath();
                ctx.fill();
            }
            
            // Crooked chimney
            const chimneyRGB = {r: 60, g: 50, b: 65};
            ctx.fillStyle = `rgb(${Math.floor(chimneyRGB.r * terraDarkening)}, ${Math.floor(chimneyRGB.g * terraDarkening)}, ${Math.floor(chimneyRGB.b * terraDarkening)})`;
            ctx.beginPath();
            ctx.moveTo(houseX + houseWidth/2 - 2, houseY - houseHeight);
            ctx.lineTo(houseX + houseWidth/2 - 3, houseY - houseHeight - 7);
            ctx.lineTo(houseX + houseWidth/2 - 1, houseY - houseHeight - 8);
            ctx.lineTo(houseX + houseWidth/2 + 1, houseY - houseHeight - 6);
            ctx.lineTo(houseX + houseWidth/2, houseY - houseHeight);
            ctx.closePath();
            ctx.fill();
            
            // Add spooky details - weathervane
            ctx.strokeStyle = `rgb(${Math.floor(40 * terraDarkening)}, ${Math.floor(40 * terraDarkening)}, ${Math.floor(40 * terraDarkening)})`;
            ctx.lineWidth = 1;
            // Crooked weathervane on roof
            ctx.beginPath();
            ctx.moveTo(houseX + 2, houseY - houseHeight - 12);
            ctx.lineTo(houseX + 2, houseY - houseHeight - 16);
            ctx.stroke();
            // Bat-like shape
            ctx.fillStyle = `rgb(${Math.floor(30 * terraDarkening)}, ${Math.floor(25 * terraDarkening)}, ${Math.floor(40 * terraDarkening)})`;
            ctx.beginPath();
            ctx.moveTo(houseX + 2, houseY - houseHeight - 16);
            ctx.lineTo(houseX - 2, houseY - houseHeight - 15);
            ctx.lineTo(houseX, houseY - houseHeight - 14);
            ctx.lineTo(houseX + 2, houseY - houseHeight - 15);
            ctx.lineTo(houseX + 6, houseY - houseHeight - 15);
            ctx.lineTo(houseX + 4, houseY - houseHeight - 14);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore(); // End all spire/house drawing
            
            // Draw smoke particles (like nomad campfire)
            if (game.terraWitch.smokeParticles.length > 0) {
                // Calculate spire and house heights for smoke positioning
                const topTwist = Math.sin(6 * 0.8) * 4;
                let spireHeight = 0;
                for (let j = 0; j < 6; j++) {
                    const floorHeight = (j === 0 || j === 5) ? 12 : 10;
                    spireHeight += floorHeight - (j > 0 ? 1 : 0);
                }
                const houseHeight = 10.5; // 30% shorter
                const houseWidth = 14; // 30% thinner
                const chimneyHeight = 5.6; // 30% shorter
                
                // Chimney X position on the twisted spire
                const chimneyX = x + topTwist + houseWidth/2 - 3.5 + 1.4; // +1.4 to center smoke in 2.8-wide chimney
                const chimneyTop = y - spireHeight - houseHeight - chimneyHeight;
                
                game.terraWitch.smokeParticles.forEach(particle => {
                    const opacity = (1 - particle.age / particle.maxAge) * 0.3;
                    const size = particle.size * (1 + particle.age / particle.maxAge * 2);
                    
                    // Calculate smoke drift from the chimney position
                    const driftX = particle.vx * particle.age * 50;
                    const driftY = particle.vy * particle.age * 50;
                    
                    ctx.save();
                    // Position smoke relative to actual chimney position
                    ctx.translate(chimneyX + driftX, chimneyTop - particle.age * 0.8 + driftY);
                    ctx.fillStyle = `rgba(60, 60, 60, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }
        }
        
        // Render witch in other worlds
        // renderWorldWitch function removed - only Terra has a witch
        function renderWorldWitch_removed(ctx, witch, world) {
            const iso = worldToIsometric(witch.x, witch.y);
            const actualHeight = witch.currentHeight + witch.bobOffset;
            
            ctx.save();
            
            // Render magic circle during bone ritual
            if ((witch.phase === 'bone_ritual_channeling' || witch.phase === 'portal_ritual_channeling') && witch.magicCircleRadius > 0) {
                renderBoneRitualMagicCircle(ctx, witch, world);
            }
            
            // Draw shadow
            if (witch.phase !== 'in_house' && witch.phase !== 'waiting') {
                const tileX = Math.floor(witch.x);
                const tileY = Math.floor(witch.y);
                if (tileX >= 0 && tileX < WORLD_SIZE && tileY >= 0 && tileY < WORLD_SIZE) {
                    const tile = world.tiles[tileX][tileY];
                    if (tile && tile.elevation > 0) {
                        ctx.save();
                        ctx.fillStyle = `rgba(0, 0, 0, ${0.2 * witch.shadowOpacity})`;
                        ctx.translate(iso.x, iso.y);
                        ctx.beginPath();
                        ctx.ellipse(0, 3, 12 * witch.scale, 6 * witch.scale, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
            }
            
            // Transform for witch position
            ctx.translate(iso.x, iso.y - actualHeight);
            ctx.scale(witch.scale, witch.scale);
            
            // Handle sprite flipping
            if (!witch.facingRight) {
                ctx.scale(-1, 1);
            }
            
            // Witch body/robe (dark purple for other worlds)
            ctx.fillStyle = world.name === 'Ignis' ? '#8B0000' : 
                           world.name === 'Aqua' ? '#000080' : 
                           world.name === 'Aether' ? '#4B0082' : '#2A0845';
            ctx.beginPath();
            ctx.moveTo(0, -8);
            ctx.lineTo(-8, 8);
            ctx.lineTo(8, 8);
            ctx.closePath();
            ctx.fill();
            
            // Witch hat
            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.moveTo(0, -15);
            ctx.lineTo(-5, -8);
            ctx.lineTo(5, -8);
            ctx.closePath();
            ctx.fill();
            
            // Hat brim
            ctx.fillRect(-7, -8, 14, 2);
            
            // Hat tip (bent)
            ctx.save();
            ctx.translate(0, -15);
            ctx.rotate(witch.facingRight ? 0.3 : -0.3);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-2, -5);
            ctx.lineTo(2, -5);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // Face
            ctx.fillStyle = '#D4A76A';
            ctx.beginPath();
            ctx.arc(0, -5, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Hair (long black)
            ctx.save();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1.5;
            ctx.globalAlpha = 0.9;
            
            // Hair strands flowing back (scaled for world witch size)
            const hairSway = Math.sin(witch.bobPhase * 2) * 0.5;
            const windEffect = witch.currentSpeed * 3;
            
            for (let i = 0; i < 5; i++) {
                const angle = -2.7 + i * 0.3;
                const lengthVariation = 5 + i * 0.8;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * 3, -6 + Math.sin(angle) * 1);
                // Control points for flowing hair
                const cp1x = Math.cos(angle) * 6 - windEffect;
                const cp1y = -3 + hairSway;
                const cp2x = Math.cos(angle) * 8 - windEffect * 1.5;
                const cp2y = 2 + hairSway * 1.5;
                const endX = Math.cos(angle) * 10 - windEffect * 2 + hairSway;
                const endY = 5 + lengthVariation + hairSway * 2;
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                ctx.stroke();
            }
            ctx.restore();
            
            // Broom
            ctx.save();
            ctx.translate(0, 5);
            ctx.rotate(witch.broomTilt);
            
            // Broom stick
            ctx.strokeStyle = '#4A2C17';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-15, 0);
            ctx.lineTo(10, 0);
            ctx.stroke();
            
            // Broom bristles
            ctx.strokeStyle = '#8B6914';
            ctx.lineWidth = 1;
            for (let i = -3; i <= 3; i++) {
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.lineTo(15, i * 2);
                ctx.stroke();
            }
            
            ctx.restore();
            
            // Dark power glow during ritual
            if (witch.darkPowerCharge > 0) {
                ctx.save();
                ctx.globalAlpha = witch.darkPowerCharge * 0.5;
                const glowColor = world.name === 'Ignis' ? 'rgba(139, 0, 0, 0.5)' : 
                                 world.name === 'Aqua' ? 'rgba(0, 0, 128, 0.5)' : 
                                 world.name === 'Aether' ? 'rgba(75, 0, 130, 0.5)' : 'rgba(42, 8, 69, 0.5)';
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = 20;
                ctx.fillStyle = glowColor;
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            ctx.restore();
            
            // Render smoke particles
            witch.smokeParticles.forEach(particle => {
                const particleIso = worldToIsometric(particle.x, particle.y);
                const opacity = (1 - particle.age / particle.maxAge) * 0.3;
                const size = particle.size * (1 + particle.age / particle.maxAge);
                
                ctx.save();
                ctx.fillStyle = `rgba(80, 80, 80, ${opacity})`;
                ctx.translate(particleIso.x, particleIso.y - particle.age * 0.5);
                ctx.beginPath();
                ctx.arc(0, 0, size * 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
            
            // Render bones around spire if any
            if (witch.hasHouse) {
                witch.bones.forEach(bone => {
                    renderBone(ctx, bone, world);
                });
                
                // Render consumed bones during ritual
                witch.consumedBones.forEach(bone => {
                    const boneIso = worldToIsometric(bone.x, bone.y);
                    const heightOffset = 20 + bone.progress * 40;
                    
                    ctx.save();
                    ctx.translate(boneIso.x, boneIso.y - heightOffset);
                    ctx.globalAlpha = 1 - bone.progress * 0.5;
                    ctx.scale(bone.scale, bone.scale);
                    ctx.rotate(bone.rotation + bone.progress * Math.PI);
                    
                    // Add glow effect
                    ctx.shadowColor = 'rgba(128, 0, 128, 0.8)';
                    ctx.shadowBlur = 10 * (1 + bone.progress);
                    
                    if (bone.type === 'skull') {
                        ctx.fillStyle = '#E8DCC0';
                        ctx.beginPath();
                        ctx.arc(0, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#222';
                        ctx.fillRect(-3, -2, 2, 3);
                        ctx.fillRect(1, -2, 2, 3);
                        ctx.fillRect(-1, 1, 2, 2);
                    } else {
                        ctx.strokeStyle = '#E8DCC0';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(-10, 0);
                        ctx.lineTo(10, 0);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.arc(-10, 0, 3, 0, Math.PI * 2);
                        ctx.arc(10, 0, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                });
            }
            
            // Render witch house with smoke
            if (witch.hasHouse && witch.smokeParticles.length > 0) {
                const houseX = Math.floor(witch.houseX);
                const houseY = Math.floor(witch.houseY);
                const chimneyOffset = 12;
                const chimneyIso = worldToIsometric(houseX + 0.5, houseY + 0.5);
                const chimneyX = chimneyIso.x + chimneyOffset;
                const chimneyTop = chimneyIso.y - 45;
                
                witch.smokeParticles.forEach(particle => {
                    const opacity = (1 - particle.age / particle.maxAge) * 0.3;
                    const size = particle.size * (1 + particle.age / particle.maxAge * 2);
                    
                    const driftX = particle.vx * particle.age * 50;
                    const driftY = particle.vy * particle.age * 50;
                    
                    ctx.save();
                    ctx.translate(chimneyX + driftX, chimneyTop - particle.age * 0.8 + driftY);
                    ctx.fillStyle = `rgba(60, 60, 60, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }
            
            // Render smoke trail
            if (witch.smokeTrail.length > 1) {
                ctx.save();
                
                // Draw smoke trail as connected path
                for (let i = 0; i < witch.smokeTrail.length - 1; i++) {
                    const point = witch.smokeTrail[i];
                    const nextPoint = witch.smokeTrail[i + 1];
                    const alpha = 1 - (point.age / 60);
                    
                    const pointIso = worldToIsometric(point.x, point.y);
                    const nextPointIso = worldToIsometric(nextPoint.x, nextPoint.y);
                    
                    // Create gradient for each segment
                    const gradient = ctx.createLinearGradient(
                        pointIso.x, pointIso.y - witch.currentHeight,
                        nextPointIso.x, nextPointIso.y - witch.currentHeight
                    );
                    
                    gradient.addColorStop(0, `rgba(138, 43, 226, ${alpha * 0.3})`); // Purple with transparency
                    gradient.addColorStop(1, `rgba(138, 43, 226, ${alpha * 0.1})`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = point.size * 10 * (1 - i / witch.smokeTrail.length); // Taper the trail
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(pointIso.x, pointIso.y - witch.currentHeight);
                    ctx.lineTo(nextPointIso.x, nextPointIso.y - witch.currentHeight);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }
        
        // Render magic circle for bone ritual
        function renderBoneRitualMagicCircle(ctx, witch, world) {
            const centerIso = worldToIsometric(witch.houseX, witch.houseY);
            
            ctx.save();
            ctx.translate(centerIso.x, centerIso.y);
            ctx.rotate(witch.magicCircleRotation);
            
            const radius = witch.magicCircleRadius * 20; // Convert world units to pixels
            
            // Glow effect - multiple layers
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#8B00FF';
            
            // Outer glow ring
            ctx.strokeStyle = '#FF00FF';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 1.15, 0, Math.PI * 2);
            ctx.stroke();
            
            // Main outer circle with glow
            ctx.strokeStyle = '#8B00FF';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.9;
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner circle with glow
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.7;
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.8, 0, Math.PI * 2);
            ctx.stroke();
            
            // Pentagram with glow
            ctx.strokeStyle = '#FF00FF';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.8;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#FF00FF';
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                const x = Math.cos(angle) * radius * 0.6;
                const y = Math.sin(angle) * radius * 0.6;
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    // Draw to every second point to create a star
                    const nextAngle = ((i * 2) % 5) * 2 * Math.PI / 5 - Math.PI / 2;
                    const nextX = Math.cos(nextAngle) * radius * 0.6;
                    const nextY = Math.sin(nextAngle) * radius * 0.6;
                    ctx.lineTo(nextX, nextY);
                }
            }
            ctx.closePath();
            ctx.stroke();
            
            // Runes around the circle with glow
            ctx.fillStyle = '#FF00FF';
            ctx.globalAlpha = 1;
            ctx.font = 'bold 14px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#FF00FF';
            
            const runes = ['☠', '✦', '⚡', '☽', '✧', '☣', '⬟', '☆'];
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI / 4);
                const runeX = Math.cos(angle) * radius * 0.9;
                const runeY = Math.sin(angle) * radius * 0.9;
                
                ctx.save();
                ctx.translate(runeX, runeY);
                ctx.rotate(-witch.magicCircleRotation); // Counter-rotate to keep runes upright
                // Pulsing glow for runes
                const runePulse = 0.7 + Math.sin(witch.boneRitualTimer * 0.05 + i) * 0.3;
                ctx.globalAlpha = runePulse;
                ctx.fillText(runes[i], 0, 0);
                ctx.restore();
            }
            
            // Energy pulses with enhanced glow
            const pulseAlpha = 0.2 + Math.sin(witch.boneRitualTimer * 0.1) * 0.3;
            ctx.strokeStyle = '#FF00FF';
            ctx.lineWidth = 2;
            ctx.shadowBlur = 25;
            ctx.shadowColor = '#8B00FF';
            
            for (let i = 0; i < 3; i++) {
                const pulseRadius = radius * (1.1 + i * 0.15);
                ctx.globalAlpha = pulseAlpha * (1 - i * 0.3); // Fade outer pulses
                ctx.beginPath();
                ctx.arc(0, 0, pulseRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Add central glow
            const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 0.5);
            glowGradient.addColorStop(0, `rgba(139, 0, 255, ${0.3 * pulseAlpha})`);
            glowGradient.addColorStop(0.5, `rgba(255, 0, 255, ${0.2 * pulseAlpha})`);
            glowGradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
            ctx.fillStyle = glowGradient;
            ctx.globalAlpha = 1;
            ctx.fillRect(-radius, -radius, radius * 2, radius * 2);
            
            ctx.restore();
        }
        
        // Render army death smoke effect
        function renderArmyDeathSmoke(ctx, effect) {
            ctx.save();
            ctx.translate(effect.x, effect.y);
            
            // Render smoke particles
            effect.particles.forEach(particle => {
                const alpha = (particle.life / particle.maxLife) * 0.6;
                const size = particle.size * (1 + (1 - particle.life / particle.maxLife) * 0.5);
                
                // Smoke gradient
                const gradient = ctx.createRadialGradient(
                    particle.x, particle.y, 0,
                    particle.x, particle.y, size
                );
                gradient.addColorStop(0, `rgba(80, 80, 80, ${alpha})`);
                gradient.addColorStop(0.5, `rgba(120, 120, 120, ${alpha * 0.7})`);
                gradient.addColorStop(1, `rgba(150, 150, 150, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.restore();
        }
        
        // Render red god ray effect for war
        function renderRedGodRay(ctx, effect) {
            const iso = worldToIsometric(effect.x, effect.y);
            ctx.save();
            ctx.translate(iso.x, iso.y);
            
            // Calculate fade in/out
            const progress = effect.currentTick / effect.duration;
            let fadeFactor = 1;
            if (progress < 0.1) {
                // Fade in during first 10%
                fadeFactor = progress / 0.1;
            } else if (progress > 0.9) {
                // Fade out during last 10%
                fadeFactor = (1 - progress) / 0.1;
            }
            
            // Draw main beam
            const beamGradient = ctx.createLinearGradient(0, -500, 0, 40); // Taller and extends below capital
            beamGradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
            beamGradient.addColorStop(0.3, `rgba(255, 50, 50, ${0.1 * fadeFactor})`); // Apply fade
            beamGradient.addColorStop(0.7, `rgba(255, 100, 100, ${0.2 * fadeFactor})`); // Apply fade
            beamGradient.addColorStop(1, `rgba(255, 150, 150, ${0.3 * fadeFactor})`); // Apply fade
            
            ctx.fillStyle = beamGradient;
            ctx.beginPath();
            ctx.moveTo(-effect.beamWidth/2, 40); // Start below capital
            ctx.lineTo(-effect.beamWidth/3, -500); // Left side up
            ctx.lineTo(effect.beamWidth/3, -500); // Top edge
            ctx.lineTo(effect.beamWidth/2, 40); // Right side down
            // Curved bottom edge
            ctx.quadraticCurveTo(0, 60, -effect.beamWidth/2, 40);
            ctx.closePath();
            ctx.fill();
            
            // Draw particles
            effect.particles.forEach(particle => {
                const particleAlpha = particle.opacity * (1 - effect.currentTick / effect.duration) * fadeFactor;
                ctx.fillStyle = `rgba(255, 100, 100, ${particleAlpha})`;
                ctx.beginPath();
                ctx.arc(particle.offsetX, particle.height, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw pulsing glow at base
            const pulseAlpha = (0.3 + Math.sin(effect.currentTick * 0.1) * 0.2) * fadeFactor;
            const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, effect.beamWidth);
            glowGradient.addColorStop(0, `rgba(255, 100, 100, ${pulseAlpha})`);
            glowGradient.addColorStop(1, 'rgba(255, 100, 100, 0)');
            
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(0, 0, effect.beamWidth, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Render golden god ray effect for peace
        function renderGoldenGodRay(ctx, effect) {
            const iso = worldToIsometric(effect.x, effect.y);
            ctx.save();
            ctx.translate(iso.x, iso.y);
            
            // Calculate fade in/out
            const progress = effect.currentTick / effect.duration;
            let fadeFactor = 1;
            if (progress < 0.1) {
                // Fade in during first 10%
                fadeFactor = progress / 0.1;
            } else if (progress > 0.9) {
                // Fade out during last 10%
                fadeFactor = (1 - progress) / 0.1;
            }
            
            // Draw main beam
            const beamGradient = ctx.createLinearGradient(0, -500, 0, 40); // Taller and extends below capital
            beamGradient.addColorStop(0, 'rgba(255, 223, 186, 0)');
            beamGradient.addColorStop(0.3, `rgba(255, 235, 205, ${0.15 * fadeFactor})`); // Apply fade
            beamGradient.addColorStop(0.7, `rgba(255, 223, 186, ${0.25 * fadeFactor})`); // Apply fade
            beamGradient.addColorStop(1, `rgba(255, 215, 170, ${0.35 * fadeFactor})`); // Apply fade
            
            ctx.fillStyle = beamGradient;
            ctx.beginPath();
            ctx.moveTo(-effect.beamWidth/2, 40); // Start below capital
            ctx.lineTo(-effect.beamWidth/3, -500); // Left side up
            ctx.lineTo(effect.beamWidth/3, -500); // Top edge
            ctx.lineTo(effect.beamWidth/2, 40); // Right side down
            // Curved bottom edge
            ctx.quadraticCurveTo(0, 60, -effect.beamWidth/2, 40);
            ctx.closePath();
            ctx.fill();
            
            // Draw particles with shimmer effect
            effect.particles.forEach(particle => {
                const particleAlpha = particle.opacity * (1 - effect.currentTick / effect.duration) * fadeFactor;
                const shimmerScale = 1 + Math.sin(particle.shimmer) * 0.3;
                
                // Create gradient for each particle
                const particleGradient = ctx.createRadialGradient(
                    particle.offsetX, particle.height, 0,
                    particle.offsetX, particle.height, particle.size * shimmerScale
                );
                particleGradient.addColorStop(0, `rgba(255, 255, 220, ${particleAlpha})`);
                particleGradient.addColorStop(0.5, `rgba(255, 235, 205, ${particleAlpha * 0.7})`);
                particleGradient.addColorStop(1, `rgba(255, 223, 186, 0)`);
                
                ctx.fillStyle = particleGradient;
                ctx.beginPath();
                ctx.arc(particle.offsetX, particle.height, particle.size * shimmerScale, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw pulsing glow at base
            const pulseAlpha = (0.4 + Math.sin(effect.currentTick * 0.08) * 0.3) * fadeFactor;
            const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, effect.beamWidth * 1.5);
            glowGradient.addColorStop(0, `rgba(255, 235, 205, ${pulseAlpha})`);
            glowGradient.addColorStop(0.5, `rgba(255, 223, 186, ${pulseAlpha * 0.5})`);
            glowGradient.addColorStop(1, 'rgba(255, 215, 170, 0)');
            
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(0, 0, effect.beamWidth * 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Render terraform effect
        function renderTerraformEffect(ctx, effect) {
            const iso = worldToIsometric(effect.x, effect.y);
            ctx.save();
            ctx.translate(iso.x, iso.y);
            
            // Draw ripples
            effect.ripples.forEach(ripple => {
                if (ripple.opacity > 0.01) {
                    ctx.strokeStyle = `rgba(139, 69, 19, ${ripple.opacity})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, ripple.radius * 1.5, ripple.radius * 0.75, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
            
            // Draw earth particles
            const particleCount = 8;
            const angle = (effect.currentTick / effect.duration) * Math.PI * 2;
            for (let i = 0; i < particleCount; i++) {
                const particleAngle = (i / particleCount) * Math.PI * 2 + angle;
                const distance = 20 + Math.sin(effect.currentTick * 0.1 + i) * 10;
                const x = Math.cos(particleAngle) * distance;
                const y = Math.sin(particleAngle) * distance * 0.5;
                const size = 3 + Math.sin(effect.currentTick * 0.2 + i * 2) * 2;
                const opacity = Math.max(0, 1 - (effect.currentTick / effect.duration));
                
                ctx.fillStyle = `rgba(160, 82, 45, ${opacity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function renderSculptEffect(ctx, effect) {
            ctx.save();
            ctx.translate((effect.x + camera.x) * camera.zoom + canvas.width / 2,
                         (effect.y + camera.y) * camera.zoom + canvas.height / 2);
            
            // Draw particles
            effect.particles.forEach(particle => {
                if (particle.opacity > 0.01) {
                    ctx.globalAlpha = particle.opacity;
                    ctx.fillStyle = effect.color;
                    ctx.beginPath();
                    ctx.arc(particle.x * camera.zoom, particle.y * camera.zoom, 
                           particle.size * camera.zoom, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            ctx.restore();
        }
        
        // Render kingdom creation effect
        function renderKingdomCreationEffect(ctx, effect) {
            const iso = worldToIsometric(effect.x, effect.y);
            ctx.save();
            ctx.translate(iso.x, iso.y - 20); // Elevate effect
            
            // Draw crown
            if (effect.crownSize > 0) {
                const crownAlpha = Math.min(1, (effect.duration - effect.currentTick) / 30);
                
                // Crown base
                ctx.fillStyle = `rgba(255, 215, 0, ${crownAlpha})`;
                ctx.strokeStyle = `rgba(184, 134, 11, ${crownAlpha})`;
                ctx.lineWidth = 2;
                
                // Draw crown shape
                ctx.beginPath();
                const size = effect.crownSize;
                ctx.moveTo(-size * 0.8, 0);
                ctx.lineTo(-size * 0.8, -size * 0.4);
                ctx.lineTo(-size * 0.5, -size * 0.3);
                ctx.lineTo(-size * 0.3, -size * 0.8);
                ctx.lineTo(0, -size * 0.4);
                ctx.lineTo(size * 0.3, -size * 0.8);
                ctx.lineTo(size * 0.5, -size * 0.3);
                ctx.lineTo(size * 0.8, -size * 0.4);
                ctx.lineTo(size * 0.8, 0);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Crown jewels
                ctx.fillStyle = `rgba(255, 105, 180, ${crownAlpha})`;
                ctx.beginPath();
                ctx.arc(-size * 0.4, -size * 0.2, size * 0.1, 0, Math.PI * 2);
                ctx.arc(0, -size * 0.2, size * 0.1, 0, Math.PI * 2);
                ctx.arc(size * 0.4, -size * 0.2, size * 0.1, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw particles
            effect.particles.forEach(particle => {
                const x = Math.cos(particle.angle) * particle.distance;
                const y = Math.sin(particle.angle) * particle.distance * 0.5 + particle.y;
                
                ctx.save();
                ctx.fillStyle = particle.color.startsWith('#') ? 
                    `rgba(${parseInt(particle.color.slice(1,3), 16)}, ${parseInt(particle.color.slice(3,5), 16)}, ${parseInt(particle.color.slice(5,7), 16)}, ${particle.opacity})` :
                    particle.color;
                ctx.beginPath();
                ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Add glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = particle.color;
                ctx.beginPath();
                ctx.arc(x, y, particle.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
            
            // Central glow
            const glowAlpha = Math.max(0, 1 - effect.currentTick / effect.duration);
            const glowGradient = ctx.createRadialGradient(0, -10, 0, 0, -10, 40);
            glowGradient.addColorStop(0, `rgba(255, 215, 0, ${glowAlpha * 0.6})`);
            glowGradient.addColorStop(0.5, `rgba(255, 215, 0, ${glowAlpha * 0.3})`);
            glowGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
            
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(0, -10, 40, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Render portal creation effect
        function renderPortalCreationEffect(ctx, effect) {
            const iso = worldToIsometric(effect.x, effect.y);
            ctx.save();
            ctx.translate(iso.x, iso.y);
            
            // Draw expanding ring
            ctx.strokeStyle = `rgba(200, 100, 255, ${0.8 * (1 - effect.currentTick / effect.duration)})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, effect.radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw spiral particles
            effect.particles.forEach(particle => {
                const x = Math.cos(particle.angle) * particle.distance;
                const y = Math.sin(particle.angle) * particle.distance * 0.5; // Isometric compression
                
                ctx.save();
                ctx.fillStyle = `rgba(200, 100, 255, ${particle.opacity})`;
                ctx.beginPath();
                ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Add glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(200, 100, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(x, y, particle.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
            
            // Central glow
            const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
            glowGradient.addColorStop(0, `rgba(255, 255, 255, ${0.6 * (1 - effect.currentTick / effect.duration)})`);
            glowGradient.addColorStop(0.5, `rgba(200, 100, 255, ${0.4 * (1 - effect.currentTick / effect.duration)})`);
            glowGradient.addColorStop(1, 'rgba(200, 100, 255, 0)');
            
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function renderRequestBubbleClickEffect(ctx, effect) {
            ctx.save();
            ctx.translate(effect.x, effect.y);
            
            const progress = 1 - (effect.life / effect.maxLife);
            
            // Draw expanding ripples
            effect.ripples.forEach(ripple => {
                if (ripple.delay <= 0 && ripple.radius < ripple.maxRadius) {
                    const rippleProgress = ripple.radius / ripple.maxRadius;
                    const opacity = 0.6 * (1 - rippleProgress);
                    
                    // Outer ripple
                    if (ripple.radius > 0) {
                        ctx.strokeStyle = `rgba(255, 215, 0, ${opacity})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, ripple.radius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Inner glow - only draw if radius is large enough
                    const innerRadius = ripple.radius - 2;
                    if (innerRadius > 0) {
                        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.5})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(0, 0, innerRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            });
            
            // Draw sparkles
            effect.sparkles.forEach(sparkle => {
                const sparkleOpacity = (sparkle.life / 30);
                ctx.fillStyle = `rgba(255, 255, 255, ${sparkleOpacity})`;
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
                ctx.beginPath();
                ctx.arc(sparkle.x, sparkle.y, sparkle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.restore();
        }
        
        // Render kingdom territory highlights for War power
        function renderWarKingdomHighlights(ctx, world) {
            if (!game.abilities.war.active || !hoveredTile) return;
            
            ctx.save();
            
            // Get hovered tile and its owner
            const tile = world.tiles[hoveredTile.x][hoveredTile.y];
            const hoveredKingdomId = tile.owner;
            
            if (hoveredKingdomId === null) {
                ctx.restore();
                return;
            }
            
            // Simple highlight function similar to blessing
            function highlightKingdom(kingdomId, fillColor) {
                for (let y = 0; y < WORLD_SIZE; y++) {
                    for (let x = 0; x < WORLD_SIZE; x++) {
                        if (world.tiles[x][y].owner === kingdomId) {
                            const iso = worldToIsometric(x, y);
                            
                            // Draw tile highlight
                            ctx.fillStyle = fillColor;
                            ctx.beginPath();
                            ctx.moveTo(iso.x, iso.y - 10);
                            ctx.lineTo(iso.x + 20, iso.y);
                            ctx.lineTo(iso.x, iso.y + 10);
                            ctx.lineTo(iso.x - 20, iso.y);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                }
            }
            
            // If no kingdom selected yet, highlight the hovered kingdom
            if (!game.abilities.war.firstKingdom) {
                highlightKingdom(hoveredKingdomId, 'rgba(255, 100, 100, 0.3)');
            } else {
                // First kingdom selected - show it in solid red
                highlightKingdom(game.abilities.war.firstKingdom, 'rgba(255, 50, 50, 0.4)');
                
                // If hovering over a different kingdom, check if it borders
                if (hoveredKingdomId !== game.abilities.war.firstKingdom) {
                    const canDeclareWar = checkKingdomsBorder(game.abilities.war.firstKingdom, hoveredKingdomId);
                    
                    // Highlight hovered kingdom in orange if valid target, gray if not
                    const fillColor = canDeclareWar ? 'rgba(255, 165, 0, 0.3)' : 'rgba(128, 128, 128, 0.2)';
                    
                    highlightKingdom(hoveredKingdomId, fillColor);
                }
            }
            
            ctx.restore();
        }
        
        // Render kingdom territory highlights for Peace power
        function renderPeaceKingdomHighlights(ctx, world) {
            if (!game.abilities.peace.active || !hoveredTile) return;
            
            ctx.save();
            
            // Get hovered tile and its owner
            const tile = world.tiles[hoveredTile.x][hoveredTile.y];
            const hoveredKingdomId = tile.owner;
            
            if (hoveredKingdomId === null) {
                ctx.restore();
                return;
            }
            
            // Simple highlight function similar to blessing
            function highlightKingdom(kingdomId, fillColor) {
                for (let y = 0; y < WORLD_SIZE; y++) {
                    for (let x = 0; x < WORLD_SIZE; x++) {
                        if (world.tiles[x][y].owner === kingdomId) {
                            const iso = worldToIsometric(x, y);
                            
                            // Draw tile highlight
                            ctx.fillStyle = fillColor;
                            ctx.beginPath();
                            ctx.moveTo(iso.x, iso.y - 10);
                            ctx.lineTo(iso.x + 20, iso.y);
                            ctx.lineTo(iso.x, iso.y + 10);
                            ctx.lineTo(iso.x - 20, iso.y);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                }
            }
            
            // If no kingdom selected yet, highlight the hovered kingdom
            if (!game.abilities.peace.firstKingdom) {
                highlightKingdom(hoveredKingdomId, 'rgba(255, 223, 186, 0.3)');
            } else {
                // First kingdom selected - show it in solid golden
                highlightKingdom(game.abilities.peace.firstKingdom, 'rgba(255, 235, 205, 0.4)');
                
                // If hovering over a different kingdom, check if they're at war
                if (hoveredKingdomId !== game.abilities.peace.firstKingdom) {
                    const areAtWar = areKingdomsAtWar(game.abilities.peace.firstKingdom, hoveredKingdomId);
                    
                    // Highlight hovered kingdom in bright gold if at war, gray if not
                    const fillColor = areAtWar ? 'rgba(255, 215, 0, 0.3)' : 'rgba(128, 128, 128, 0.2)';
                    
                    highlightKingdom(hoveredKingdomId, fillColor);
                }
            }
            
            ctx.restore();
        }
        
        // Render portal tile highlights
        function renderPortalHighlights(ctx, world) {
            if (!game.abilities.portal.active) return;
            
            ctx.save();
            
            // Highlight first selected tile
            if (game.abilities.portal.firstTile && game.abilities.portal.firstTile.worldId === world.id) {
                const firstTile = game.abilities.portal.firstTile;
                const iso = worldToIsometric(firstTile.x, firstTile.y);
                
                // Draw pulsing highlight for first tile
                const pulseAlpha = 0.3 + Math.sin(Date.now() * 0.003) * 0.1;
                ctx.fillStyle = `rgba(200, 100, 255, ${pulseAlpha})`;
                
                ctx.save();
                ctx.translate(iso.x, iso.y);
                ctx.beginPath();
                ctx.moveTo(0, -17);
                ctx.lineTo(33, 0);
                ctx.lineTo(0, 17);
                ctx.lineTo(-33, 0);
                ctx.closePath();
                ctx.fill();
                
                // Draw selection border
                ctx.strokeStyle = 'rgba(200, 100, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
            }
            
            // Highlight hovered tile if selecting second tile
            if (game.abilities.portal.firstTile && hoveredTile) {
                const hoveredWorldId = world.id;
                const isValidSecondTile = true; // Could add validation here
                
                const iso = worldToIsometric(hoveredTile.x, hoveredTile.y);
                
                // Different color based on validity
                const fillColor = isValidSecondTile ? 'rgba(200, 100, 255, 0.2)' : 'rgba(255, 100, 100, 0.2)';
                
                ctx.save();
                ctx.translate(iso.x, iso.y);
                ctx.fillStyle = fillColor;
                ctx.beginPath();
                ctx.moveTo(0, -17);
                ctx.lineTo(33, 0);
                ctx.lineTo(0, 17);
                ctx.lineTo(-33, 0);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                
                // Draw connection line between tiles if in same world
                if (game.abilities.portal.firstTile.worldId === world.id) {
                    const firstIso = worldToIsometric(game.abilities.portal.firstTile.x, game.abilities.portal.firstTile.y);
                    
                    ctx.strokeStyle = 'rgba(200, 100, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(firstIso.x, firstIso.y);
                    ctx.lineTo(iso.x, iso.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            
            // Highlight hovered tile when selecting first tile (no first tile selected yet)
            if (!game.abilities.portal.firstTile && hoveredTile) {
                const iso = worldToIsometric(hoveredTile.x, hoveredTile.y);
                
                ctx.save();
                ctx.translate(iso.x, iso.y);
                
                // Draw hover highlight
                ctx.fillStyle = 'rgba(200, 100, 255, 0.3)';
                ctx.beginPath();
                ctx.moveTo(0, -17);
                ctx.lineTo(33, 0);
                ctx.lineTo(0, 17);
                ctx.lineTo(-33, 0);
                ctx.closePath();
                ctx.fill();
                
                // Draw portal icon
                ctx.strokeStyle = 'rgba(200, 100, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(0, 0, 8, 12, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner swirl
                ctx.beginPath();
                ctx.arc(0, -3, 3, 0, Math.PI * 1.5);
                ctx.stroke();
                
                ctx.restore();
            }
            
            ctx.restore();
        }
        
        function renderSculptHighlights(ctx, world) {
            if (!game.abilities.sculpt.active || !hoveredTile) return;
            
            ctx.save();
            
            const centerTile = world.tiles[hoveredTile.x][hoveredTile.y];
            const willRemove = centerTile.active;
            const radius = game.abilities.sculpt.radius;
            
            // Draw targeting area
            const areaColor = 'rgba(139, 69, 19, 0.2)';
            const areaStroke = 'rgba(139, 69, 19, 0.4)';
            
            // Draw all tiles in radius to show targeting area
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    const x = hoveredTile.x + dx;
                    const y = hoveredTile.y + dy;
                    
                    // Check bounds
                    if (x < 0 || x >= WORLD_SIZE || y < 0 || y >= WORLD_SIZE) continue;
                    
                    // Check distance
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > radius) continue;
                    
                    const tile = world.tiles[x][y];
                    if (!tile) continue;
                    
                    // Calculate position
                    let renderX, renderY;
                    if (tile.isoX !== undefined && tile.isoY !== undefined) {
                        renderX = tile.isoX;
                        renderY = tile.active ? tile.renderY : tile.isoY;
                    } else {
                        const iso = worldToIsometric(x, y);
                        renderX = iso.x;
                        renderY = iso.y;
                    }
                    
                    // Draw targeting area outline
                    ctx.save();
                    ctx.translate(renderX, renderY);
                    ctx.globalAlpha = 0.3;
                    
                    ctx.fillStyle = areaColor;
                    ctx.strokeStyle = areaStroke;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, -17);
                    ctx.lineTo(33, 0);
                    ctx.lineTo(0, 17);
                    ctx.lineTo(-33, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
            
            // Highlight the specific hovered tile
            const tile = centerTile;
            const fillColor = willRemove ? 'rgba(255, 99, 71, 0.5)' : 'rgba(70, 130, 180, 0.5)';
            const strokeColor = willRemove ? 'rgba(255, 99, 71, 0.8)' : 'rgba(70, 130, 180, 0.8)';
            
            // Calculate position for hovered tile
            let renderX, renderY;
            if (tile.isoX !== undefined && tile.isoY !== undefined) {
                renderX = tile.isoX;
                renderY = tile.active ? tile.renderY : tile.isoY;
            } else {
                const iso = worldToIsometric(hoveredTile.x, hoveredTile.y);
                renderX = iso.x;
                renderY = iso.y;
            }
            
            // Draw specific tile highlight
            ctx.save();
            ctx.translate(renderX, renderY);
            
            ctx.fillStyle = fillColor;
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -17);
            ctx.lineTo(33, 0);
            ctx.lineTo(0, 17);
            ctx.lineTo(-33, 0);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw action icon
            ctx.fillStyle = strokeColor;
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(willRemove ? '−' : '+', 0, 0);
            
            ctx.restore();
            ctx.restore();
        }
        
        // Render kingdom creation highlights
        function renderKingdomHighlights(ctx, world) {
            if (!game.abilities.kingdom.active || !hoveredTile) return;
            
            ctx.save();
            
            const tile = world.tiles[hoveredTile.x][hoveredTile.y];
            const isValidTile = tile.owner === null && tile.active;
            
            const iso = worldToIsometric(hoveredTile.x, hoveredTile.y);
            
            // Different color based on validity
            const fillColor = isValidTile ? 'rgba(255, 215, 0, 0.3)' : 'rgba(255, 100, 100, 0.2)';
            const strokeColor = isValidTile ? 'rgba(255, 215, 0, 0.8)' : 'rgba(255, 100, 100, 0.6)';
            
            ctx.save();
            ctx.translate(iso.x, iso.y);
            
            // Draw tile highlight
            ctx.fillStyle = fillColor;
            ctx.beginPath();
            ctx.moveTo(0, -17);
            ctx.lineTo(33, 0);
            ctx.lineTo(0, 17);
            ctx.lineTo(-33, 0);
            ctx.closePath();
            ctx.fill();
            
            // Draw border
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw crown preview if valid
            if (isValidTile) {
                ctx.save();
                ctx.translate(0, -25);
                ctx.scale(0.5, 0.5);
                
                // Mini crown
                ctx.fillStyle = 'rgba(255, 215, 0, 0.6)';
                ctx.strokeStyle = 'rgba(184, 134, 11, 0.8)';
                ctx.lineWidth = 1.5;
                
                ctx.beginPath();
                ctx.moveTo(-16, 0);
                ctx.lineTo(-16, -8);
                ctx.lineTo(-10, -6);
                ctx.lineTo(-6, -16);
                ctx.lineTo(0, -8);
                ctx.lineTo(6, -16);
                ctx.lineTo(10, -6);
                ctx.lineTo(16, -8);
                ctx.lineTo(16, 0);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.restore();
            }
            
            ctx.restore();
            ctx.restore();
        }
        
        // Render terraform highlights
        function renderTerraformHighlights(ctx, world) {
            if (!game.abilities.terraform.active || !hoveredTile) return;
            
            ctx.save();
            
            const tile = world.tiles[hoveredTile.x][hoveredTile.y];
            const isValidTile = tile.active;
            
            // Use the tile's render position which accounts for elevation
            const centerX = tile.isoX !== undefined ? tile.isoX : worldToIsometric(hoveredTile.x, hoveredTile.y).x;
            const centerY = tile.renderY !== undefined ? tile.renderY : worldToIsometric(hoveredTile.x, hoveredTile.y).y;
            
            // Draw terraform radius preview
            const maxDistance = game.abilities.terraform.radius;
            for (let dx = -maxDistance; dx <= maxDistance; dx++) {
                for (let dy = -maxDistance; dy <= maxDistance; dy++) {
                    const x = hoveredTile.x + dx;
                    const y = hoveredTile.y + dy;
                    
                    if (x >= 0 && x < WORLD_SIZE && y >= 0 && y < WORLD_SIZE) {
                        const affectedTile = world.tiles[x][y];
                        if (affectedTile && affectedTile.active) {
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const influence = Math.pow(1 - Math.min(distance / maxDistance, 1), 1.2);
                            
                            if (influence > 0.1) {
                                // Use the affected tile's render position
                                const tileX = affectedTile.isoX !== undefined ? affectedTile.isoX : worldToIsometric(x, y).x;
                                const tileY = affectedTile.renderY !== undefined ? affectedTile.renderY : worldToIsometric(x, y).y;
                                
                                ctx.save();
                                ctx.translate(tileX, tileY);
                                
                                // Draw influence indicator
                                const alpha = influence * 0.3;
                                ctx.fillStyle = `rgba(139, 69, 19, ${alpha})`;
                                ctx.beginPath();
                                ctx.moveTo(0, -17);
                                ctx.lineTo(33, 0);
                                ctx.lineTo(0, 17);
                                ctx.lineTo(-33, 0);
                                ctx.closePath();
                                ctx.fill();
                                
                                ctx.restore();
                            }
                        }
                    }
                }
            }
            
            // Draw center tile highlight
            if (isValidTile) {
                ctx.save();
                ctx.translate(centerX, centerY);
                
                // Draw terrain icon
                ctx.fillStyle = 'rgba(139, 69, 19, 0.8)';
                ctx.strokeStyle = 'rgba(101, 67, 33, 0.8)';
                ctx.lineWidth = 2;
                
                // Mountain shape
                ctx.beginPath();
                ctx.moveTo(-10, 0);
                ctx.lineTo(-5, -10);
                ctx.lineTo(0, -5);
                ctx.lineTo(5, -12);
                ctx.lineTo(10, 0);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Draw up/down arrows
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                // Up arrow
                ctx.moveTo(0, -20);
                ctx.lineTo(0, -30);
                ctx.moveTo(-4, -26);
                ctx.lineTo(0, -30);
                ctx.lineTo(4, -26);
                // Down arrow
                ctx.moveTo(0, 10);
                ctx.lineTo(0, 20);
                ctx.moveTo(-4, 16);
                ctx.lineTo(0, 20);
                ctx.lineTo(4, 16);
                ctx.stroke();
                
                ctx.restore();
            }
            
            ctx.restore();
        }
        
        // Render Terra Witch
        function renderTerraWitch(ctx, world) {
            const witch = game.terraWitch;
            const iso = worldToIsometric(witch.x, witch.y);
            const actualHeight = witch.currentHeight + witch.bobOffset;
            
            ctx.save();
            
            // Check if this witch is being followed
            var isFollowed = camera.followingEntity && 
                           camera.followingEntity.type === 'terraWitch';
            
            // Draw follow indicator if being followed
            if (isFollowed) {
                ctx.save();
                ctx.translate(iso.x, iso.y - actualHeight);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, Math.PI * 2);
                ctx.stroke();
                
                // Pulsing inner circle
                var pulseSize = 25 + Math.sin(Date.now() * 0.003) * 5;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            
            // Render magic circle during bone ritual
            if (witch.phase === 'bone_ritual_channeling' && witch.magicCircleRadius > 0) {
                renderBoneRitualMagicCircle(ctx, witch, world);
            }
            
            // Draw shadow only if above land tiles
            if (witch.phase !== 'in_house' && witch.phase !== 'waiting') {
                const tileX = Math.floor(witch.x);
                const tileY = Math.floor(witch.y);
                if (tileX >= 0 && tileX < WORLD_SIZE && tileY >= 0 && tileY < WORLD_SIZE) {
                    const tile = world.tiles[tileX][tileY];
                    if (tile && tile.elevation > 0) { // Only show shadow above land
                        ctx.save();
                        ctx.translate(iso.x, iso.y);
                        ctx.globalAlpha = 0.3;
                        
                        const shadowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 8);
                        shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');
                        shadowGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.2)');
                        shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        
                        ctx.fillStyle = shadowGradient;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 8, 4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
            }
            
            // Draw witch at height
            // Add spire twist offset when observing
            let xOffset = 0;
            if (witch.phase === 'observing_spire') {
                // Apply the same twist as the spire's top platform
                const topTwist = Math.sin(6 * 0.8) * 4;
                xOffset = topTwist;
            }
            ctx.translate(iso.x + xOffset, iso.y - actualHeight);
            
            // Flip if facing right (to match isometric view)
            if (witch.facingRight) {
                ctx.scale(-1, 1);
            }
            
            // Draw broom (static, no animation)
            ctx.save();
            
            // Broom handle (smaller to fit witch)
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 1.15;
            ctx.beginPath();
            ctx.moveTo(-5, 1);
            ctx.lineTo(6, 1);
            ctx.stroke();
            
            // Broom bristles - 7 individual hairs
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 0.5;
            const bristleStartX = 6;
            const bristleAngles = [-0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6];
            const bristleLengths = [3, 3.5, 4, 4.25, 4, 3.5, 3]; // Middle hair is longest
            
            for (let i = 0; i < 7; i++) {
                ctx.beginPath();
                ctx.moveTo(bristleStartX, 1);
                const endX = bristleStartX + bristleLengths[i];
                const endY = 1 + Math.sin(bristleAngles[i]) * 3.5;
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
            
            // Magic particles from broom bristles only when flying
            if (witch.phase === 'flying_patrol' || witch.phase === 'hunting_army') {
                ctx.fillStyle = '#8B00FF';
                ctx.globalAlpha = 0.6;
                for (let i = 0; i < 3; i++) {
                    const particleX = bristleStartX + 3 + Math.random() * 1;
                    const particleY = 1 + (Math.random() - 0.5) * 4;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, 0.3 + Math.random() * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
            
            ctx.restore();
            
            // Adjust witch pose when observing
            if (witch.phase === 'observing') {
                ctx.save();
                // Slightly different stance
                ctx.translate(0, -1);
                ctx.restore();
            }
            
            // Draw witch body (recruit-sized, black)
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(0, 0, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw arms only during attack
            if (witch.phase === 'attacking' || witch.phase === 'eternal_hunt_attacking') {
                ctx.strokeStyle = '#90EE90'; // Green skin for arms
                ctx.lineWidth = 1.5;
                ctx.lineCap = 'round';
                
                // Left arm (viewer's right when facing left)
                ctx.beginPath();
                ctx.moveTo(-2, -1);
                if (witch.armRaised) {
                    // Raised arm pointing forward
                    ctx.lineTo(-4, -4);
                    ctx.lineTo(-6, -5);
                    // Add magical glow effect
                    ctx.save();
                    ctx.strokeStyle = '#8B00FF';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(-6, -5, 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                } else {
                    // Normal arm position
                    ctx.lineTo(-3, 1);
                    ctx.lineTo(-2, 3);
                }
                ctx.stroke();
                
                // Right arm (viewer's left when facing left)
                ctx.beginPath();
                ctx.moveTo(2, -1);
                ctx.lineTo(3, 1);
                ctx.lineTo(2, 3);
                ctx.stroke();
            }
            
            // Draw witch head (no eyes)
            ctx.fillStyle = '#90EE90'; // Green skin
            ctx.beginPath();
            ctx.arc(0, -5, 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Black pointed hat
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(-3, -7);
            ctx.lineTo(0, -12);
            ctx.lineTo(3, -7);
            ctx.closePath();
            ctx.fill();
            
            // Draw simple black hair strands on right side
            ctx.save();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.globalAlpha = 0.9;
            
            // Draw several hair strands flowing right and down
            const hairSway = Math.sin(witch.bobPhase * 2) * 0.3;
            
            // Main hair strands
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                const startAngle = 0.5 + i * 0.2; // Changed to 0.5
                const startX = Math.cos(startAngle) * 2.5;
                const startY = -6 + Math.sin(startAngle) * 0.5; // Moved down from -6.5 to -6
                
                ctx.moveTo(startX, startY);
                
                // Hair flows right and down - smaller and closer to body
                const midX = startX + 1 + i * 0.15; // Reduced from 2 to 1, and spread from 0.3 to 0.15
                const midY = startY + 2; // Reduced from 3 to 2
                const endX = midX + 0.5 + hairSway * 0.5; // Reduced from 1 to 0.5
                const endY = midY + 1 + i * 0.3; // Reduced from 2 to 1
                
                ctx.quadraticCurveTo(midX, midY, endX, endY);
                ctx.stroke();
            }
            
            ctx.restore();
            
            // Hat brim
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.ellipse(0, -7, 4, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            
            // Render smoke trail
            if (witch.smokeTrail.length > 1) {
                ctx.save();
                
                // Draw smoke trail as connected path
                for (let i = 0; i < witch.smokeTrail.length - 1; i++) {
                    const point = witch.smokeTrail[i];
                    const nextPoint = witch.smokeTrail[i + 1];
                    const alpha = 1 - (point.age / 60);
                    
                    const pointIso = worldToIsometric(point.x, point.y);
                    const nextPointIso = worldToIsometric(nextPoint.x, nextPoint.y);
                    
                    // Create gradient for each segment
                    const gradient = ctx.createLinearGradient(
                        pointIso.x, pointIso.y - witch.currentHeight,
                        nextPointIso.x, nextPointIso.y - witch.currentHeight
                    );
                    
                    gradient.addColorStop(0, `rgba(138, 43, 226, ${alpha * 0.3})`); // Purple with transparency
                    gradient.addColorStop(1, `rgba(138, 43, 226, ${alpha * 0.1})`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = point.size * 10 * (1 - i / witch.smokeTrail.length); // Taper the trail
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(pointIso.x, pointIso.y - witch.currentHeight);
                    ctx.lineTo(nextPointIso.x, nextPointIso.y - witch.currentHeight);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }
        
        function renderBurnedBody(ctx, body) {
            const fadeProgress = body.currentTick / body.duration;
            const alpha = 1 - fadeProgress;
            
            ctx.save();
            ctx.globalAlpha = alpha;
            
            // Draw scorch mark on ground first
            const scorchSize = body.unitType === 'army' ? 30 : 20;
            ctx.fillStyle = `rgba(20, 20, 20, ${alpha * 0.3})`;
            ctx.beginPath();
            ctx.ellipse(body.x, body.y, scorchSize, scorchSize * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw banner first if army had one
            if (body.hasBanner && body.unitType === 'army') {
                ctx.save();
                ctx.translate(body.x - 12, body.y - 8);
                
                // Charred banner pole (fallen)
                ctx.strokeStyle = '#2a2a2a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(15, -10);
                ctx.stroke();
                
                // Burned banner flag (on ground)
                ctx.fillStyle = '#333333';
                ctx.beginPath();
                ctx.moveTo(15, -10);
                ctx.lineTo(18, -6);
                ctx.lineTo(12, -5);
                ctx.lineTo(10, -8);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
            
            // Draw each body lying on side
            body.bodies.forEach((bodyData, index) => {
                ctx.save();
                ctx.translate(body.x + bodyData.offsetX, body.y + bodyData.offsetY);
                
                // Randomly face left or right
                const facingLeft = index % 2 === 0;
                if (!facingLeft) {
                    ctx.scale(-1, 1); // Mirror for facing right
                }
                
                // Small rotation for natural variation
                ctx.rotate(bodyData.rotation * 0.3);
                
                // Draw shadow under body
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.2})`;
                ctx.beginPath();
                ctx.ellipse(2, 0, 10, 3, -0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Charred body (lying on side - horizontal oval)
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.ellipse(0, 0, 7, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Blackened head (at left end of body)
                ctx.fillStyle = '#222222';
                ctx.beginPath();
                ctx.arc(-6, -1, 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Charred helmet (for armies only, lying near head)
                if (body.unitType === 'army') {
                    ctx.fillStyle = '#2a2a2a';
                    ctx.beginPath();
                    // Helmet on its side
                    ctx.moveTo(-8, -3);
                    ctx.lineTo(-5, -5);
                    ctx.lineTo(-3, -3);
                    ctx.lineTo(-4, -1);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Darker edge on helmet
                    ctx.strokeStyle = '#1a1a1a';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                // Front arm (visible, slightly bent)
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(-3, 0);
                ctx.lineTo(-5, 3);
                ctx.lineTo(-7, 2);
                ctx.stroke();
                
                // Legs (one visible in profile)
                ctx.beginPath();
                ctx.moveTo(5, 0);
                ctx.lineTo(8, 1);
                ctx.lineTo(10, 0);
                ctx.stroke();
                
                // Second leg (slightly behind)
                ctx.globalAlpha = alpha * 0.7;
                ctx.beginPath();
                ctx.moveTo(5, -1);
                ctx.lineTo(8, -2);
                ctx.lineTo(9, -3);
                ctx.stroke();
                ctx.globalAlpha = alpha;
                
                // For armies, add burned weapon (lying in front)
                if (body.unitType === 'army') {
                    ctx.save();
                    ctx.translate(0, 4);
                    
                    // Weapon staff
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(-8, 0);
                    ctx.lineTo(5, 0);
                    ctx.stroke();
                    
                    // Charred weapon tip
                    ctx.fillStyle = '#444444';
                    ctx.beginPath();
                    ctx.moveTo(5, 0);
                    ctx.lineTo(7, -1);
                    ctx.lineTo(7, 1);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                // For recruits, add burned farmer hat (near head)
                if (body.unitType === 'recruit' && index % 2 === 0) {
                    // Charred farmer hat lying on ground
                    ctx.fillStyle = '#2a2a2a';
                    ctx.beginPath();
                    // Conical hat on its side
                    ctx.moveTo(-9, -3);
                    ctx.lineTo(-4, -5);
                    ctx.lineTo(-2, -2);
                    ctx.lineTo(-6, -1);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Darker edge/brim
                    ctx.strokeStyle = '#1a1a1a';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                // Ash particles (only from some bodies)
                if (fadeProgress < 0.5 && index % 2 === 0) {
                    ctx.fillStyle = `rgba(100, 100, 100, ${(1 - fadeProgress * 2) * 0.5})`;
                    for (let i = 0; i < 2; i++) {
                        const particleY = -fadeProgress * 15 - i * 3;
                        const particleX = (Math.sin(performance.now() * 0.0001 + index + i) * 2);
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, 0.8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            });
            
            ctx.restore();
        }
        
        function renderStructureBurnEffect(ctx, effect) {
            const progress = effect.currentTick / effect.duration;
            const fadeOut = 1 - progress;
            
            ctx.save();
            ctx.translate(effect.x, effect.y);
            
            // Render flames
            effect.flames.forEach((flame, i) => {
                // Use actual time for smooth animation
                const animTime = performance.now() * 0.001;
                const flameProgress = (animTime + flame.phase) % 2;
                const flameHeight = flame.size * (1 + Math.sin(flameProgress * Math.PI) * 0.3);
                const flameY = flame.offsetY - flameHeight * fadeOut;
                
                // Outer flame (orange)
                ctx.fillStyle = `rgba(255, 140, 0, ${fadeOut * 0.7})`;
                ctx.beginPath();
                ctx.moveTo(flame.offsetX - flame.size/2, flameY + flameHeight);
                ctx.quadraticCurveTo(flame.offsetX - flame.size/3, flameY + flameHeight/2, flame.offsetX, flameY);
                ctx.quadraticCurveTo(flame.offsetX + flame.size/3, flameY + flameHeight/2, flame.offsetX + flame.size/2, flameY + flameHeight);
                ctx.closePath();
                ctx.fill();
                
                // Inner flame (yellow)
                ctx.fillStyle = `rgba(255, 255, 0, ${fadeOut * 0.9})`;
                ctx.beginPath();
                ctx.moveTo(flame.offsetX - flame.size/3, flameY + flameHeight);
                ctx.quadraticCurveTo(flame.offsetX - flame.size/4, flameY + flameHeight*0.7, flame.offsetX, flameY + flameHeight*0.3);
                ctx.quadraticCurveTo(flame.offsetX + flame.size/4, flameY + flameHeight*0.7, flame.offsetX + flame.size/3, flameY + flameHeight);
                ctx.closePath();
                ctx.fill();
            });
            
            // Add embers
            if (progress > 0.3) {
                ctx.fillStyle = `rgba(255, 100, 0, ${fadeOut})`;
                const animTime = performance.now() * 0.0001;
                for (let i = 0; i < 5; i++) {
                    const emberX = (Math.sin(animTime * 10 + i) * 20);
                    const emberY = -20 - (progress - 0.3) * 100 - i * 5;
                    const emberSize = 2 + Math.sin(animTime * 20 + i) * 1;
                    
                    ctx.beginPath();
                    ctx.arc(emberX, emberY, emberSize * fadeOut, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }
        
        function renderKingdomDefeatEffect(ctx, effect) {
            const progress = effect.currentTick / effect.duration;
            
            ctx.save();
            ctx.translate(effect.x, effect.y);
            
            // Shake effect for collapsing tower
            if (effect.towerCollapseProgress > 0) {
                const shakeIntensity = (1 - effect.towerCollapseProgress) * 3;
                ctx.translate(
                    (Math.random() - 0.5) * shakeIntensity,
                    (Math.random() - 0.5) * shakeIntensity
                );
            }
            
            // Draw collapsing capital tower
            const towerOffset = effect.towerCollapseProgress * 30;
            const towerRotation = effect.towerCollapseProgress * 0.3;
            
            ctx.save();
            ctx.rotate(towerRotation);
            ctx.translate(0, towerOffset);
            
            // Tower body (getting darker as it falls)
            const darkness = 1 - effect.towerCollapseProgress * 0.5;
            ctx.fillStyle = `rgb(${Math.floor(156 * darkness)}, ${Math.floor(138 * darkness)}, ${Math.floor(122 * darkness)})`;
            ctx.fillRect(-8, -40, 16, 35);
            
            // Tower roof
            ctx.fillStyle = `rgb(${Math.floor(107 * darkness)}, ${Math.floor(85 * darkness)}, ${Math.floor(55 * darkness)})`;
            ctx.beginPath();
            ctx.moveTo(-10, -40);
            ctx.lineTo(0, -50);
            ctx.lineTo(10, -40);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
            
            // Draw falling flag
            if (effect.flagFallProgress > 0) {
                ctx.save();
                const flagY = -50 + effect.flagFallProgress * 70;
                const flagRotation = effect.flagFallProgress * 1.5;
                
                ctx.translate(0, flagY);
                ctx.rotate(flagRotation);
                
                // Flag pole
                ctx.strokeStyle = '#4A4A4A';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -15);
                ctx.stroke();
                
                // Flag (fading out)
                ctx.fillStyle = effect.kingdomColor;
                ctx.globalAlpha = 1 - effect.flagFallProgress * 0.7;
                ctx.beginPath();
                ctx.moveTo(0, -15);
                ctx.lineTo(15, -10);
                ctx.lineTo(12, -5);
                ctx.lineTo(0, -8);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
            
            // Draw debris
            ctx.globalAlpha = 1 - progress * 0.5;
            effect.debris.forEach(d => {
                ctx.save();
                ctx.translate(d.x, d.y);
                ctx.rotate(d.rotation);
                
                ctx.fillStyle = d.color;
                ctx.fillRect(-d.size/2, -d.size/2, d.size, d.size);
                
                ctx.restore();
            });
            
            // Dust cloud
            const dustRadius = progress * 50;
            const dustAlpha = (1 - progress) * 0.3;
            ctx.fillStyle = `rgba(139, 115, 85, ${dustAlpha})`;
            ctx.beginPath();
            ctx.arc(0, 0, dustRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Kingdom name fading out
            if (progress < 0.5) {
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(255, 255, 255, ' + (1 - progress * 2) + ')';
                ctx.strokeStyle = 'rgba(0, 0, 0, ' + (1 - progress * 2) + ')';
                ctx.lineWidth = 3;
                ctx.strokeText(effect.kingdomName + ' has fallen!', 0, -70);
                ctx.fillText(effect.kingdomName + ' has fallen!', 0, -70);
            }
            
            ctx.restore();
        }
        
        function renderVictoryEffect(ctx, effect) {
            const progress = effect.currentTick / effect.duration;
            
            ctx.save();
            ctx.translate(effect.x, effect.y);
            
            // Golden glow aura
            const glowRadius = 60 + Math.sin(progress * Math.PI * 4) * 10;
            const gradient = ctx.createRadialGradient(0, -30, 0, 0, -30, glowRadius);
            gradient.addColorStop(0, `rgba(255, 215, 0, ${0.3 * (1 - progress * 0.5)})`);
            gradient.addColorStop(0.5, `rgba(255, 215, 0, ${0.15 * (1 - progress * 0.5)})`);
            gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, -30, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Victory banner raising
            if (effect.bannerRaiseProgress > 0) {
                ctx.save();
                
                // Banner pole (growing upward)
                const poleHeight = effect.bannerRaiseProgress * 50;
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(15, -20);
                ctx.lineTo(15, -20 - poleHeight);
                ctx.stroke();
                
                // Victory banner (unfurling)
                const bannerSize = effect.bannerRaiseProgress;
                ctx.fillStyle = effect.kingdomColor;
                ctx.globalAlpha = effect.bannerRaiseProgress;
                
                ctx.beginPath();
                ctx.moveTo(15, -20 - poleHeight);
                ctx.lineTo(15 + 25 * bannerSize, -20 - poleHeight + 5 * bannerSize);
                ctx.lineTo(15 + 25 * bannerSize, -20 - poleHeight + 20 * bannerSize);
                ctx.lineTo(15 + 20 * bannerSize, -20 - poleHeight + 22 * bannerSize);
                ctx.lineTo(15 + 15 * bannerSize, -20 - poleHeight + 20 * bannerSize);
                ctx.lineTo(15, -20 - poleHeight + 15 * bannerSize);
                ctx.closePath();
                ctx.fill();
                
                // Victory text on banner
                if (effect.bannerRaiseProgress > 0.7) {
                    ctx.font = 'bold 8px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = 'white';
                    ctx.save();
                    ctx.translate(15 + 12, -20 - poleHeight + 12);
                    ctx.rotate(-0.1);
                    ctx.fillText('VICTORY', 0, 0);
                    ctx.restore();
                }
                
                ctx.restore();
            }
            
            // Celebration particles
            effect.particles.forEach(p => {
                if (effect.currentTick > p.delay) {
                    const particleProgress = (effect.currentTick - p.delay) / (effect.duration - p.delay);
                    const alpha = (1 - particleProgress) * 0.8;
                    
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    ctx.globalAlpha = alpha;
                    
                    // Rectangle confetti pieces
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size * 1.5);
                    
                    ctx.restore();
                }
            });
            
            // Victory message
            if (progress > 0.2 && progress < 0.8) {
                const textAlpha = progress < 0.5 ? (progress - 0.2) / 0.3 : (0.8 - progress) / 0.3;
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = `rgba(255, 215, 0, ${textAlpha})`;
                ctx.strokeStyle = `rgba(0, 0, 0, ${textAlpha})`;
                ctx.lineWidth = 3;
                ctx.strokeText(effect.kingdomName + ' victorious!', 0, -80);
                ctx.fillText(effect.kingdomName + ' victorious!', 0, -80);
            }
            
            ctx.restore();
        }
        function drawRequestIcon(ctx, x, y, type, scale = 1) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            
            switch(type) {
                case 'attack':
                    // Smite button icon - lightning bolt
                    ctx.fillStyle = '#64c8ff';
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 0.5;
                    ctx.strokeLinejoin = 'round';
                    ctx.beginPath();
                    ctx.moveTo(2, -12);
                    ctx.lineTo(-4, 0);
                    ctx.lineTo(1, 0);
                    ctx.lineTo(-2, 12);
                    ctx.lineTo(4, -2);
                    ctx.lineTo(-1, -2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                    
                    
                case 'peace':
                    // Peace button icon - peace symbol
                    ctx.strokeStyle = '#ffdba8';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    // Circle
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    // Peace sign inside
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(0, 10);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-7, 7);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(7, 7);
                    ctx.stroke();
                    break;
                    
                case 'blessing':
                    // Bless button icon - sparkle
                    ctx.fillStyle = '#ffd700';
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 0.5;
                    
                    // Center vertical sparkle
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(1, -2);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(-1, -2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Left horizontal sparkle
                    ctx.beginPath();
                    ctx.moveTo(-6, 0);
                    ctx.lineTo(-2, -1);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(-2, 1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Right horizontal sparkle
                    ctx.beginPath();
                    ctx.moveTo(6, 0);
                    ctx.lineTo(2, -1);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(2, 1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Bottom vertical sparkle
                    ctx.beginPath();
                    ctx.moveTo(0, 10);
                    ctx.lineTo(-1, 2);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(1, 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Small corner sparkles
                    ctx.beginPath();
                    ctx.arc(-7, -7, 1.5, 0, Math.PI * 2);
                    ctx.arc(7, -7, 1.5, 0, Math.PI * 2);
                    ctx.arc(-7, 7, 1.5, 0, Math.PI * 2);
                    ctx.arc(7, 7, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    break;
                    
                    
                case 'portal':
                    // Portal button icon - oval with spiral
                    ctx.save();
                    
                    // Portal oval
                    ctx.strokeStyle = '#9370DB';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 8, 12, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner spiral
                    ctx.lineWidth = 1.5;
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.quadraticCurveTo(6, 0, 0, 8);
                    ctx.quadraticCurveTo(-6, 0, 0, -8);
                    ctx.stroke();
                    
                    // Center glow
                    ctx.fillStyle = '#9370DB';
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                    break;
            }
            
            ctx.restore();
        }
        
        function renderTempleRequest(ctx, x, y, request, kingdom, world) {
            var fadeIn = Math.min(request.currentTick / 30, 1);
            var fadeOut = request.currentTick > request.duration - 30 ? (request.duration - request.currentTick) / 30 : 1;
            
            // If request is completed and fading out, use fade timer
            if (request.fadingOut && request.fadeTimer !== undefined) {
                fadeOut = request.fadeTimer / 30;
            }
            
            var alpha = fadeIn * fadeOut;
            
            ctx.save();
            
            // Bubble dimensions
            const bubbleWidth = 70;
            const bubbleHeight = 40;
            const bubbleX = x - bubbleWidth/2;
            const bubbleY = y - bubbleHeight/2;
            
            // Store bubble position for hover detection
            request.bubbleX = x;
            request.bubbleY = y;
            request.bubbleWidth = bubbleWidth;
            request.bubbleHeight = bubbleHeight;
            
            // First pass: Create blur effect backdrop
            ctx.globalAlpha = alpha * 0.3;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.45)';
            ctx.filter = 'blur(12px)';
            ctx.beginPath();
            ctx.roundRect(bubbleX - 8, bubbleY - 8, bubbleWidth + 16, bubbleHeight + 16, 15);
            ctx.fill();
            
            // Second pass: Main bubble with no outline
            ctx.filter = 'none';
            ctx.globalAlpha = alpha * 0.375;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.425)';
            ctx.beginPath();
            ctx.roundRect(bubbleX, bubbleY, bubbleWidth, bubbleHeight, 12);
            ctx.fill();
            
            // Draw tail pointing to capital
            ctx.beginPath();
            ctx.moveTo(x - 6, y + bubbleHeight/2);
            ctx.lineTo(x + 6, y + bubbleHeight/2);
            ctx.lineTo(x, y + bubbleHeight/2 + 10);
            ctx.closePath();
            ctx.fill();
            
            // Draw icon on left, praying hands emoji on right
            ctx.globalAlpha = alpha * 0.5;
            
            // Draw button icon on left
            drawRequestIcon(ctx, x - 18, y, request.type, 0.8);
            
            // Draw praying hands emoji on right
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('🙏', x + 18, y);
            
            ctx.restore();
            
            // Highlight target kingdom or location on hover (drawn separately to avoid clipping)
            if (isMouseOverRequest(x, y, bubbleWidth, bubbleHeight)) {
                if (request.target) {
                    highlightTargetKingdom(ctx, request.target, world, x, y);
                } else if (request.location) {
                    highlightTargetLocation(ctx, request.location, world, x, y, request.type);
                }
            }
        }
        
        function isMouseOverRequest(reqX, reqY, width, height) {
            // Convert screen coordinates to canvas coordinates
            const rect = canvas.getBoundingClientRect();
            const canvasX = camera.currentMouseX - rect.left;
            const canvasY = camera.currentMouseY - rect.top;
            
            // Convert to world coordinates
            const worldX = (canvasX - canvas.width/2) / camera.zoom + camera.x;
            const worldY = (canvasY - canvas.height/2) / camera.zoom + camera.y;
            
            // Check if mouse is over the request bubble
            return Math.abs(worldX - reqX) < width/2 && 
                   Math.abs(worldY - reqY) < height/2;
        }
        
        function highlightTargetKingdom(ctx, targetKingdom, world, requestX, requestY) {
            if (!targetKingdom.alive || targetKingdom.capitalX === undefined) return;
            
            const capitalIso = worldToIsometric(targetKingdom.capitalX, targetKingdom.capitalY);
            
            ctx.save();
            
            // Draw connecting line from request to target
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(requestX, requestY + 20);
            ctx.lineTo(capitalIso.x, capitalIso.y - 40);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw highlight circle around target capital
            const pulseScale = 1 + Math.sin(Date.now() * 0.003) * 0.1;
            
            // Outer glow
            ctx.globalAlpha = 0.4;
            ctx.strokeStyle = 'rgba(255, 215, 0, 1)';
            ctx.lineWidth = 8;
            ctx.shadowBlur = 30;
            ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
            ctx.beginPath();
            ctx.arc(capitalIso.x, capitalIso.y - 40, 45 * pulseScale, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner ring
            ctx.globalAlpha = 0.8;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'rgba(255, 215, 0, 1)';
            ctx.beginPath();
            ctx.arc(capitalIso.x, capitalIso.y - 40, 40 * pulseScale, 0, Math.PI * 2);
            ctx.stroke();
            
            // Target name label
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(capitalIso.x - 50, capitalIso.y - 100, 100, 25);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(targetKingdom.name, capitalIso.x, capitalIso.y - 87);
            
            ctx.restore();
        }
        
        function highlightTargetLocation(ctx, location, world, requestX, requestY, requestType) {
            const locationIso = worldToIsometric(location.x, location.y);
            
            ctx.save();
            
            // Draw connecting line from request to location
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(requestX, requestY + 20);
            ctx.lineTo(locationIso.x, locationIso.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw highlight based on request type
            const pulseScale = 1 + Math.sin(Date.now() * 0.003) * 0.1;
            
            if (requestType === 'terraform') {
                // Draw terrain highlight
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = 'rgba(139, 69, 19, 0.3)';
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                ctx.lineWidth = 3;
                
                // Draw a diamond shape for terrain
                ctx.beginPath();
                ctx.moveTo(locationIso.x, locationIso.y - 30 * pulseScale);
                ctx.lineTo(locationIso.x + 40 * pulseScale, locationIso.y);
                ctx.lineTo(locationIso.x, locationIso.y + 30 * pulseScale);
                ctx.lineTo(locationIso.x - 40 * pulseScale, locationIso.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Add terrain icon
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#ffd700';
                ctx.fillText('⛰️', locationIso.x, locationIso.y + 5);
            } else if (requestType === 'portal') {
                // Draw portal highlight
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = 'rgba(147, 112, 219, 1)';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(147, 112, 219, 0.8)';
                
                // Draw swirling circles
                for (let i = 0; i < 3; i++) {
                    const radius = (20 + i * 10) * pulseScale;
                    const rotation = Date.now() * 0.001 + i * Math.PI / 3;
                    ctx.beginPath();
                    ctx.arc(locationIso.x + Math.cos(rotation) * 10, 
                           locationIso.y + Math.sin(rotation) * 10, 
                           radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Add portal icon
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#9370db';
                ctx.fillText('🌀', locationIso.x, locationIso.y + 5);
            }
            
            // Location label
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(locationIso.x - 60, locationIso.y + 40, 120, 25);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            if (requestType === 'terraform') {
                ctx.fillText('Raise Terrain Here', locationIso.x, locationIso.y + 52);
            } else if (requestType === 'portal') {
                ctx.fillText('Portal Needed Here', locationIso.x, locationIso.y + 52);
            }
            
            ctx.restore();
        }
        
        function renderCloudTransition() {
            ctx.fillStyle = 'rgba(255, 255, 255, ' + camera.transitionAlpha + ')';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(240, 240, 240, ' + (camera.transitionAlpha * 0.8) + ')';
            for (var i = 0; i < 5; i++) {
                var x = (i * 250) % canvas.width;
                var y = Math.sin(i) * 100 + canvas.height / 2;
                ctx.beginPath();
                ctx.arc(x, y, 80, 0, Math.PI * 2);
                ctx.arc(x + 50, y - 20, 60, 0, Math.PI * 2);
                ctx.arc(x + 80, y, 70, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function renderPortalTransition() {
            ctx.fillStyle = `rgba(128, 0, 128, ${camera.transitionAlpha})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = `rgba(221, 160, 221, ${camera.transitionAlpha * 0.8})`;
             for (var i = 0; i < 5; i++) {
                var x = (i * 250 + performance.now() * 0.001) % (canvas.width + 200) - 100;
                var y = Math.sin(i) * 100 + canvas.height / 2;
                ctx.beginPath(); ctx.arc(x, y, 80, 0, Math.PI * 2); ctx.arc(x + 50, y - 20, 60, 0, Math.PI * 2); ctx.arc(x + 100, y, 70, 0, Math.PI * 2); ctx.fill();
            }
        }
        
        // World Effect Rendering Functions
        function renderIgnisEffect(ctx, center, effect) {
            const animTime = performance.now() * 0.0001;
            
            effect.embers.forEach(ember => {
                // Update ember position
                ember.z += ember.speed;
                if (ember.z > 400) ember.z = 0;  // Higher ceiling
                
                const wobbleX = Math.sin(animTime * ember.speed * 10 + ember.phase) * 100;  // Doubled from 50 to 100
                const wobbleY = Math.cos(animTime * ember.speed * 8 + ember.phase) * 60;  // Doubled from 30 to 60
                
                const x = center.x + ember.x + wobbleX;
                const y = center.y + ember.y + wobbleY - ember.z;
                
                // Fade based on height
                const alpha = ember.brightness * (1 - ember.z / 400);
                
                // Larger glow effect
                const glowSize = ember.size * 5;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
                gradient.addColorStop(0, `rgba(255, 200, 100, ${alpha * 0.4})`);
                gradient.addColorStop(0.5, `rgba(255, 150, 50, ${alpha * 0.2})`);
                gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Ember core
                ctx.fillStyle = `rgba(255, ${150 + ember.brightness * 100}, 50, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x, y, ember.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
        }
        
        function renderIgnisShadows(ctx, center, effect) {
            const animTime = performance.now() * 0.0001;
            
            // Render shadow armies
            effect.shadowArmies.forEach((army, index) => {
                // Calculate current position along route
                let currentPos;
                if (army.routeIndex < army.route.length - 1) {
                    const from = army.route[army.routeIndex];
                    const to = army.route[army.routeIndex + 1];
                    currentPos = {
                        x: from.x + (to.x - from.x) * army.moveProgress,
                        y: from.y + (to.y - from.y) * army.moveProgress
                    };
                } else {
                    currentPos = army.route[army.route.length - 1];
                }
                
                const armyIso = worldToIsometric(currentPos.x, currentPos.y);
                const armyX = armyIso.x;
                const armyY = armyIso.y;
                
                // Check if this shadow army is being followed
                var isFollowed = camera.followingEntity && 
                               camera.followingEntity.type === 'ignisShadow' &&
                               camera.followingEntity.shadowIndex === index;
                
                // Draw follow indicator if being followed
                if (isFollowed) {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(armyX, armyY - 10, 25, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Pulsing inner circle
                    var pulseSize = 20 + Math.sin(Date.now() * 0.003) * 5;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(armyX, armyY - 10, pulseSize, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                
                ctx.save();
                // 75% transparent (25% opacity)
                ctx.globalAlpha = army.fadeIn * 0.25;
                
                // Draw shadow for the army formation (matching renderArmy)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.beginPath();
                ctx.ellipse(armyX + 4, armyY - 5, 15, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw soldiers in exact army formation
                const rows = 2;
                const spacing = 6;
                
                // Render rows in reverse order (bottom row first for correct overlap)
                for (let row = rows - 1; row >= 0; row--) {
                    const soldiersInRow = row === 0 ? 3 : 4;
                    const startX = armyX - (soldiersInRow - 1) * spacing / 2;
                    const rowY = armyY - row * 8;
                    
                    for (let i = 0; i < soldiersInRow; i++) {
                        const unitX = startX + i * spacing;
                        const unitY = rowY + (i % 2) * 2;
                        
                        // Body (black shadow)
                        ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                        ctx.fillRect(unitX - 2, unitY - 6, 4, 6);
                        
                        // Head (black shadow)
                        ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                        ctx.beginPath();
                        ctx.arc(unitX, unitY - 8, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Red glowing eyes
                        ctx.fillStyle = 'rgba(255, 50, 0, 0.8)';
                        ctx.beginPath();
                        ctx.arc(unitX - 1, unitY - 8, 0.5, 0, Math.PI * 2);
                        ctx.arc(unitX + 1, unitY - 8, 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            });
        }
        
        function renderAquaEffect(ctx, center, effect) {
            const animTime = performance.now() * 0.0001;
            
            // Render pretty bubbles (behind rain)
            ctx.save();
            effect.bubbles.forEach(bubble => {
                // Update bubble position
                bubble.y -= bubble.speed;
                if (bubble.y < -effect.radius * 60 - 100) {
                    bubble.y = effect.radius * 60 + 100;
                }
                
                const wobbleX = Math.sin(animTime * 2 + bubble.wobblePhase) * 10;
                const x = center.x + bubble.x + wobbleX;
                const y = center.y + bubble.y;
                
                // Bubble gradient with shimmer
                const shimmer = 0.5 + Math.sin(animTime * 3 + bubble.shimmerPhase) * 0.3;
                const gradient = ctx.createRadialGradient(
                    x - bubble.size * 0.3, 
                    y - bubble.size * 0.3, 
                    0,
                    x, 
                    y, 
                    bubble.size
                );
                gradient.addColorStop(0, `rgba(255, 255, 255, ${0.6 * shimmer})`);
                gradient.addColorStop(0.3, `rgba(200, 230, 255, ${0.3 * shimmer})`);
                gradient.addColorStop(0.7, `rgba(150, 200, 255, ${0.2 * shimmer})`);
                gradient.addColorStop(1, `rgba(100, 150, 255, ${0.1 * shimmer})`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, bubble.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Bubble outline
                ctx.strokeStyle = `rgba(200, 230, 255, ${0.3 * shimmer})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Highlight
                ctx.fillStyle = `rgba(255, 255, 255, ${0.7 * shimmer})`;
                ctx.beginPath();
                ctx.arc(x - bubble.size * 0.4, y - bubble.size * 0.4, bubble.size * 0.2, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();
            
            // Render rain drops
            ctx.save();
            ctx.globalAlpha = 0.6;
            effect.rainDrops.forEach(drop => {
                // Update rain position
                drop.y += drop.speed;
                if (drop.y > effect.radius * 60 + 100) {
                    drop.y = -effect.radius * 60 - 400 - Math.random() * 200;
                    drop.x = (Math.random() - 0.5) * effect.radius * 100;
                }
                
                const x = center.x + drop.x;
                const y = center.y + drop.y;
                
                // Rain drop gradient (pointing downward)
                const gradient = ctx.createLinearGradient(x, y - drop.length, x, y);
                gradient.addColorStop(0, `rgba(150, 200, 255, 0)`);
                gradient.addColorStop(1, `rgba(150, 200, 255, ${drop.opacity})`);
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(x, y - drop.length);
                ctx.lineTo(x, y);
                ctx.stroke();
            });
            
            ctx.restore();
        }
        
        function renderAetherEffect(ctx, center, effect) {
            const animTime = performance.now() * 0.0001;
            
            // Render floating air particles first (background)
            effect.airParticles.forEach((particle, i) => {
                // Update particle position
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.z += 0.1;  // Slight upward drift in z
                
                // Wrap around boundaries
                if (particle.x > effect.radius * 50) particle.x = -effect.radius * 50;
                if (particle.x < -effect.radius * 50) particle.x = effect.radius * 50;
                if (particle.y < -effect.radius * 40 - 100) {
                    particle.y = effect.radius * 40;
                    particle.x = (Math.random() - 0.5) * effect.radius * 100;
                }
                if (particle.z > 200) particle.z = 0;
                
                const x = center.x + particle.x;
                const y = center.y + particle.y - particle.z;
                
                // Twinkling effect
                const twinkle = 0.5 + Math.sin(animTime * 5 + particle.twinkle) * 0.5;
                const alpha = particle.opacity * twinkle;
                
                // Glow effect
                const glowSize = particle.size * 3;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
                gradient.addColorStop(0, `rgba(240, 250, 255, ${alpha * 0.5})`);
                gradient.addColorStop(0.5, `rgba(220, 240, 255, ${alpha * 0.2})`);
                gradient.addColorStop(1, 'rgba(200, 220, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Particle core
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Render wind streaks on top
            effect.windParticles.forEach((particle, i) => {
                // Spiral motion
                particle.angle += particle.speed * 0.005;
                particle.radius = effect.radius * 20 + Math.sin(animTime * 2 + i) * effect.radius * 10;  // Much larger radius
                
                const x = center.x + Math.cos(particle.angle) * particle.radius;
                const y = center.y + Math.sin(particle.angle) * particle.radius * 0.5;
                
                // Longer wind streaks
                ctx.strokeStyle = `rgba(220, 240, 255, ${particle.opacity})`;
                ctx.lineWidth = particle.size;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(x, y);
                const trailX = x - Math.cos(particle.angle) * 100;  // Longer trails
                const trailY = y - Math.sin(particle.angle) * 50;
                ctx.lineTo(trailX, trailY);
                ctx.stroke();
                
                // Add secondary trail for depth
                ctx.strokeStyle = `rgba(200, 220, 255, ${particle.opacity * 0.5})`;
                ctx.lineWidth = particle.size * 1.5;
                ctx.beginPath();
                ctx.moveTo(x - 10, y - 5);
                ctx.lineTo(trailX - 10, trailY - 5);
                ctx.stroke();
            });
        }
        
        function renderTerraEffect(ctx, center, effect) {
            const animTime = performance.now() * 0.0001;
            
            // Spawn new particles at crystal positions
            effect.crystals.forEach((crystal, crystalIndex) => {
                const angle = crystal.baseAngle + animTime * 0.3;
                const crystalX = center.x + Math.cos(angle) * crystal.orbitRadius;
                const crystalY = center.y + Math.sin(angle) * crystal.orbitRadius * 0.5 - crystal.height;
                
                // Spawn particles every few frames - reduced by 75% for Terra
                if (Math.random() < 0.075) {
                    for (let i = 0; i < 2; i++) {
                        // Check if crystal is purple or transitioning to adjust particle properties
                        const isPurple = crystal.struckByLightning || crystal.color === '#9B59B6' || crystal.color.includes('rgb(');
                        const speedMultiplier = isPurple ? 0.25 : 1; // 75% slower for purple
                        const lifeMultiplier = isPurple ? 1.75 : 1; // 75% longer for purple
                        
                        effect.crystalParticles.push({
                            x: crystalX,
                            y: crystalY,
                            vx: (Math.random() - 0.5) * 2 * speedMultiplier,
                            vy: (Math.random() - 0.5) * 2 * speedMultiplier,
                            life: 0,
                            maxLife: 1.5 * lifeMultiplier,
                            size: 1 + Math.random() * 2,
                            color: crystal.color
                        });
                    }
                }
            });
            
            // Update and render trail particles
            effect.crystalParticles = effect.crystalParticles.filter(particle => {
                // Update particle
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life += 0.01;
                
                // Check if particle is still alive
                if (particle.life >= particle.maxLife) {
                    return false;
                }
                
                // Fade based on life
                const alpha = (1 - particle.life / particle.maxLife) * 0.8;
                
                // Draw particle with simple glow (no gradient for performance)
                // Parse particle color to determine if it's purple or green
                const isPurple = particle.color === '#9B59B6' || particle.color.includes('rgb(');
                
                if (isPurple) {
                    // Purple particle for struck crystals with glow
                    // Add shadow blur for glow effect
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(155, 89, 182, 0.8)';
                    
                    // Outer glow
                    ctx.fillStyle = `rgba(155, 89, 182, ${alpha * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Middle glow
                    ctx.fillStyle = `rgba(180, 120, 200, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Particle core
                    ctx.fillStyle = `rgba(220, 180, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                } else {
                    // Green particle for normal crystals
                    // Outer glow
                    ctx.fillStyle = `rgba(50, 255, 50, ${alpha * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Middle glow
                    ctx.fillStyle = `rgba(100, 255, 100, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Particle core
                    ctx.fillStyle = `rgba(200, 255, 200, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                return true;
            });
            
            // Limit particle count for performance
            if (effect.crystalParticles.length > 500) {
                effect.crystalParticles = effect.crystalParticles.slice(-500);
            }
            
            // Earth particles removed
            
            // Render crystals with enhanced shine
            effect.crystals.forEach(crystal => {
                // Crystals remain purple permanently after being struck
                
                // Orbital motion
                const angle = crystal.baseAngle + animTime * 0.3;
                const x = center.x + Math.cos(angle) * crystal.orbitRadius;
                const y = center.y + Math.sin(angle) * crystal.orbitRadius * 0.5 - crystal.height;
                
                // Calculate rotation based on orbital position
                // Normalize angle to 0-2π
                let normalizedAngle = angle % (Math.PI * 2);
                if (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                
                // Map orbital position to tilt angle
                let tiltAngle = 0;
                const degToRad = Math.PI / 180;
                
                // Pattern is 3 positions early, shift back by 3π/4
                // Previous was -2π/3, so: -2π/3 - 3π/4 = -17π/12
                // Normalized: -17π/12 + 2π = 7π/12
                const alignedAngle = normalizedAngle + Math.PI * 7 / 12;
                
                // Apply sine for the correct pattern
                // This gives: top = 0°, right = 30°, bottom = 0°, left = -30°
                tiltAngle = Math.sin(alignedAngle) * 30 * degToRad;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(tiltAngle);
                
                // Dynamic shine effect
                const shineIntensity = 0.7 + Math.sin(animTime * 3 + crystal.shinePhase) * 0.3;
                
                // Add purple glow effect for struck crystals
                if (crystal.struckByLightning) {
                    const glowTime = (game.currentTick - crystal.lightningTime) / 600; // Normalize over 1 year
                    const glowIntensity = Math.max(0, 1 - glowTime * 0.5); // Fade over 2 years
                    
                    // Purple glow aura
                    ctx.shadowBlur = 20 + Math.sin(animTime * 5) * 10;
                    ctx.shadowColor = `rgba(155, 89, 182, ${glowIntensity})`;
                    
                    // Add pulsing effect
                    crystal.size = crystal.baseSize || crystal.size;
                    if (!crystal.baseSize) crystal.baseSize = crystal.size;
                    const pulseScale = 1 + Math.sin(animTime * 4) * 0.1 * glowIntensity;
                    crystal.size = crystal.baseSize * pulseScale;
                }
                
                // Crystal body with metallic gradient - make taller
                const crystalHeight = crystal.size * 1.5; // Taller crystals
                const gradient = ctx.createLinearGradient(-crystal.size * 0.8, -crystalHeight, crystal.size * 0.8, crystalHeight);
                
                if (crystal.struckByLightning) {
                    // Purple crystal gradient
                    gradient.addColorStop(0, '#FFFFFF');  // White shine
                    gradient.addColorStop(0.2, crystal.color);  // Purple
                    gradient.addColorStop(0.5, '#6B46C1');  // Darker purple
                    gradient.addColorStop(0.8, '#4A2E83');  // Even darker
                    gradient.addColorStop(1, '#2E1A47');   // Dark purple base
                } else {
                    // Normal green crystal gradient
                    gradient.addColorStop(0, '#FFFFFF');  // White shine
                    gradient.addColorStop(0.2, crystal.color);  // Main color
                    gradient.addColorStop(0.5, '#00AA00');  // Darker green
                    gradient.addColorStop(0.8, crystal.color);  // Main color again
                    gradient.addColorStop(1, '#005500');  // Dark green
                }
                
                ctx.fillStyle = gradient;
                
                // Draw taller hexagonal crystal
                ctx.beginPath();
                ctx.moveTo(0, -crystalHeight);
                ctx.lineTo(crystal.size * 0.5, -crystalHeight * 0.3);
                ctx.lineTo(crystal.size * 0.5, crystalHeight * 0.3);
                ctx.lineTo(0, crystalHeight);
                ctx.lineTo(-crystal.size * 0.5, crystalHeight * 0.3);
                ctx.lineTo(-crystal.size * 0.5, -crystalHeight * 0.3);
                ctx.closePath();
                ctx.fill();
                
                // Crystal highlight with dynamic shine
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 * shineIntensity})`;
                ctx.beginPath();
                ctx.moveTo(0, -crystalHeight);
                ctx.lineTo(crystal.size * 0.3, -crystalHeight * 0.5);
                ctx.lineTo(0, -crystalHeight * 0.3);
                ctx.lineTo(-crystal.size * 0.3, -crystalHeight * 0.5);
                ctx.closePath();
                ctx.fill();
                
                // Additional shine streaks
                // Removed the middle line that was drawing across the crystal
                
                // Glow effect
                const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, crystal.size * 1.5);
                if (crystal.struckByLightning) {
                    // Purple glow for struck crystals
                    const glowTime = (game.currentTick - crystal.lightningTime) / 600;
                    const glowIntensity = Math.max(0, 1 - glowTime * 0.5);
                    glowGradient.addColorStop(0, `rgba(155, 89, 182, ${0.5 * shineIntensity * glowIntensity})`);
                    glowGradient.addColorStop(0.5, `rgba(120, 60, 180, ${0.3 * shineIntensity * glowIntensity})`);
                    glowGradient.addColorStop(1, 'rgba(80, 40, 120, 0)');
                } else {
                    // Green glow for normal crystals
                    glowGradient.addColorStop(0, `rgba(0, 255, 0, ${0.3 * shineIntensity})`);
                    glowGradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
                }
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(0, 0, crystal.size * 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Reset shadow blur for struck crystals
                if (crystal.struckByLightning) {
                    ctx.shadowBlur = 0;
                }
                
                ctx.restore();
            });
        }
        
        function renderLuxEffectFromAbove(ctx, effect) {
            const animTime = performance.now() * 0.0001;
            
            // Update dust particles with optimized physics
            effect.dustParticles.forEach(particle => {
                // Update position
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.z += particle.vz;
                
                // Add gentle turbulence
                const turbulence = Math.sin(animTime * 2 + particle.x * 0.01) * 0.05;
                particle.x += turbulence;
                
                // Wrap around boundaries for infinite effect
                const worldBounds = WORLD_SIZE * 33; // Half of isometric world size
                if (particle.x < -worldBounds) particle.x = worldBounds;
                if (particle.x > worldBounds) particle.x = -worldBounds;
                if (particle.y < -worldBounds) particle.y = worldBounds;
                if (particle.y > worldBounds) particle.y = -worldBounds;
                
                // Remove particles that fall too low or move out of bounds
                if (particle.z < 0 || Math.abs(particle.x) > WORLD_SIZE * 50 || Math.abs(particle.y) > WORLD_SIZE * 50) {
                    // Mark for removal
                    particle.dead = true;
                }
                
                // Check if particle is in any light beam (angled beams)
                particle.inBeam = false;
                effect.beams.forEach(beam => {
                    
                    // Calculate beam position at particle height
                    // Map particle Y to a height factor (particles closer to bottom of screen = lower height)
                    const particleScreenHeight = (particle.y + WORLD_SIZE * 33) / (WORLD_SIZE * 66); // 0 to 1
                    const heightRatio = 1 - particleScreenHeight; // Invert so bottom = 0, top = 1
                    
                    // Calculate beam position at particle height using tile-based angle
                    const beamBottomX = beam.targetX;
                    
                    // Interpolate tile position based on height
                    const topTileX = beam.tileX - effect.beamAngleOffsetX;
                    const topTileY = beam.tileY - effect.beamAngleOffsetY;
                    const tileLerpX = beam.tileX + (topTileX - beam.tileX) * heightRatio;
                    const tileLerpY = beam.tileY + (topTileY - beam.tileY) * heightRatio;
                    
                    // Convert interpolated tile position to isometric
                    const lerpIso = worldToIsometric(tileLerpX, tileLerpY);
                    const beamXAtHeight = lerpIso.x;
                    
                    // No sway - beam is fixed in position
                    const beamCenterX = beamXAtHeight;
                    
                    // Uniform width from top to bottom
                    const halfWidth = beam.width / 2;
                    
                    // Check if particle is within the angled beam
                    if (particle.x > beamCenterX - halfWidth && particle.x < beamCenterX + halfWidth) {
                        particle.inBeam = true;
                    }
                });
            });
            
            // Remove dead particles
            effect.dustParticles = effect.dustParticles.filter(particle => !particle.dead);
            
            ctx.save();
            
            // Render god rays with optimized gradients
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.85;
            
            effect.beams.forEach(beam => {
                const beamX = beam.x; // No swaying
                const pulseOpacity = beam.currentOpacity; // No pulsing for stable appearance
                
                // Create angled gradient for god ray (matching the beam angle)
                const topY = -1000; // Start high above the world
                const bottomY = beam.targetY + 17; // End at the bottom edge of the capital
                // Calculate beam top position using tile coordinates for consistent angle
                const beamBottomX = beam.targetX; // Capital position
                // Calculate top position by going up and left in tile space
                const topTileX = beam.tileX - effect.beamAngleOffsetX;
                const topTileY = beam.tileY - effect.beamAngleOffsetY;
                const topIso = worldToIsometric(topTileX, topTileY);
                const beamTopX = topIso.x;
                
                // Create gradient that matches the angled beam
                const gradient = ctx.createLinearGradient(beamTopX, topY, beamBottomX, bottomY);
                gradient.addColorStop(0, `rgba(255, 255, 240, 0)`); // Fully transparent at top
                gradient.addColorStop(0.1, `rgba(255, 255, 240, ${pulseOpacity * 0.3})`); // Fade in quickly
                gradient.addColorStop(0.3, `rgba(255, 252, 220, ${pulseOpacity * 0.8})`);
                gradient.addColorStop(0.7, `rgba(255, 250, 210, ${pulseOpacity * 1.2})`);
                gradient.addColorStop(0.9, `rgba(255, 248, 200, ${pulseOpacity * 1.5})`); // Brighter near bottom
                gradient.addColorStop(1, `rgba(255, 245, 190, ${pulseOpacity * 1.8})`); // Brightest at bottom
                
                ctx.fillStyle = gradient;
                
                // Draw angled beam shape (from top-left to bottom-right)
                ctx.beginPath();
                const topWidth = beam.width;
                const bottomWidth = beam.width;
                const curveDepth = beam.width * 0.3; // How much the bottom curves outward
                
                // Top points
                ctx.moveTo(beamTopX - topWidth/2, topY);
                ctx.lineTo(beamTopX + topWidth/2, topY);
                
                // Right side down to bottom
                ctx.lineTo(beamBottomX + bottomWidth/2, bottomY);
                
                // Curved bottom using quadratic curve
                ctx.quadraticCurveTo(
                    beamBottomX, bottomY + curveDepth,  // Control point below center
                    beamBottomX - bottomWidth/2, bottomY  // End point on left
                );
                
                // Left side back up
                ctx.lineTo(beamTopX - topWidth/2, topY);
                
                ctx.closePath();
                ctx.fill();
            });
            
            // Render dust particles with batching for performance
            ctx.globalCompositeOperation = 'normal';
            
            // Batch particles by their state (in beam vs out of beam)
            const inBeamParticles = [];
            const outBeamParticles = [];
            
            effect.dustParticles.forEach(particle => {
                const x = particle.x;
                const y = particle.y - particle.z * 0.5; // Isometric height adjustment
                
                // Twinkling effect
                const twinkle = 0.7 + Math.sin(animTime * 8 + particle.twinkle) * 0.3;
                
                // Brightness based on beam intersection
                const brightness = particle.inBeam ? 
                    particle.brightness * twinkle : 
                    particle.brightness * 0.4 * twinkle;
                
                const alpha = particle.inBeam ? 0.9 : 0.5;
                const size = particle.size * (particle.inBeam ? 1.5 : 1);
                
                if (particle.inBeam) {
                    inBeamParticles.push({x, y, size, alpha: alpha * brightness});
                } else {
                    outBeamParticles.push({x, y, size, alpha: alpha * brightness});
                }
            });
            
            // Don't render out-of-beam particles at all
            
            // Render in-beam particles (brighter)
            ctx.fillStyle = 'rgba(255, 252, 220, 1)';
            inBeamParticles.forEach(p => {
                ctx.globalAlpha = p.alpha;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Render light sprites
            effect.lightSprites.forEach(sprite => {
                ctx.save();
                ctx.globalAlpha = sprite.opacity;
                ctx.translate(sprite.currentX, sprite.currentY);
                ctx.scale(sprite.scale, sprite.scale);
                
                // Draw multiple layers of glow for stronger effect
                ctx.globalCompositeOperation = 'screen';
                
                // Outer glow
                const outerGlow = ctx.createRadialGradient(0, -10, 0, 0, -10, 40);
                outerGlow.addColorStop(0, 'rgba(255, 252, 220, 0.2)');
                outerGlow.addColorStop(0.5, 'rgba(255, 248, 200, 0.1)');
                outerGlow.addColorStop(1, 'rgba(255, 252, 220, 0)');
                ctx.fillStyle = outerGlow;
                ctx.beginPath();
                ctx.arc(0, -10, 40, 0, Math.PI * 2);
                ctx.fill();
                
                // Middle glow
                const middleGlow = ctx.createRadialGradient(0, -10, 0, 0, -10, 25);
                middleGlow.addColorStop(0, 'rgba(255, 252, 220, 0.4)');
                middleGlow.addColorStop(1, 'rgba(255, 252, 220, 0)');
                ctx.fillStyle = middleGlow;
                ctx.beginPath();
                ctx.arc(0, -10, 25, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner bright core
                const innerGlow = ctx.createRadialGradient(0, -10, 0, 0, -10, 15);
                innerGlow.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                innerGlow.addColorStop(0.5, 'rgba(255, 252, 220, 0.7)');
                innerGlow.addColorStop(1, 'rgba(255, 252, 220, 0)');
                ctx.fillStyle = innerGlow;
                ctx.beginPath();
                ctx.arc(0, -10, 15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalCompositeOperation = 'source-over';
                
                // Draw the light sprite body
                ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                ctx.beginPath();
                ctx.ellipse(0, -10, 8, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw the arms
                ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                
                // Left arm
                ctx.beginPath();
                ctx.moveTo(-5, -5);
                ctx.lineTo(-5 - Math.cos(sprite.armAngle) * 10, -5 - Math.sin(sprite.armAngle) * 10);
                ctx.stroke();
                
                // Right arm
                ctx.beginPath();
                ctx.moveTo(5, -5);
                ctx.lineTo(5 + Math.cos(sprite.armAngle) * 10, -5 - Math.sin(sprite.armAngle) * 10);
                ctx.stroke();
                
                // Draw simple legs
                ctx.beginPath();
                ctx.moveTo(-3, 2);
                ctx.lineTo(-3, 10);
                ctx.moveTo(3, 2);
                ctx.lineTo(3, 10);
                ctx.stroke();
                
                ctx.restore();
            });
            
            ctx.restore();
        }
        
        function renderLuxEffect(ctx, center, effect) {
            const animTime = performance.now() * 0.0001;
            
            // Update dust particles
            effect.dustParticles.forEach(particle => {
                // Add slight turbulence for more dynamic movement
                const turbulence = Math.sin(animTime * 5 + particle.x * 0.01) * 0.1;
                
                // Update position - faster movement when in light beam
                const speedBoost = particle.inBeam ? 1.5 : 1.0;
                particle.x += (particle.vx + turbulence) * speedBoost;
                particle.y += particle.vy * speedBoost;
                particle.z += 0.25 * speedBoost;  // Faster rise
                
                // Wrap around boundaries
                if (Math.abs(particle.x) > effect.radius * 50) particle.x = -particle.x;
                if (particle.y < -effect.radius * 40 - 100) {
                    particle.y = effect.radius * 40;
                    particle.x = (Math.random() - 0.5) * effect.radius * 100;
                    particle.z = Math.random() * 150;
                }
                if (particle.z > 150) {
                    particle.z = 0;
                    particle.x = (Math.random() - 0.5) * effect.radius * 100;
                    particle.y = (Math.random() - 0.5) * effect.radius * 80;
                }
                
                // Check if particle is in any light beam
                particle.inBeam = false;
                const particleAngle = Math.atan2(particle.y - center.y, particle.x - center.x);
                const particleDistance = Math.sqrt(Math.pow(particle.x - center.x, 2) + Math.pow(particle.y - center.y, 2));
                
                effect.beams.forEach(beam => {
                    const beamAngle = beam.angle + Math.sin(animTime + beam.phase) * 0.1;
                    const angleDiff = Math.abs(((particleAngle - beamAngle + Math.PI * 3) % (Math.PI * 2)) - Math.PI);
                    const beamWidth = beam.width * (0.8 + Math.sin(animTime * 2 + beam.phase) * 0.2);
                    
                    // Check if particle is within beam cone
                    if (angleDiff < beamWidth / particleDistance && particleDistance < beam.length) {
                        particle.inBeam = true;
                    }
                });
            });
            
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            // Render light beams
            effect.beams.forEach(beam => {
                const rotation = beam.angle + Math.sin(animTime + beam.phase) * 0.1;
                const pulseWidth = beam.width * (0.8 + Math.sin(animTime * 2 + beam.phase) * 0.2);
                
                ctx.save();
                ctx.translate(center.x, center.y);
                ctx.rotate(rotation);
                
                // Light beam gradient
                const gradient = ctx.createLinearGradient(0, 0, beam.length, 0);
                gradient.addColorStop(0, `rgba(255, 255, 200, ${beam.opacity * 0.5})`);
                gradient.addColorStop(0.5, `rgba(255, 255, 150, ${beam.opacity})`);
                gradient.addColorStop(1, 'rgba(255, 255, 100, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(0, -pulseWidth / 2);
                ctx.lineTo(beam.length, -pulseWidth / 4);
                ctx.lineTo(beam.length, pulseWidth / 4);
                ctx.lineTo(0, pulseWidth / 2);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            });
            
            // Render dust particles (after beams so they appear on top)
            ctx.globalCompositeOperation = 'normal';
            effect.dustParticles.forEach(particle => {
                const x = center.x + particle.x;
                const y = center.y + particle.y - particle.z;
                
                // Twinkling effect
                const twinkle = 0.5 + Math.sin(animTime * 12 + particle.twinkle) * 0.5;  // Faster twinkle (was 8)
                
                // Brightness based on whether particle is in beam
                const brightness = particle.inBeam ? 
                    particle.brightness * twinkle : 
                    particle.brightness * 0.3 * twinkle;
                
                const alpha = particle.inBeam ? 0.8 : 0.4;
                
                // Glowing dust particle
                const glowSize = particle.size * (particle.inBeam ? 4 : 2);
                const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
                
                if (particle.inBeam) {
                    // Golden glow for particles in light beam
                    glowGradient.addColorStop(0, `rgba(255, 250, 205, ${alpha * brightness})`);
                    glowGradient.addColorStop(0.5, `rgba(255, 235, 170, ${alpha * brightness * 0.5})`);
                    glowGradient.addColorStop(1, 'rgba(255, 220, 130, 0)');
                } else {
                    // Subtle glow for particles outside beam
                    glowGradient.addColorStop(0, `rgba(255, 255, 230, ${alpha * brightness})`);
                    glowGradient.addColorStop(0.5, `rgba(255, 255, 200, ${alpha * brightness * 0.3})`);
                    glowGradient.addColorStop(1, 'rgba(255, 255, 170, 0)');
                }
                
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(x, y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Particle core
                ctx.fillStyle = particle.inBeam ? 
                    `rgba(255, 255, 230, ${brightness})` : 
                    `rgba(255, 255, 255, ${brightness * 0.5})`;
                ctx.beginPath();
                ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.restore();
        }
        
        function renderUmbraEffect(ctx, center, effect) {
            const animTime = performance.now() * 0.0001;
            
            // Update and render centered dark wisps
            effect.wisps.forEach(wisp => {
                // Gentle drift around base position
                const driftRadius = 20;
                wisp.x = wisp.baseX + Math.sin(animTime * 0.5 + wisp.driftPhase) * driftRadius;
                wisp.y = wisp.baseY + Math.cos(animTime * 0.4 + wisp.driftPhase) * driftRadius;
                
                const x = center.x + wisp.x;
                const y = center.y + wisp.y;
                
                // Pulsing size
                const size = wisp.size * (1 + Math.sin(animTime * 3 + wisp.phase) * 0.3);
                
                // Stronger multi-layered shadow for centered effect
                for (let layer = 0; layer < 4; layer++) { // Extra layer for more darkness
                    const layerSize = size * (1 + layer * 0.6);
                    const layerAlpha = wisp.opacity * (0.4 - layer * 0.08); // Stronger opacity
                    
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, layerSize);
                    gradient.addColorStop(0, `rgba(20, 0, 40, ${layerAlpha})`); // Darker core
                    gradient.addColorStop(0.5, `rgba(50, 0, 70, ${layerAlpha * 0.5})`);
                    gradient.addColorStop(1, 'rgba(80, 0, 100, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, layerSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Render ghosts
            effect.ghosts.forEach((ghost, index) => {
                const iso = worldToIsometric(ghost.x, ghost.y);
                const x = center.x + iso.x;
                const y = center.y + iso.y;
                
                // Check if this ghost is being followed
                var isFollowed = camera.followingEntity && 
                               camera.followingEntity.type === 'umbraGhost' &&
                               camera.followingEntity.ghostIndex === index;
                
                // Draw follow indicator if being followed
                if (isFollowed) {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y - 20, 25, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Pulsing inner circle
                    var pulseSize = 20 + Math.sin(Date.now() * 0.003) * 5;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y - 20, pulseSize, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Floating animation
                const floatY = y - 20 - Math.sin(animTime * 4 + ghost.floatPhase) * 5;
                
                ctx.save();
                ctx.globalAlpha = ghost.fadeIn * 0.6;
                
                // Ghost glow
                const glowGradient = ctx.createRadialGradient(x, floatY, 0, x, floatY, ghost.size * 2);
                glowGradient.addColorStop(0, 'rgba(200, 150, 255, 0.3)');
                glowGradient.addColorStop(0.5, 'rgba(150, 100, 200, 0.2)');
                glowGradient.addColorStop(1, 'rgba(100, 50, 150, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(x, floatY, ghost.size * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Ghost body (translucent figure)
                const bodyGradient = ctx.createLinearGradient(x, floatY - ghost.size, x, floatY + ghost.size);
                bodyGradient.addColorStop(0, 'rgba(220, 200, 255, 0.4)');
                bodyGradient.addColorStop(0.5, 'rgba(180, 150, 220, 0.3)');
                bodyGradient.addColorStop(1, 'rgba(150, 120, 200, 0.1)');
                
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                // Ghost shape (rounded top, wavy bottom)
                ctx.arc(x, floatY - ghost.size * 0.3, ghost.size * 0.7, Math.PI, 0);
                // Wavy bottom
                ctx.bezierCurveTo(
                    x + ghost.size * 0.7, floatY,
                    x + ghost.size * 0.5, floatY + ghost.size * 0.5,
                    x + ghost.size * 0.3, floatY + ghost.size
                );
                ctx.bezierCurveTo(
                    x, floatY + ghost.size * 0.7,
                    x - ghost.size * 0.3, floatY + ghost.size * 0.5,
                    x - ghost.size * 0.3, floatY + ghost.size
                );
                ctx.bezierCurveTo(
                    x - ghost.size * 0.5, floatY + ghost.size * 0.5,
                    x - ghost.size * 0.7, floatY,
                    x - ghost.size * 0.7, floatY - ghost.size * 0.3
                );
                ctx.closePath();
                ctx.fill();
                
                // Ghost eyes (glowing dots)
                ctx.fillStyle = 'rgba(255, 200, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(x - ghost.size * 0.2, floatY - ghost.size * 0.3, 2, 0, Math.PI * 2);
                ctx.arc(x + ghost.size * 0.2, floatY - ghost.size * 0.3, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
            
            // Render orbiting purple clouds at the edges
            ctx.save();
            ctx.globalAlpha = 0.6;
            
            effect.clouds.forEach(cloud => {
                // Update cloud position (orbiting)
                cloud.angle += cloud.speed * 0.01;
                
                const cloudX = center.x + Math.cos(cloud.angle) * cloud.radius;
                const cloudY = center.y + Math.sin(cloud.angle) * cloud.radius * 0.5 + cloud.heightOffset;
                
                // Create multi-part cloud
                const cloudParts = [
                    { dx: 0, dy: 0, size: cloud.size },
                    { dx: cloud.size * 0.6, dy: -cloud.size * 0.2, size: cloud.size * 0.8 },
                    { dx: -cloud.size * 0.5, dy: cloud.size * 0.1, size: cloud.size * 0.7 },
                    { dx: cloud.size * 0.3, dy: cloud.size * 0.2, size: cloud.size * 0.6 }
                ];
                
                cloudParts.forEach(part => {
                    const partX = cloudX + part.dx;
                    const partY = cloudY + part.dy;
                    
                    const cloudGradient = ctx.createRadialGradient(
                        partX, partY, part.size * 0.3,
                        partX, partY, part.size
                    );
                    cloudGradient.addColorStop(0, `rgba(100, 50, 150, ${cloud.opacity})`);
                    cloudGradient.addColorStop(0.4, `rgba(80, 30, 120, ${cloud.opacity * 0.7})`);
                    cloudGradient.addColorStop(0.7, `rgba(60, 20, 100, ${cloud.opacity * 0.4})`);
                    cloudGradient.addColorStop(1, 'rgba(40, 10, 80, 0)');
                    
                    ctx.fillStyle = cloudGradient;
                    ctx.beginPath();
                    ctx.arc(partX, partY, part.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Add inner glow to clouds
                const glowGradient = ctx.createRadialGradient(
                    cloudX, cloudY, 0,
                    cloudX, cloudY, cloud.size * 0.5
                );
                glowGradient.addColorStop(0, `rgba(150, 100, 200, ${cloud.opacity * 0.3})`);
                glowGradient.addColorStop(1, 'rgba(100, 50, 150, 0)');
                
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(cloudX, cloudY, cloud.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.restore();
        }
        
        function renderVitaEffect(ctx, center, effect) {
            const animTime = performance.now() * 0.001;
            
            // Update walking leaves in real-time if not using tick system
            if (!effect.useTickSystemForLeaves) {
                effect.updateWalkingLeaves();
            }
            
            // Render emanation rings first (background)
            effect.emanationRings.forEach(ring => {
                const x = center.x + ring.x;
                const y = center.y + ring.y;
                
                const ringGradient = ctx.createRadialGradient(x, y, Math.max(0, ring.radius - 10), x, y, ring.radius);
                ringGradient.addColorStop(0, 'rgba(150, 255, 150, 0)');
                ringGradient.addColorStop(0.7, `rgba(100, 255, 100, ${ring.opacity * 0.3})`);
                ringGradient.addColorStop(1, 'rgba(50, 255, 50, 0)');
                
                ctx.fillStyle = ringGradient;
                ctx.beginPath();
                ctx.arc(x, y, ring.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Render glow particles
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            // Sort particles by z-depth for 3D effect
            const sortedParticles = [...effect.glowParticles].sort((a, b) => a.z - b.z);
            
            sortedParticles.forEach(particle => {
                const particleX = center.x + particle.x;
                const particleY = center.y + particle.y;
                
                // Size based on depth
                const depthScale = 1 + particle.z / 200;
                const size = particle.size * depthScale;
                
                // Create gradient for each particle
                const particleGradient = ctx.createRadialGradient(
                    particleX, particleY, 0,
                    particleX, particleY, size
                );
                
                const color = `hsl(${particle.hue}, 80%, 70%)`;
                particleGradient.addColorStop(0, `hsla(${particle.hue}, 100%, 85%, ${particle.opacity})`);
                particleGradient.addColorStop(0.4, `hsla(${particle.hue}, 80%, 70%, ${particle.opacity * 0.6})`);
                particleGradient.addColorStop(1, `hsla(${particle.hue}, 60%, 50%, 0)`);
                
                ctx.fillStyle = particleGradient;
                ctx.beginPath();
                ctx.arc(particleX, particleY, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Add a bright core
                ctx.fillStyle = `hsla(${particle.hue + 10}, 100%, 95%, ${particle.opacity * 0.8})`;
                ctx.beginPath();
                ctx.arc(particleX, particleY, size * 0.3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.restore();
            
            // Render central world tree
            const treeBase = { x: center.x, y: center.y };
            
            // Save context and apply scale
            ctx.save();
            ctx.translate(treeBase.x, treeBase.y);
            ctx.scale(effect.worldTree.scale, effect.worldTree.scale);
            ctx.translate(-treeBase.x, -treeBase.y);
            
            // Enhanced multi-layered tree glow
            // Layer 1: Soft outer glow
            ctx.globalCompositeOperation = 'screen';
            const outerGlow = ctx.createRadialGradient(treeBase.x, treeBase.y - 400, 0, treeBase.x, treeBase.y - 400, 600);
            outerGlow.addColorStop(0, `rgba(100, 255, 150, ${effect.worldTree.glowIntensity * 0.05})`);
            outerGlow.addColorStop(0.3, `rgba(50, 255, 100, ${effect.worldTree.glowIntensity * 0.03})`);
            outerGlow.addColorStop(0.7, `rgba(150, 255, 200, ${effect.worldTree.glowIntensity * 0.02})`);
            outerGlow.addColorStop(1, 'rgba(200, 255, 220, 0)');
            
            ctx.fillStyle = outerGlow;
            ctx.beginPath();
            ctx.arc(treeBase.x, treeBase.y - 400, 600, 0, Math.PI * 2);
            ctx.fill();
            
            // Layer 2: Middle glow with color variation
            const middleGlow = ctx.createRadialGradient(treeBase.x, treeBase.y - 400, 0, treeBase.x, treeBase.y - 400, 450);
            middleGlow.addColorStop(0, `rgba(150, 255, 180, ${effect.worldTree.glowIntensity * 0.15})`);
            middleGlow.addColorStop(0.4, `rgba(100, 255, 150, ${effect.worldTree.glowIntensity * 0.08})`);
            middleGlow.addColorStop(0.8, `rgba(180, 255, 200, ${effect.worldTree.glowIntensity * 0.04})`);
            middleGlow.addColorStop(1, 'rgba(150, 255, 180, 0)');
            
            ctx.fillStyle = middleGlow;
            ctx.beginPath();
            ctx.arc(treeBase.x, treeBase.y - 400, 450, 0, Math.PI * 2);
            ctx.fill();
            
            // Layer 3: Inner bright glow
            const innerGlow = ctx.createRadialGradient(treeBase.x, treeBase.y - 400, 0, treeBase.x, treeBase.y - 400, 300);
            innerGlow.addColorStop(0, `rgba(200, 255, 220, ${effect.worldTree.glowIntensity * 0.25})`);
            innerGlow.addColorStop(0.5, `rgba(150, 255, 180, ${effect.worldTree.glowIntensity * 0.15})`);
            innerGlow.addColorStop(1, 'rgba(100, 255, 150, 0)');
            
            ctx.fillStyle = innerGlow;
            ctx.beginPath();
            ctx.arc(treeBase.x, treeBase.y - 400, 300, 0, Math.PI * 2);
            ctx.fill();
            
            // Layer 4: Core intense glow
            const coreGlow = ctx.createRadialGradient(treeBase.x, treeBase.y - 400, 0, treeBase.x, treeBase.y - 400, 150);
            coreGlow.addColorStop(0, `rgba(220, 255, 240, ${effect.worldTree.glowIntensity * 0.4})`);
            coreGlow.addColorStop(0.7, `rgba(180, 255, 200, ${effect.worldTree.glowIntensity * 0.2})`);
            coreGlow.addColorStop(1, 'rgba(150, 255, 180, 0)');
            
            ctx.fillStyle = coreGlow;
            ctx.beginPath();
            ctx.arc(treeBase.x, treeBase.y - 400, 150, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.globalCompositeOperation = 'source-over';
            
            // Draw simple shadow beneath the tree
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(treeBase.x + 30, treeBase.y - 5, 225, 72, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Draw thick curved trunk with natural organic shape
            const trunkHeight = 600; // Twice as tall (was 300)
            const trunkTopY = treeBase.y - trunkHeight;
            
            // Add slight natural lean to trunk
            const trunkLean = Math.sin(effect.worldTree.pulsePhase * 0.2) * 12;
            
            // Draw trunk shadow first for depth - more transparent
            ctx.fillStyle = `rgba(40, 30, 20, 0.15)`;
            ctx.beginPath();
            const shadowOffset = 6;
            
            // Base of trunk with root flare - even thinner
            const baseWidth = 50; // Reduced from 70
            const lowerMiddleWidth = 30; // Reduced from 45
            const upperMiddleWidth = 18; // Reduced from 25
            const topWidth = 8; // Reduced from 10
            const baseCurve = 20; // Less root flare
            
            // Shadow shape with organic irregularity
            ctx.moveTo(treeBase.x - baseWidth/2 + shadowOffset, treeBase.y);
            
            // Right root bulge
            ctx.bezierCurveTo(
                treeBase.x - baseWidth/3 + shadowOffset, treeBase.y + baseCurve/2,
                treeBase.x + baseWidth/3 + shadowOffset, treeBase.y + baseCurve/2,
                treeBase.x + baseWidth/2 + shadowOffset, treeBase.y
            );
            
            // Right side with natural curve - sharper taper
            ctx.bezierCurveTo(
                treeBase.x + baseWidth/2 + shadowOffset + 10, treeBase.y - trunkHeight * 0.15,
                treeBase.x + lowerMiddleWidth/2 + shadowOffset + trunkLean/3, treeBase.y - trunkHeight * 0.4,
                treeBase.x + upperMiddleWidth/2 + shadowOffset + trunkLean*0.7, treeBase.y - trunkHeight * 0.7,
            );
            ctx.bezierCurveTo(
                treeBase.x + upperMiddleWidth/2 + shadowOffset + trunkLean*0.8, treeBase.y - trunkHeight * 0.85,
                treeBase.x + topWidth/2 + shadowOffset + trunkLean, trunkTopY + 10,
                treeBase.x + topWidth/2 + shadowOffset + trunkLean, trunkTopY
            );
            
            // Top with slight irregularity
            ctx.lineTo(treeBase.x - topWidth/2 + shadowOffset + trunkLean, trunkTopY);
            
            // Left side
            ctx.bezierCurveTo(
                treeBase.x - topWidth/2 + shadowOffset + trunkLean, trunkTopY + 10,
                treeBase.x - upperMiddleWidth/2 + shadowOffset + trunkLean*0.8, treeBase.y - trunkHeight * 0.85,
                treeBase.x - upperMiddleWidth/2 + shadowOffset + trunkLean*0.7, treeBase.y - trunkHeight * 0.7
            );
            ctx.bezierCurveTo(
                treeBase.x - lowerMiddleWidth/2 + shadowOffset + trunkLean/3, treeBase.y - trunkHeight * 0.4,
                treeBase.x - baseWidth/2 + shadowOffset - 5, treeBase.y - trunkHeight * 0.15,
                treeBase.x - baseWidth/2 + shadowOffset, treeBase.y
            );
            
            ctx.closePath();
            ctx.fill();
            
            // Main trunk shape with multi-layer gradient for depth - more transparent
            const trunkGradient = ctx.createLinearGradient(
                treeBase.x - baseWidth/2 + trunkLean/2, 0, 
                treeBase.x + baseWidth/2 + trunkLean/2, 0
            );
            trunkGradient.addColorStop(0, `rgba(65, 45, 30, 0.4)`);
            trunkGradient.addColorStop(0.2, `rgba(85, 65, 45, 0.5)`);
            trunkGradient.addColorStop(0.5, `rgba(95, 75, 55, 0.5)`);
            trunkGradient.addColorStop(0.8, `rgba(75, 55, 35, 0.4)`);
            trunkGradient.addColorStop(1, `rgba(55, 40, 25, 0.35)`);
            
            ctx.fillStyle = trunkGradient;
            ctx.beginPath();
            
            // Bottom with root flare
            ctx.moveTo(treeBase.x - baseWidth/2, treeBase.y);
            
            // Natural root bulges
            ctx.bezierCurveTo(
                treeBase.x - baseWidth/3, treeBase.y + baseCurve/2,
                treeBase.x + baseWidth/3, treeBase.y + baseCurve/2,
                treeBase.x + baseWidth/2, treeBase.y
            );
            
            // Right side with organic bulge - sharper taper
            ctx.bezierCurveTo(
                treeBase.x + baseWidth/2 + 10, treeBase.y - trunkHeight * 0.15,
                treeBase.x + lowerMiddleWidth/2 + 8 + trunkLean/3, treeBase.y - trunkHeight * 0.4,
                treeBase.x + upperMiddleWidth/2 + 4 + trunkLean*0.7, treeBase.y - trunkHeight * 0.7
            );
            ctx.bezierCurveTo(
                treeBase.x + upperMiddleWidth/2 + 2 + trunkLean*0.8, treeBase.y - trunkHeight * 0.85,
                treeBase.x + topWidth/2 + trunkLean, trunkTopY + 5,
                treeBase.x + topWidth/2 + trunkLean, trunkTopY
            );
            
            // Top with natural variation - sharp point
            ctx.bezierCurveTo(
                treeBase.x + trunkLean, trunkTopY - 2,
                treeBase.x - topWidth/4 + trunkLean, trunkTopY - 1,
                treeBase.x - topWidth/2 + trunkLean, trunkTopY
            );
            
            // Left side with subtle S-curve
            ctx.bezierCurveTo(
                treeBase.x - topWidth/2 + trunkLean, trunkTopY + 5,
                treeBase.x - upperMiddleWidth/2 - 2 + trunkLean*0.8, treeBase.y - trunkHeight * 0.85,
                treeBase.x - upperMiddleWidth/2 - 4 + trunkLean*0.7, treeBase.y - trunkHeight * 0.7
            );
            ctx.bezierCurveTo(
                treeBase.x - lowerMiddleWidth/2 - 8 + trunkLean/3, treeBase.y - trunkHeight * 0.4,
                treeBase.x - baseWidth/2 - 5, treeBase.y - trunkHeight * 0.15,
                treeBase.x - baseWidth/2, treeBase.y
            );
            
            ctx.closePath();
            ctx.fill();
            
            // Add subtle horizontal bark rings only
            ctx.strokeStyle = `rgba(40, 25, 15, 0.1)`;  // More transparent
            for (let i = 0; i < 3; i++) {  // Fewer rings
                const y = treeBase.y - (i + 1) * 80 - Math.sin(i * 2.1) * 15;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                const width = baseWidth * (1 - (treeBase.y - y) / trunkHeight) * 0.8;
                const curveAmount = Math.sin(i * 1.3) * 2;  // Less curve
                ctx.moveTo(treeBase.x - width/2 + trunkLean * (1 - (treeBase.y - y) / trunkHeight), y);
                ctx.quadraticCurveTo(
                    treeBase.x + trunkLean * (1 - (treeBase.y - y) / trunkHeight), 
                    y + curveAmount,
                    treeBase.x + width/2 + trunkLean * (1 - (treeBase.y - y) / trunkHeight), 
                    y
                );
                ctx.stroke();
            }
            
            
            // Enhanced glowing veins on trunk with multiple layers
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            // Outer vein glow
            ctx.strokeStyle = `rgba(100, 255, 180, ${effect.worldTree.glowIntensity * 0.05})`;
            ctx.lineWidth = 8;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(treeBase.x, treeBase.y);
            const veinCurve = 15;
            ctx.bezierCurveTo(
                treeBase.x - veinCurve/2 + trunkLean/4, treeBase.y - trunkHeight * 0.3,
                treeBase.x + veinCurve/2 + trunkLean/2, treeBase.y - trunkHeight * 0.7,
                treeBase.x + trunkLean, trunkTopY
            );
            ctx.stroke();
            
            // Middle vein glow
            ctx.strokeStyle = `rgba(150, 255, 200, ${effect.worldTree.glowIntensity * 0.15})`;
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // Inner bright vein
            ctx.strokeStyle = `rgba(200, 255, 220, ${effect.worldTree.glowIntensity * 0.25})`;
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 15]);
            ctx.stroke();
            
            // Additional spiral veins
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                const spiralOffset = (i * 120) + effect.worldTree.pulsePhase * 20;
                const spiralX = Math.sin(spiralOffset * 0.01) * 20;
                ctx.moveTo(treeBase.x + spiralX, treeBase.y);
                ctx.bezierCurveTo(
                    treeBase.x - spiralX/2 + trunkLean/3, treeBase.y - trunkHeight * 0.25,
                    treeBase.x + spiralX + trunkLean/2, treeBase.y - trunkHeight * 0.5,
                    treeBase.x + spiralX/3 + trunkLean*0.8, treeBase.y - trunkHeight * 0.8
                );
                ctx.strokeStyle = `rgba(180, 255, 210, ${effect.worldTree.glowIntensity * 0.1})`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            ctx.restore();
            ctx.setLineDash([]);
            
            // Sort branches by length and draw shorter ones first for proper layering
            const branchesWithData = effect.worldTree.branches.map((branch, index) => {
                const endPoint = effect.calculateBranchEndpoint(branch, branch.lengthVariation);
                const length = Math.sqrt(endPoint.x * endPoint.x + endPoint.y * endPoint.y);
                return { branch, index, length };
            });
            
            // Sort by length (longer first, so shorter branches render on top)
            branchesWithData.sort((a, b) => b.length - a.length);
            
            // Draw branches with natural organic shapes
            branchesWithData.forEach(({ branch, index }) => {
                // Calculate starting position based on branch height along trunk
                const branchHeight = treeBase.y - trunkHeight * branch.heightPosition;
                const startY = branchHeight;
                    
                    // Calculate trunk width at this height for proper branch attachment
                    let trunkWidthAtHeight;
                    if (branch.heightPosition < 0.4) {
                        // Lower trunk area
                        const t = branch.heightPosition / 0.4;
                        trunkWidthAtHeight = baseWidth * (1 - t) + lowerMiddleWidth * t;
                    } else if (branch.heightPosition < 0.7) {
                        // Middle trunk area
                        const t = (branch.heightPosition - 0.4) / 0.3;
                        trunkWidthAtHeight = lowerMiddleWidth * (1 - t) + upperMiddleWidth * t;
                    } else {
                        // Upper trunk area
                        const t = (branch.heightPosition - 0.7) / 0.3;
                        trunkWidthAtHeight = upperMiddleWidth * (1 - t) + topWidth * t;
                    }
                    
                    // Organic branch distribution around trunk circumference
                    const branchSpread = Math.cos(branch.angle) * trunkWidthAtHeight * 0.4;
                    const trunkLeanAtHeight = trunkLean * branch.heightPosition;
                    const branchStartX = treeBase.x + branchSpread + trunkLeanAtHeight;
                    
                    // Use pre-calculated length variation
                    const endPoint = effect.calculateBranchEndpoint(branch, branch.lengthVariation);
                    
                    // Add natural sway and curve - enhanced sway based on height
                    const swayAmplitude = 8 + branch.heightPosition * 12; // More sway at top
                    const branchSway = Math.sin(effect.worldTree.pulsePhase * 0.3 + branch.swayOffset) * swayAmplitude;
                    const endX = branchStartX + endPoint.x + branchSway;
                    // Add significant downward droop to branch tips
                    const tipDroop = 30 + branch.lengthVariation * 25; // 30-60 pixel droop
                    const endY = startY + endPoint.y + tipDroop;
                    
                    // Multiple control points for S-curve with branch angle
                    const controlX1 = branchStartX + endPoint.x * 0.3;
                    const controlY1 = startY + endPoint.y * 0.2 + Math.sin(branch.branchAngle) * 40 + branch.curveVariation;
                    const controlX2 = branchStartX + endPoint.x * 0.7 + branchSway * 0.5;
                    // Make top half bend downwards much more (negative for downward)
                    const downwardBend = -(60 + branch.lengthVariation * 40); // Much more downward bend
                    const controlY2 = startY + endPoint.y * 0.6 + Math.sin(branch.branchAngle) * 20 + downwardBend;
                    
                    // Draw branch shadow with reduced opacity
                    ctx.strokeStyle = `rgba(30, 20, 10, 0.08)`;
                    ctx.lineWidth = branch.thickness + 1;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    ctx.moveTo(branchStartX + 5, startY);
                    ctx.bezierCurveTo(
                        controlX1 + 5, controlY1 + 3,
                        controlX2 + 5, controlY2 + 3,
                        endX + 5, endY
                    );
                    ctx.stroke();
                    
                    // Main branch with pre-calculated thickness
                    const branchThickness = branch.thickness;
                    
                    // Multi-tone branch coloring - more transparent
                    const branchGradient = ctx.createLinearGradient(branchStartX, startY, endX, endY);
                    branchGradient.addColorStop(0, `rgba(85, 65, 45, 0.4)`);
                    branchGradient.addColorStop(0.3, `rgba(90, 70, 50, 0.35)`);
                    branchGradient.addColorStop(0.7, `rgba(75, 55, 35, 0.3)`);
                    branchGradient.addColorStop(1, `rgba(65, 45, 25, 0.25)`);
                    
                    ctx.strokeStyle = branchGradient;
                    ctx.lineWidth = branchThickness;
                    ctx.beginPath();
                    ctx.moveTo(branchStartX, startY);
                    
                    // Natural S-curve using bezier
                    ctx.bezierCurveTo(
                        controlX1, controlY1,
                        controlX2, controlY2,
                        endX, endY
                    );
                    ctx.stroke();
                    
                    // Add subtle bark texture to branches
                    ctx.strokeStyle = `rgba(40, 25, 15, 0.1)`;
                    ctx.lineWidth = 0.5;
                    ctx.setLineDash([5, 8]);
                    ctx.beginPath();
                    ctx.moveTo(branchStartX, startY);
                    ctx.bezierCurveTo(
                        controlX1 - 2, controlY1,
                        controlX2 - 2, controlY2,
                        endX - 2, endY
                    );
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
            });
            
            // First pass: Draw all small branches
            branchesWithData.forEach(({ branch, index }) => {
                if (branch.subBranches.length === 0) return;
                
                // Calculate branch start and end for leaf positioning
                const branchHeight = treeBase.y - trunkHeight * branch.heightPosition;
                const startY = branchHeight;
                
                // Calculate trunk width and position
                let trunkWidthAtHeight;
                if (branch.heightPosition < 0.4) {
                    const t = branch.heightPosition / 0.4;
                    trunkWidthAtHeight = baseWidth * (1 - t) + lowerMiddleWidth * t;
                } else if (branch.heightPosition < 0.7) {
                    const t = (branch.heightPosition - 0.4) / 0.3;
                    trunkWidthAtHeight = lowerMiddleWidth * (1 - t) + upperMiddleWidth * t;
                } else {
                    const t = (branch.heightPosition - 0.7) / 0.3;
                    trunkWidthAtHeight = upperMiddleWidth * (1 - t) + topWidth * t;
                }
                
                const branchSpread = Math.cos(branch.angle) * trunkWidthAtHeight * 0.4;
                const trunkLeanAtHeight = trunkLean * branch.heightPosition;
                const branchStartX = treeBase.x + branchSpread + trunkLeanAtHeight;
                
                const endPoint = effect.calculateBranchEndpoint(branch, branch.lengthVariation);
                const swayAmplitude = 8 + branch.heightPosition * 12;
                const branchSway = Math.sin(effect.worldTree.pulsePhase * 0.3 + branch.swayOffset) * swayAmplitude;
                
                // Draw each small branch and its leaves
                branch.subBranches.forEach(smallBranch => {
                    // Calculate small branch position along main branch using bezier interpolation
                    const t = smallBranch.position; // Position along curve (0-1)
                    
                    // Calculate position on bezier curve
                    // B(t) = (1-t)³P0 + 3(1-t)²tP1 + 3(1-t)t²P2 + t³P3
                    const t2 = t * t;
                    const t3 = t2 * t;
                    const mt = 1 - t;
                    const mt2 = mt * mt;
                    const mt3 = mt2 * mt;
                    
                    // Control points from branch rendering
                    const controlX1 = branchStartX + endPoint.x * 0.3;
                    const controlY1 = startY + endPoint.y * 0.2 + Math.sin(branch.branchAngle) * 40 + branch.curveVariation;
                    const controlX2 = branchStartX + endPoint.x * 0.7 + branchSway * 0.5;
                    const downwardBend = -(60 + branch.lengthVariation * 40);
                    const controlY2 = startY + endPoint.y * 0.6 + Math.sin(branch.branchAngle) * 20 + downwardBend;
                    const tipDroop = 30 + branch.lengthVariation * 25;
                    const endX = branchStartX + endPoint.x + branchSway;
                    const endY = startY + endPoint.y + tipDroop;
                    
                    // Cubic bezier curve position for small branch start
                    const smallBranchStartX = mt3 * branchStartX + 
                                  3 * mt2 * t * controlX1 + 
                                  3 * mt * t2 * controlX2 + 
                                  t3 * endX;
                    const smallBranchStartY = mt3 * startY + 
                                  3 * mt2 * t * controlY1 + 
                                  3 * mt * t2 * controlY2 + 
                                  t3 * endY;
                    
                    // Calculate main branch angle at this point
                    const mainBranchDX = endX - branchStartX;
                    const mainBranchDY = endY - startY;
                    const mainBranchAngle = Math.atan2(mainBranchDY, mainBranchDX);
                    
                    // Small branch angle is relative to main branch
                    const absoluteSmallBranchAngle = mainBranchAngle + smallBranch.angle;
                    
                    // Calculate small branch end position
                    const smallBranchEndX = smallBranchStartX + Math.cos(absoluteSmallBranchAngle) * smallBranch.length;
                    const smallBranchEndY = smallBranchStartY + Math.sin(absoluteSmallBranchAngle) * smallBranch.length * 0.5 + smallBranch.length * 0.2; // Slight droop
                    
                    // Draw small branch with taper
                    // Create a tapered path
                    ctx.save();
                    
                    // Branch color - use index for consistent color
                    const branchBrightness = 0.25 + (index * 0.01) % 0.1;
                    ctx.fillStyle = `rgba(75, 55, 35, ${branchBrightness})`;
                    
                    // Calculate control point with curvature
                    const smallControlX = smallBranchStartX + (smallBranchEndX - smallBranchStartX) * 0.5;
                    const curveAmount = smallBranch.length * smallBranch.curvature;
                    const smallControlY = smallBranchStartY + (smallBranchEndY - smallBranchStartY) * 0.5 + curveAmount;
                    
                    // Draw tapered branch using filled path
                    ctx.beginPath();
                    
                    // Start with full thickness
                    const startThickness = smallBranch.thickness;
                    const endThickness = startThickness * 0.3; // Taper to 30% of start
                    
                    // Top edge of branch
                    ctx.moveTo(smallBranchStartX, smallBranchStartY - startThickness/2);
                    ctx.quadraticCurveTo(
                        smallControlX, smallControlY - startThickness/2,
                        smallBranchEndX, smallBranchEndY - endThickness/2
                    );
                    
                    // Bottom edge of branch (reverse)
                    ctx.lineTo(smallBranchEndX, smallBranchEndY + endThickness/2);
                    ctx.quadraticCurveTo(
                        smallControlX, smallControlY + startThickness/2,
                        smallBranchStartX, smallBranchStartY + startThickness/2
                    );
                    
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add subtle edge highlight
                    ctx.strokeStyle = `rgba(90, 70, 50, 0.15)`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                    
                    ctx.restore();
                });
            });
            
            // Second pass: Draw all leaves
            branchesWithData.forEach(({ branch, index }) => {
                if (branch.subBranches.length === 0) return;
                
                // Recalculate branch positions for leaves
                const branchHeight = treeBase.y - trunkHeight * branch.heightPosition;
                const startY = branchHeight;
                
                let trunkWidthAtHeight;
                if (branch.heightPosition < 0.4) {
                    const t = branch.heightPosition / 0.4;
                    trunkWidthAtHeight = baseWidth * (1 - t) + lowerMiddleWidth * t;
                } else if (branch.heightPosition < 0.7) {
                    const t = (branch.heightPosition - 0.4) / 0.3;
                    trunkWidthAtHeight = lowerMiddleWidth * (1 - t) + upperMiddleWidth * t;
                } else {
                    const t = (branch.heightPosition - 0.7) / 0.3;
                    trunkWidthAtHeight = upperMiddleWidth * (1 - t) + topWidth * t;
                }
                
                const branchSpread = Math.cos(branch.angle) * trunkWidthAtHeight * 0.4;
                const trunkLeanAtHeight = trunkLean * branch.heightPosition;
                const branchStartX = treeBase.x + branchSpread + trunkLeanAtHeight;
                
                const endPoint = effect.calculateBranchEndpoint(branch, branch.lengthVariation);
                const swayAmplitude = 8 + branch.heightPosition * 12;
                const branchSway = Math.sin(effect.worldTree.pulsePhase * 0.3 + branch.swayOffset) * swayAmplitude;
                
                const tipDroop = 30 + branch.lengthVariation * 25;
                const endX = branchStartX + endPoint.x + branchSway;
                const endY = startY + endPoint.y + tipDroop;
                
                branch.subBranches.forEach(smallBranch => {
                    const t = smallBranch.position;
                    const t2 = t * t;
                    const t3 = t2 * t;
                    const mt = 1 - t;
                    const mt2 = mt * mt;
                    const mt3 = mt2 * mt;
                    
                    const controlX1 = branchStartX + endPoint.x * 0.3;
                    const controlY1 = startY + endPoint.y * 0.2 + Math.sin(branch.branchAngle) * 40 + branch.curveVariation;
                    const controlX2 = branchStartX + endPoint.x * 0.7 + branchSway * 0.5;
                    const downwardBend = -(60 + branch.lengthVariation * 40);
                    const controlY2 = startY + endPoint.y * 0.6 + Math.sin(branch.branchAngle) * 20 + downwardBend;
                    
                    const smallBranchStartX = mt3 * branchStartX + 
                                  3 * mt2 * t * controlX1 + 
                                  3 * mt * t2 * controlX2 + 
                                  t3 * endX;
                    const smallBranchStartY = mt3 * startY + 
                                  3 * mt2 * t * controlY1 + 
                                  3 * mt * t2 * controlY2 + 
                                  t3 * endY;
                    
                    const mainBranchDX = endX - branchStartX;
                    const mainBranchDY = endY - startY;
                    const mainBranchAngle = Math.atan2(mainBranchDY, mainBranchDX);
                    const absoluteSmallBranchAngle = mainBranchAngle + smallBranch.angle;
                    
                    const smallBranchEndX = smallBranchStartX + Math.cos(absoluteSmallBranchAngle) * smallBranch.length;
                    const smallBranchEndY = smallBranchStartY + Math.sin(absoluteSmallBranchAngle) * smallBranch.length * 0.5 + smallBranch.length * 0.2;
                    
                    // Draw leaves on small branch
                    smallBranch.leaves.forEach(leaf => {
                        // Calculate leaf position along small branch
                        const leafT = leaf.position;
                        const leafBaseX = smallBranchStartX + (smallBranchEndX - smallBranchStartX) * leafT;
                        const leafBaseY = smallBranchStartY + (smallBranchEndY - smallBranchStartY) * leafT;
                        
                        // Use the already calculated absolute small branch angle
                        const branchAngle = absoluteSmallBranchAngle;
                        
                        // Leaf should grow outward from branch
                        // Use leaf.angle as offset from branch direction (-1 to 1 range)
                        const leafDirection = branchAngle + (leaf.angle - Math.PI) * 0.3; // Reduced spread
                        
                        // Position leaf at its base (no offset)
                        const leafX = leafBaseX;
                        const leafY = leafBaseY;
                        
                        // Add sway effect
                        const leafSway = Math.sin(effect.worldTree.pulsePhase * 0.5 + leaf.swayOffset) * 0.15; // Reduced sway
                        const finalX = leafX + branchSway * 0.3;
                        const finalY = leafY;
                        
                        // Draw teardrop-shaped leaf
                        ctx.save();
                        ctx.translate(finalX, finalY);
                        // Rotate leaf to point away from branch
                        ctx.rotate(leafDirection + Math.PI/2 + leafSway);
                        
                        // Create gradient for leaf
                        const leafGradient = ctx.createRadialGradient(0, -leaf.size/3, 0, 0, 0, leaf.size);
                        leafGradient.addColorStop(0, `rgba(${leaf.color.r}, ${leaf.color.g}, ${leaf.color.b}, ${leaf.opacity})`);
                        leafGradient.addColorStop(0.7, `rgba(${leaf.color.r - 20}, ${leaf.color.g - 20}, ${leaf.color.b - 10}, ${leaf.opacity * 0.7})`);
                        leafGradient.addColorStop(1, `rgba(${leaf.color.r - 40}, ${leaf.color.g - 40}, ${leaf.color.b - 20}, 0)`);
                        
                        ctx.fillStyle = leafGradient;
                        
                        // Draw teardrop shape
                        ctx.beginPath();
                        ctx.moveTo(0, -leaf.size);
                        ctx.bezierCurveTo(
                            -leaf.size * 0.5, -leaf.size * 0.7,
                            -leaf.size * 0.4, leaf.size * 0.2,
                            0, leaf.size * 0.4
                        );
                        ctx.bezierCurveTo(
                            leaf.size * 0.4, leaf.size * 0.2,
                            leaf.size * 0.5, -leaf.size * 0.7,
                            0, -leaf.size
                        );
                        ctx.fill();
                        
                        // Add subtle vein
                        ctx.strokeStyle = `rgba(${leaf.color.r - 30}, ${leaf.color.g - 30}, ${leaf.color.b - 20}, ${leaf.opacity * 0.3})`;
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(0, -leaf.size);
                        ctx.lineTo(0, leaf.size * 0.2);
                        ctx.stroke();
                        
                        ctx.restore();
                    });
                });
            });
            
            // Restore context after scaling
            ctx.restore();
            
            // Separate walking leaves by position relative to tree
            const trunkTile = isometricToTile(0, 0);
            const leavesAbove = [];
            const leavesBelow = [];
            
            effect.walkingLeaves.forEach(leaf => {
                const leafTileY = leaf.state === 'walking' ? leaf.currentY : isometricToTile(leaf.targetX, leaf.targetY).y;
                if (leafTileY < trunkTile.y) {
                    leavesAbove.push(leaf);
                } else {
                    leavesBelow.push(leaf);
                }
            });
            
            // Render leaves above the tree (behind it)
            leavesAbove.forEach((leaf, index) => {
                const pos = effect.getLeafPosition(leaf);
                
                // Check if this leaf is being followed
                var isFollowed = camera.followingEntity && 
                               camera.followingEntity.type === 'vitaLeaf' &&
                               camera.followingEntity.leafIndex === effect.walkingLeaves.indexOf(leaf);
                
                // Draw follow indicator if being followed and walking
                if (isFollowed && leaf.state === 'walking') {
                    ctx.save();
                    const leafWorldPos = worldToIsometric(leaf.currentX, leaf.currentY);
                    ctx.translate(center.x + leafWorldPos.x, center.y + leafWorldPos.y);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 20, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Pulsing inner circle
                    var pulseSize = 15 + Math.sin(Date.now() * 0.003) * 3;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Draw shadow always, including when falling
                ctx.save();
                ctx.globalAlpha = 0.15; // Same transparency as unit shadows
                ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                
                if (leaf.state === 'falling') {
                    // For falling leaves, project shadow to ground level
                    const groundY = leaf.targetY;
                    const shadowY = groundY - (leaf.fallingY - leaf.targetY) * 0.1; // Shadow gets closer as leaf falls
                    ctx.translate(center.x + leaf.targetX, center.y + shadowY);
                } else {
                    ctx.translate(center.x + pos.x + 3, center.y + pos.y + 2); // Slight offset for shadow
                }
                
                ctx.beginPath();
                ctx.ellipse(0, leaf.size * 0.4, leaf.size * 0.4, leaf.size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                ctx.save();
                ctx.globalAlpha = leaf.opacity;
                ctx.translate(center.x + pos.x, center.y + pos.y);
                
                // Rotation and tilt based on state
                if (leaf.state === 'falling') {
                    ctx.rotate(leaf.rotation);
                } else if (leaf.state === 'standing') {
                    // Gradually stand up - interpolate from horizontal to vertical
                    const standProgress = Math.min(leaf.standingTimer / 90, 1); // 5x faster
                    const tiltAngle = (Math.PI / 2) * (1 - standProgress); // Start horizontal, end vertical
                    ctx.rotate(tiltAngle);
                } else if (leaf.state === 'dying') {
                    // Lay down animation - go from vertical to horizontal
                    const dyingProgress = Math.min((leaf.maxAge - leaf.age) / 300, 1);
                    const tiltAngle = (Math.PI / 2) * (1 - dyingProgress) * (leaf.dyingDirection || 1);
                    ctx.rotate(tiltAngle);
                }
                
                // Create gradient for leaf
                const leafGradient = ctx.createRadialGradient(0, -leaf.size/3, 0, 0, 0, leaf.size);
                leafGradient.addColorStop(0, `rgba(${leaf.color.r}, ${leaf.color.g}, ${leaf.color.b}, 1)`);
                leafGradient.addColorStop(0.7, `rgba(${leaf.color.r - 20}, ${leaf.color.g - 20}, ${leaf.color.b - 10}, 0.8)`);
                leafGradient.addColorStop(1, `rgba(${leaf.color.r - 40}, ${leaf.color.g - 40}, ${leaf.color.b - 20}, 0)`);
                
                ctx.fillStyle = leafGradient;
                
                // Draw leaf shape - always same size
                ctx.beginPath();
                ctx.moveTo(0, -leaf.size);
                ctx.bezierCurveTo(
                    -leaf.size * 0.5, -leaf.size * 0.7,
                    -leaf.size * 0.4, leaf.size * 0.2,
                    0, leaf.size * 0.4
                );
                ctx.bezierCurveTo(
                    leaf.size * 0.4, leaf.size * 0.2,
                    leaf.size * 0.5, -leaf.size * 0.7,
                    0, -leaf.size
                );
                ctx.fill();
                
                ctx.restore();
            });
            
            // Render leaf particles (after tree rendering so they appear in front)
            effect.leafParticles.forEach(particle => {
                ctx.save();
                ctx.translate(center.x + particle.x, center.y + particle.y);
                ctx.rotate(particle.rotation);
                
                // Create gradient for particle
                const particleGradient = ctx.createRadialGradient(0, -particle.size/3, 0, 0, 0, particle.size);
                particleGradient.addColorStop(0, `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${particle.opacity})`);
                particleGradient.addColorStop(0.7, `rgba(${particle.color.r - 20}, ${particle.color.g - 20}, ${particle.color.b - 10}, ${particle.opacity * 0.7})`);
                particleGradient.addColorStop(1, `rgba(${particle.color.r - 40}, ${particle.color.g - 40}, ${particle.color.b - 20}, 0)`);
                
                ctx.fillStyle = particleGradient;
                
                // Draw small teardrop-shaped leaf particle
                ctx.beginPath();
                ctx.moveTo(0, -particle.size);
                ctx.bezierCurveTo(
                    -particle.size * 0.5, -particle.size * 0.7,
                    -particle.size * 0.4, particle.size * 0.2,
                    0, particle.size * 0.4
                );
                ctx.bezierCurveTo(
                    particle.size * 0.4, particle.size * 0.2,
                    particle.size * 0.5, -particle.size * 0.7,
                    0, -particle.size
                );
                ctx.fill();
                
                ctx.restore();
            });
            
            // Render leaves below or at the tree (in front of it)
            leavesBelow.forEach((leaf, index) => {
                const pos = effect.getLeafPosition(leaf);
                
                // Check if this leaf is being followed
                var isFollowed = camera.followingEntity && 
                               camera.followingEntity.type === 'vitaLeaf' &&
                               camera.followingEntity.leafIndex === effect.walkingLeaves.indexOf(leaf);
                
                // Draw follow indicator if being followed and walking
                if (isFollowed && leaf.state === 'walking') {
                    ctx.save();
                    const leafWorldPos = worldToIsometric(leaf.currentX, leaf.currentY);
                    ctx.translate(center.x + leafWorldPos.x, center.y + leafWorldPos.y);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 20, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Pulsing inner circle
                    var pulseSize = 15 + Math.sin(Date.now() * 0.003) * 3;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Draw shadow always, including when falling
                ctx.save();
                ctx.globalAlpha = 0.15; // Same transparency as unit shadows
                ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                
                if (leaf.state === 'falling') {
                    // For falling leaves, project shadow to ground level
                    const groundY = leaf.targetY;
                    const shadowY = groundY - (leaf.fallingY - leaf.targetY) * 0.1; // Shadow gets closer as leaf falls
                    ctx.translate(center.x + leaf.targetX, center.y + shadowY);
                } else {
                    ctx.translate(center.x + pos.x + 3, center.y + pos.y + 2); // Slight offset for shadow
                }
                
                ctx.beginPath();
                ctx.ellipse(0, leaf.size * 0.4, leaf.size * 0.4, leaf.size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                ctx.save();
                ctx.globalAlpha = leaf.opacity;
                ctx.translate(center.x + pos.x, center.y + pos.y);
                
                // Rotation and tilt based on state
                if (leaf.state === 'falling') {
                    ctx.rotate(leaf.rotation);
                } else if (leaf.state === 'standing') {
                    // Gradually stand up - interpolate from horizontal to vertical
                    const standProgress = Math.min(leaf.standingTimer / 90, 1); // 5x faster
                    const tiltAngle = (Math.PI / 2) * (1 - standProgress); // Start horizontal, end vertical
                    ctx.rotate(tiltAngle);
                } else if (leaf.state === 'dying') {
                    // Lay down animation - go from vertical to horizontal
                    const dyingProgress = Math.min((leaf.maxAge - leaf.age) / 300, 1);
                    const tiltAngle = (Math.PI / 2) * (1 - dyingProgress) * (leaf.dyingDirection || 1);
                    ctx.rotate(tiltAngle);
                }
                
                // Create gradient for leaf
                const leafGradient = ctx.createRadialGradient(0, -leaf.size/3, 0, 0, 0, leaf.size);
                leafGradient.addColorStop(0, `rgba(${leaf.color.r}, ${leaf.color.g}, ${leaf.color.b}, 1)`);
                leafGradient.addColorStop(0.7, `rgba(${leaf.color.r - 20}, ${leaf.color.g - 20}, ${leaf.color.b - 10}, 0.8)`);
                leafGradient.addColorStop(1, `rgba(${leaf.color.r - 40}, ${leaf.color.g - 40}, ${leaf.color.b - 20}, 0)`);
                
                ctx.fillStyle = leafGradient;
                
                // Draw leaf shape - always same size
                ctx.beginPath();
                ctx.moveTo(0, -leaf.size);
                ctx.bezierCurveTo(
                    -leaf.size * 0.5, -leaf.size * 0.7,
                    -leaf.size * 0.4, leaf.size * 0.2,
                    0, leaf.size * 0.4
                );
                ctx.bezierCurveTo(
                    leaf.size * 0.4, leaf.size * 0.2,
                    leaf.size * 0.5, -leaf.size * 0.7,
                    0, -leaf.size
                );
                ctx.fill();
                
                ctx.restore();
            });
        }
        
        function render() {
            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Handle entity following
                if (camera.followingEntity && camera.viewMode === 'world') {
                    var entity = camera.followingEntity.entity;
                    var stillExists = false;
                    var pos = null;
                    
                    // Check if entity still exists and get position based on type
                    switch (camera.followingEntity.type) {
                        case 'army':
                            if (entity.alive && entity.size > 0) {
                                pos = entity.getPosition();
                                stillExists = true;
                            }
                            break;
                            
                        case 'recruit':
                            if (entity.alive && entity.size > 0) {
                                pos = entity.getPosition();
                                stillExists = true;
                            }
                            break;
                            
                        case 'giantFish':
                            if (game.giantFish.active) {
                                pos = { x: game.giantFish.x, y: game.giantFish.y };
                                stillExists = true;
                            }
                            break;
                            
                        case 'terraWitch':
                            if (game.terraWitch.active) {
                                pos = { x: game.terraWitch.x, y: game.terraWitch.y };
                                stillExists = true;
                            }
                            break;
                            
                        case 'nomadWagon':
                            // Check if the nomad tribe and specific wagon still exist
                            if (camera.currentWorld.nomadTribe && 
                                camera.currentWorld.nomadTribe.wagons[camera.followingEntity.wagonIndex]) {
                                var wagon = camera.currentWorld.nomadTribe.wagons[camera.followingEntity.wagonIndex];
                                pos = { x: wagon.x, y: wagon.y };
                                stillExists = true;
                            }
                            break;
                            
                        case 'umbraGhost':
                            // Check if the ghost still exists
                            if (camera.currentWorld.effect && 
                                camera.currentWorld.effect.ghosts &&
                                camera.currentWorld.effect.ghosts[camera.followingEntity.ghostIndex]) {
                                var ghost = camera.currentWorld.effect.ghosts[camera.followingEntity.ghostIndex];
                                pos = { x: ghost.x, y: ghost.y };
                                stillExists = true;
                            }
                            break;
                            
                        case 'ignisShadow':
                            // Check if the shadow still exists
                            if (camera.currentWorld.effect && 
                                camera.currentWorld.effect.shadowArmies &&
                                camera.currentWorld.effect.shadowArmies[camera.followingEntity.shadowIndex]) {
                                var shadow = camera.currentWorld.effect.shadowArmies[camera.followingEntity.shadowIndex];
                                // Shadow armies use route and routeIndex
                                if (shadow.route && shadow.route.length > 0) {
                                    var currentPos = shadow.route[Math.min(shadow.routeIndex, shadow.route.length - 1)];
                                    pos = { x: currentPos.x, y: currentPos.y };
                                    stillExists = true;
                                }
                            }
                            break;
                            
                        case 'vitaLeaf':
                            // Check if the leaf still exists and is walking
                            if (camera.currentWorld.effect && 
                                camera.currentWorld.effect.walkingLeaves &&
                                camera.currentWorld.effect.walkingLeaves[camera.followingEntity.leafIndex]) {
                                var leaf = camera.currentWorld.effect.walkingLeaves[camera.followingEntity.leafIndex];
                                if (leaf.state === 'walking') {
                                    pos = { x: leaf.currentX, y: leaf.currentY };
                                    stillExists = true;
                                }
                            }
                            break;
                    }
                    
                    if (!stillExists) {
                        camera.followingEntity = null;
                    } else if (pos) {
                        // Convert tile position to isometric coordinates
                        var iso = worldToIsometric(pos.x, pos.y);
                        var targetX = -iso.x;
                        var targetY = -iso.y;
                        
                        // Smooth camera movement
                        camera.x += (targetX - camera.x) * camera.followSmoothness;
                        camera.y += (targetY - camera.y) * camera.followSmoothness;
                    }
                }
                
                // Update portal cooldown
                if (camera.portalCooldown > 0) {
                    camera.portalCooldown--;
                }
                
                // Check for portal proximity when zoomed in
                if (camera.viewMode === 'world' && camera.currentWorld && camera.zoom >= 2.5 && 
                    !camera.isPortalTransitioning && camera.portalCooldown <= 0) {
                    const centerWorldPos = screenToWorld(canvas.width / 2, canvas.height / 2);
                    const centerTilePos = isometricToTile(centerWorldPos.x, centerWorldPos.y);
                    
                    // Ensure tile position is within bounds
                    if (centerTilePos.x >= 0 && centerTilePos.x < WORLD_SIZE && 
                        centerTilePos.y >= 0 && centerTilePos.y < WORLD_SIZE) {
                        
                        for (const portal of game.portals) {
                            let isNearPortal = false;
                            let destWorldId = -1;
                            let destPortalPos = null;
                            
                            if (portal.worldA === camera.currentWorld.id) {
                                const dist = Math.abs(portal.tileA.x - centerTilePos.x) + Math.abs(portal.tileA.y - centerTilePos.y);
                                if (dist <= 8) {
                                    isNearPortal = true;
                                    destWorldId = portal.worldB;
                                    destPortalPos = portal.tileB;
                                }
                            } else if (portal.worldB === camera.currentWorld.id) {
                                const dist = Math.abs(portal.tileB.x - centerTilePos.x) + Math.abs(portal.tileB.y - centerTilePos.y);
                                if (dist <= 8) {
                                    isNearPortal = true;
                                    destWorldId = portal.worldA;
                                    destPortalPos = portal.tileA;
                                }
                            }
                            
                            if (isNearPortal && destWorldId !== -1 && destWorldId < worlds.length) {
                                camera.isPortalTransitioning = true;
                                camera.portalCooldown = 90; // 3 seconds at 30 FPS
                                setTimeout(() => {
                                    camera.currentWorld = worlds[destWorldId];
                                    const destIso = worldToIsometric(destPortalPos.x, destPortalPos.y);
                                    camera.x = -destIso.x;
                                    camera.y = -destIso.y;
                                    document.getElementById('viewMode').textContent = 'World: ' + camera.currentWorld.name;
                                    camera.isPortalTransitioning = false;
                                    
                                    // Automatically zoom out after portal transition
                                    setTimeout(() => {
                                        camera.targetZoom = 1.0;
                                        camera.isZooming = true;
                                    }, 200); // Small delay to let player see where they arrived
                                }, 500);
                                break;
                            }
                        }
                    }
                }
                
                if (!camera.isTransitioning) {
                    var oldZoom = camera.zoom;
                    camera.zoom += (camera.targetZoom - camera.zoom) * camera.zoomSpeed;
                    
                    if (camera.isZooming && Math.abs(oldZoom - camera.zoom) > 0.001) {
                        var mouseOffsetX = camera.zoomMouseX - canvas.width / 2;
                        var mouseOffsetY = camera.zoomMouseY - canvas.height / 2;
                        
                        camera.x += mouseOffsetX * (1/camera.zoom - 1/oldZoom);
                        camera.y += mouseOffsetY * (1/camera.zoom - 1/oldZoom);
                    }
                    
                    if (Math.abs(camera.targetZoom - camera.zoom) < 0.001) {
                        camera.isZooming = false;
                    }
                } else {
                    camera.zoom += (camera.targetZoom - camera.zoom) * camera.zoomSpeed;
                }
                
                if (camera.isTransitioning || camera.isPortalTransitioning) {
                    camera.transitionAlpha = Math.min(1, camera.transitionAlpha + 0.05);
                } else {
                    camera.transitionAlpha = Math.max(0, camera.transitionAlpha - 0.05);
                }
                
                if (camera.viewMode === 'ethereal') {
                    renderEtherealMap();
                } else {
                    renderWorldView();
                    
                    // Render smite radius preview when ability is active
                    if (game.abilities.smite.active && hoveredTile && camera.currentWorld) {
                        ctx.save();
                        ctx.translate(canvas.width / 2, canvas.height / 2);
                        ctx.scale(camera.zoom, camera.zoom);
                        ctx.translate(camera.x, camera.y);
                        
                        // Draw center cross
                        const centerIso = worldToIsometric(hoveredTile.x, hoveredTile.y);
                        ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(centerIso.x - 20, centerIso.y);
                        ctx.lineTo(centerIso.x + 20, centerIso.y);
                        ctx.moveTo(centerIso.x, centerIso.y - 20);
                        ctx.lineTo(centerIso.x, centerIso.y + 20);
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                }
                
                if (camera.transitionAlpha > 0) {
                    if (camera.isPortalTransitioning) {
                        renderPortalTransition();
                    } else {
                        renderCloudTransition();
                    }
                }
                
                // Render crystal ball in ethereal view (after all world rendering)
                if (camera.viewMode === 'ethereal') {
                    renderCrystalBallFogTrail();
                    renderCrystalBall();
                }
                
                // Render screen flash effects
                game.divineEffects.forEach(effect => {
                    if (effect instanceof ScreenFlash) {
                        const alpha = effect.intensity * (1 - effect.currentTick / effect.duration);
                        ctx.fillStyle = effect.color === 'gold' ? 
                            `rgba(255, 215, 0, ${alpha})` : 
                            `rgba(255, 255, 255, ${alpha})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                });
                
                // Render sweat particles
                ctx.save();
                game.sweatParticles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    
                    // Draw outer glow
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(173, 216, 230, 0.8)';
                    
                    // Main particle with gradient
                    const gradient = ctx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, particle.size);
                    gradient.addColorStop(0, `rgba(200, 230, 255, ${alpha})`);
                    gradient.addColorStop(0.5, `rgba(173, 216, 230, ${alpha * 0.9})`);
                    gradient.addColorStop(1, `rgba(150, 200, 220, ${alpha * 0.6})`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner highlight
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(particle.x - particle.size * 0.3, particle.y - particle.size * 0.3, particle.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.restore();
                
                if (game.isPaused) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                
                game.frameCount++;
                var now = performance.now();
                if (now - game.lastFpsUpdate > 1000) {
                    game.fps = game.frameCount;
                    game.frameCount = 0;
                    game.lastFpsUpdate = now;
                    document.getElementById('fps').textContent = game.fps;
                }
                
                if (now - game.lastTpsUpdate > 1000) {
                    game.ticksPerSecond = game.tickCount;
                    game.tickCount = 0;
                    game.lastTpsUpdate = now;
                    document.getElementById('tps').textContent = game.ticksPerSecond;
                }
                
                // Update UI every 12 ticks (once per second at 1x speed)
                if (game.currentTick % 12 === 0) {
                    updateUI();
                }

            } catch (error) {
                console.error('Render error:', error);
                console.error('Stack trace:', error.stack);
            }
        }
        
        function gameLoop(timestamp) {
            if (!game.isPaused) {
                var tickInterval = 1000 / game.tickRate;
                var deltaTime = timestamp - game.lastTick;
                deltaTime = Math.min(deltaTime, 1000);
                game.tickAccumulator += deltaTime * game.timeScale;
                
                var ticksThisFrame = 0;
                while (game.tickAccumulator >= tickInterval && ticksThisFrame < game.maxTicksPerFrame) {
                    gameTick();
                    game.tickAccumulator -= tickInterval;
                    ticksThisFrame++;
                }
                
                if (ticksThisFrame >= game.maxTicksPerFrame) {
                    game.tickAccumulator = Math.min(game.tickAccumulator, tickInterval);
                }
            }
            
            game.lastTick = timestamp;
            
            // Check if we need to emit sweat particles (power selected but insufficient)
            let shouldEmitSweat = false;
            
            if (game.abilities.smite.active && game.power < game.abilities.smite.cost) {
                shouldEmitSweat = true;
            } else if (game.abilities.bless.active && hoveredTile && camera.currentWorld) {
                // For blessing, check the cost for the hovered kingdom
                const tile = camera.currentWorld.tiles[hoveredTile.x] && camera.currentWorld.tiles[hoveredTile.x][hoveredTile.y];
                if (tile && tile.owner !== null) {
                    const blessCost = getBlessingCost(tile.owner);
                    if (game.power < blessCost) {
                        shouldEmitSweat = true;
                    }
                }
            } else if (game.abilities.war.active && game.power < game.abilities.war.cost) {
                shouldEmitSweat = true;
            }
            
            if (shouldEmitSweat) {
                game.sweatParticleTimer++;
                
                // Emit particles every 5 frames (about 12 particles per second at 60fps)
                if (game.sweatParticleTimer % 5 === 0) {
                    // Use the tracked mouse position
                    const particleX = mouseX;
                    const particleY = mouseY - 40; // Higher above cursor
                    
                    // Create 4-6 particles
                    const particleCount = 4 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < particleCount; i++) {
                        game.sweatParticles.push(new SweatParticle(
                            particleX + (Math.random() - 0.5) * 30,
                            particleY + Math.random() * 15
                        ));
                    }
                }
            } else {
                game.sweatParticleTimer = 0;
            }
            
            // Always render all effects to prevent flashing
            // The performance optimization should be in the update functions, not rendering
            render(true);
            
            requestAnimationFrame(gameLoop);
        }
        
        try {
            initializeWorlds();
            camera.zoomMouseX = canvas.width / 2;
            camera.zoomMouseY = canvas.height / 2;
            
            game.lastTick = performance.now();
            game.lastTpsUpdate = performance.now();
            
            game.templeCount = 0;
            
            // Initialize crystal ball with a random world
            if (worlds.length > 0) {
                const worldIndex = Math.floor(Math.random() * worlds.length);
                crystalBall.currentWorld = worldIndex;
                crystalBall.lastSwitch = performance.now();
                crystalBall.lastLocationSwitch = performance.now();
                findInterestingLocation(worlds[worldIndex]);
            }
            
            updatePowerDisplay();
            updateSmiteRadius(game.abilities.smite.radius); // Initialize smite UI with default radius
            
            // Initialize smite AOE display
            const smiteAoeDisplay = document.getElementById('smiteAoeDisplay');
            if (smiteAoeDisplay) {
                smiteAoeDisplay.textContent = game.abilities.smite.radius === 25 ? '∞' : game.abilities.smite.radius;
            }
            
            document.getElementById('gameYear').textContent = '1';
            
            requestAnimationFrame(gameLoop);
        } catch (error) {
            console.error('Initialization error:', error);
            console.error('Stack trace:', error.stack);
        }
    </script>
</body>
</html>
